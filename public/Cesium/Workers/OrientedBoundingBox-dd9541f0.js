define(["exports","./buildModuleUrl-c881a5f0","./Cartesian2-4a5e3b0e","./Cartographic-dafe811b","./Cartesian4-58d59766","./Check-07c613bc","./when-207a1520","./Rectangle-49e286b5","./EllipsoidTangentPlane-fb04e18c","./Intersect-4d67bbf5","./Math-bae672f2","./PrimitiveType-44685a19","./Plane-e266b3a4","./PolygonPipeline-63f52c70","./Buffer-bf3c9fbe","./IndexDatatype-447558fc","./ComponentDatatype-662c7548","./GeometryAttribute-9a541822","./RuntimeError-b98f87df","./RenderState-f1428610","./WebGLConstants-8d1e45f7","./FeatureDetection-fc084259","./Color-03dac52c"],(function(e,n,t,o,i,r,a,l,c,s,u,m,f,d,p,h,v,g,_,x,C,y,T){"use strict";function z(e,n,t,o){var i=a.e(n.vertexBuffer),l=a.e(n.value),c=n.value?n.value.length:n.componentsPerAttribute;if(!i&&!l)throw new r.t("attribute must have a vertexBuffer or a value.");if(i&&l)throw new r.t("attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.");if(1!==c&&2!==c&&3!==c&&4!==c)throw l?new r.t("attribute.value.length must be in the range [1, 4]."):new r.t("attribute.componentsPerAttribute must be in the range [1, 4].");if(a.e(n.componentDatatype)&&!v.ComponentDatatype.validate(n.componentDatatype))throw new r.t("attribute must have a valid componentDatatype or not specify it.");if(a.e(n.strideInBytes)&&n.strideInBytes>255)throw new r.t("attribute must have a strideInBytes less than or equal to 255 or not specify it.");if(a.e(n.instanceDivisor)&&n.instanceDivisor>0&&!o.instancedArrays)throw new r.t("instanced arrays is not supported");if(a.e(n.instanceDivisor)&&n.instanceDivisor<0)throw new r.t("attribute must have an instanceDivisor greater than or equal to zero");if(a.e(n.instanceDivisor)&&l)throw new r.t("attribute cannot have have an instanceDivisor if it is not backed by a buffer");if(a.e(n.instanceDivisor)&&n.instanceDivisor>0&&0===n.index)throw new r.t("attribute zero cannot have an instanceDivisor greater than 0");var s={index:a.u(n.index,t),enabled:a.u(n.enabled,!0),vertexBuffer:n.vertexBuffer,value:l?n.value.slice(0):void 0,componentsPerAttribute:c,componentDatatype:a.u(n.componentDatatype,v.ComponentDatatype.FLOAT),normalize:a.u(n.normalize,!1),offsetInBytes:a.u(n.offsetInBytes,0),strideInBytes:a.u(n.strideInBytes,0),instanceDivisor:a.u(n.instanceDivisor,0)};if(i)s.vertexAttrib=function(e){var n=this.index;e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer._getBuffer()),e.vertexAttribPointer(n,this.componentsPerAttribute,this.componentDatatype,this.normalize,this.strideInBytes,this.offsetInBytes),e.enableVertexAttribArray(n),this.instanceDivisor>0&&(o.glVertexAttribDivisor(n,this.instanceDivisor),o._vertexAttribDivisors[n]=this.instanceDivisor,o._previousDrawInstanced=!0)},s.disableVertexAttribArray=function(e){e.disableVertexAttribArray(this.index),this.instanceDivisor>0&&o.glVertexAttribDivisor(t,0)};else{switch(s.componentsPerAttribute){case 1:s.vertexAttrib=function(e){e.vertexAttrib1fv(this.index,this.value)};break;case 2:s.vertexAttrib=function(e){e.vertexAttrib2fv(this.index,this.value)};break;case 3:s.vertexAttrib=function(e){e.vertexAttrib3fv(this.index,this.value)};break;case 4:s.vertexAttrib=function(e){e.vertexAttrib4fv(this.index,this.value)}}s.disableVertexAttribArray=function(e){}}e.push(s)}function b(e,n,t){for(var o=0;o<n.length;++o){var i=n[o];i.enabled&&i.vertexAttrib(e)}a.e(t)&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t._getBuffer())}function w(e){e=a.u(e,a.u.EMPTY_OBJECT),r.o.defined("options.context",e.context),r.o.defined("options.attributes",e.attributes);var n,t=e.context,o=t._gl,i=e.attributes,l=e.indexBuffer,c=[],s=1,u=!1,m=!1,f=i.length;for(n=0;n<f;++n)z(c,i[n],n,t);for(f=c.length,n=0;n<f;++n){var d=c[n];if(a.e(d.vertexBuffer)&&0===d.instanceDivisor){var p=d.strideInBytes||d.componentsPerAttribute*v.ComponentDatatype.getSizeInBytes(d.componentDatatype);s=d.vertexBuffer.sizeInBytes/p;break}}for(n=0;n<f;++n)c[n].instanceDivisor>0&&(u=!0),a.e(c[n].value)&&(m=!0);var h,g={};for(n=0;n<f;++n){var _=c[n].index;if(g[_])throw new r.t("Index "+_+" is used by more than one attribute.");g[_]=!0}t.vertexArrayObject&&(h=t.glCreateVertexArray(),t.glBindVertexArray(h),b(o,c,l),t.glBindVertexArray(null)),this._numberOfVertices=s,this._hasInstancedAttributes=u,this._hasConstantAttributes=m,this._context=t,this._gl=o,this._vao=h,this._attributes=c,this._indexBuffer=l}function S(e){return e.values.length/e.componentsPerAttribute}function L(e){return v.ComponentDatatype.getSizeInBytes(e.componentDatatype)*e.componentsPerAttribute}function E(e){e=a.u(e,a.u.EMPTY_OBJECT),this._boundingVolume=e.boundingVolume,this._orientedBoundingBox=e.orientedBoundingBox,this._cull=a.u(e.cull,!0),this._occlude=a.u(e.occlude,!0),this._modelMatrix=e.modelMatrix,this._primitiveType=a.u(e.primitiveType,m._0x102869.TRIANGLES),this._vertexArray=e.vertexArray,this._count=e.count,this._offset=a.u(e.offset,0),this._instanceCount=a.u(e.instanceCount,0),this._shaderProgram=e.shaderProgram,this._uniformMap=e.uniformMap,this._renderState=e.renderState,this._framebuffer=e.framebuffer,this._pass=e.pass,this._executeInClosestFrustum=a.u(e.executeInClosestFrustum,!1),this._owner=e.owner,this._debugShowBoundingVolume=a.u(e.debugShowBoundingVolume,!1),this._debugOverlappingFrustums=0,this._castShadows=a.u(e.castShadows,!1),this._receiveShadows=a.u(e.receiveShadows,!1),this._selectCastShadows=!1,this._pickId=e.pickId,this._pickOnly=a.u(e.pickOnly,!1),this.dirty=!0,this.lastDirtyTime=0,this.derivedCommands={},this._uniformBuffers=[]}function D(e,n){var t=/#define OUTPUT_DECLARATION/,o=e.split("\n");if(/#version 300 es/g.test(e))return e;var i,l,c=-1;for(i=0;i<o.length;++i)if(l=o[i],t.test(l)){c=i;break}if(-1===c)throw new r.t("Could not find a #define OUTPUT_DECLARATION!");var s=[];for(i=0;i<10;i++){var u="gl_FragData\\["+i+"\\]",m="czm_out"+i;new RegExp(u,"g").test(e)&&(I(m,s),A(u,m,o),o.splice(c,0,"layout(location = "+i+") out vec4 "+m+";"),c+=1)}var f="czm_fragColor";(function(e,n){for(var t=new RegExp("(^|[^\\w])("+e+")($|[^\\w])","g"),o=n.length,i=0;i<o;++i){var r=n[i];if(t.test(r))return!0}return!1})("gl_FragColor",o)&&(I(f,s),A("gl_FragColor",f,o),o.splice(c,0,"layout(location = 0) out vec4 czm_fragColor;"),c+=1);var d=function(e,n){for(var t={},o=e.length,i=[],r=0;r<n.length;++r){var l=n[r],c=/(#ifdef|#if)/g.test(l),s=/#else/g.test(l),u=/#endif/g.test(l);if(c)i.push(l);else if(s){var m=i[i.length-1].replace("ifdef","ifndef");/if/g.test(m)&&(m=m.replace(/(#if\s+)(\S*)([^]*)/,"$1!($2)$3")),i.pop(),i.push(m)}else if(u)i.pop();else if(!/layout/g.test(l))for(var f=0;f<o;++f){var d=e[f];-1!==l.indexOf(d)&&(a.e(t[d])?t[d]=t[d].filter((function(e){return i.indexOf(e)>=0})):t[d]=i.slice())}}return t}(s,o),p={};for(i=0;i<o.length;i++)for(var h in l=o[i],d)if(d.hasOwnProperty(h)){new RegExp("(layout)[^]+(out)[^]+("+h+")[^]+","g").test(l)&&(p[l]=h)}for(var v in p)if(p.hasOwnProperty(v)){var g,_=p[v],x=o.indexOf(v),C=d[_],y=C.length;for(g=0;g<y;g++)o.splice(x,0,C[g]);for(x+=y+1,g=y-1;g>=0;g--)o.splice(x,0,"#endif //"+C[g])}var T="#version 300 es",z=!1;for(i=0;i<o.length;i++)/#version/.test(o[i])&&(o[i]=T,z=!0);return z||o.splice(0,0,T),V("EXT_draw_buffers",o),V("EXT_frag_depth",o),A("texture2D","texture",o),A("texture3D","texture",o),A("textureCube","texture",o),A("gl_FragDepthEXT","gl_FragDepth",o),n?A("varying","in",o):(A("attribute","in",o),A("varying","out",o)),function(e){for(var n="",t=e.length,o=0;o<t;++o)n+=e[o]+"\n";return n}(o)}function A(e,n,t){for(var o=new RegExp("(^|[^\\w])("+e+")($|[^\\w])","g"),i=t.length,r=0;r<i;++r){var a=t[r];t[r]=a.replace(o,"$1"+n+"$3")}}function I(e,n){-1===n.indexOf(e)&&n.push(e)}function V(e,n){!function(e,n,t){for(var o=t.length,i=0;i<o;++i){var r=t[i];t[i]=r.replace(e,n)}}(new RegExp("#extension\\s+GL_"+e+"\\s+:\\s+[a-zA-Z0-9]+\\s*$","g"),"",n)}w.fromGeometry=function(e){e=a.u(e,a.u.EMPTY_OBJECT),r.o.defined("options.context",e.context);var n,t,o,i=e.context,l=a.u(e.geometry,a.u.EMPTY_OBJECT),c=a.u(e.bufferUsage,p.A.DYNAMIC_DRAW),s=a.u(e.attributeLocations,a.u.EMPTY_OBJECT),m=a.u(e.interleave,!1),f=e.vertexArrayAttributes,d=a.e(f)?f:[],x=l.attributes;if(m){var C=function(e){var n,t,o,i=[];for(t in e)e.hasOwnProperty(t)&&a.e(e[t])&&a.e(e[t].values)&&(i.push(t),e[t].componentDatatype===v.ComponentDatatype.DOUBLE&&(e[t].componentDatatype=v.ComponentDatatype.FLOAT,e[t].values=v.ComponentDatatype.createTypedArray(v.ComponentDatatype.FLOAT,e[t].values)));var r,l=i.length;if(l>0)for(r=S(e[i[0]]),n=1;n<l;++n){var c=S(e[i[n]]);if(c!==r)throw new _.t("Each attribute list must have the same number of vertices.  Attribute "+i[n]+" has a different number of vertices ("+c.toString()+") than attribute "+i[0]+" ("+r.toString()+").")}i.sort((function(n,t){return v.ComponentDatatype.getSizeInBytes(e[t].componentDatatype)-v.ComponentDatatype.getSizeInBytes(e[n].componentDatatype)}));var s=0,u={};for(n=0;n<l;++n)t=i[n],o=e[t],u[t]=s,s+=L(o);if(s>0){var m=v.ComponentDatatype.getSizeInBytes(e[i[0]].componentDatatype),f=s%m;0!==f&&(s+=m-f);var d=new ArrayBuffer(r*s),p={};for(n=0;n<l;++n){t=i[n];var h=v.ComponentDatatype.getSizeInBytes(e[t].componentDatatype);p[t]={pointer:v.ComponentDatatype.createTypedArray(e[t].componentDatatype,d),index:u[t]/h,strideInComponentType:s/h}}for(n=0;n<r;++n)for(var g=0;g<l;++g){t=i[g];for(var x=(o=e[t]).values,C=p[t],y=C.pointer,T=o.componentsPerAttribute,z=0;z<T;++z)y[C.index+z]=x[n*T+z];C.index+=C.strideInComponentType}return{buffer:d,offsetsInBytes:u,vertexSizeInBytes:s}}}(x);if(a.e(C)){o=p.h.createVertexBuffer({context:i,typedArray:C.buffer,usage:c});var y=C.offsetsInBytes,T=C.vertexSizeInBytes;for(n in x)x.hasOwnProperty(n)&&a.e(x[n])&&(t=x[n],a.e(t.values)?d.push({index:s[n],vertexBuffer:o,componentDatatype:t.componentDatatype,componentsPerAttribute:t.componentsPerAttribute,normalize:t.normalize,offsetInBytes:y[n],strideInBytes:T}):d.push({index:s[n],value:t.value,componentDatatype:t.componentDatatype,normalize:t.normalize}))}}else for(n in x)if(x.hasOwnProperty(n)&&a.e(x[n])){var z=(t=x[n]).componentDatatype;z===v.ComponentDatatype.DOUBLE&&(z=v.ComponentDatatype.FLOAT),o=void 0,a.e(t.values)&&(o=p.h.createVertexBuffer({context:i,typedArray:v.ComponentDatatype.createTypedArray(z,t.values),usage:c})),d.push({index:s[n],vertexBuffer:o,value:t.value,componentDatatype:z,componentsPerAttribute:t.componentsPerAttribute,normalize:t.normalize})}var b,E=l.indices;return a.e(E)&&(b=g.I.computeNumberOfVertices(l)>=u.e.SIXTY_FOUR_KILOBYTES&&i.elementIndexUint?p.h.createIndexBuffer({context:i,typedArray:new Uint32Array(E),usage:c,indexDatatype:h.IndexDatatype.UNSIGNED_INT}):p.h.createIndexBuffer({context:i,typedArray:new Uint16Array(E),usage:c,indexDatatype:h.IndexDatatype.UNSIGNED_SHORT})),new w({context:i,attributes:d,indexBuffer:b})},Object.defineProperties(w.prototype,{numberOfAttributes:{get:function(){return this._attributes.length}},numberOfVertices:{get:function(){return this._numberOfVertices}},indexBuffer:{get:function(){return this._indexBuffer}}}),w.prototype.getAttribute=function(e){return r.o.defined("index",e),this._attributes[e]},w.prototype._bind=function(){a.e(this._vao)?(this._context.glBindVertexArray(this._vao),this._context.instancedArrays&&function(e){var n=e._context,t=e._hasInstancedAttributes;if(t||n._previousDrawInstanced){n._previousDrawInstanced=t;var o,i=n._vertexAttribDivisors,r=e._attributes,a=x.e.maximumVertexAttributes;if(t){var l=r.length;for(o=0;o<l;++o){var c=r[o];if(c.enabled){var s=c.instanceDivisor,u=c.index;s!==i[u]&&(n.glVertexAttribDivisor(u,s),i[u]=s)}}}else for(o=0;o<a;++o)i[o]>0&&(n.glVertexAttribDivisor(o,0),i[o]=0)}}(this),this._hasConstantAttributes&&function(e,n){for(var t=e._attributes,o=t.length,i=0;i<o;++i){var r=t[i];r.enabled&&a.e(r.value)&&r.vertexAttrib(n)}}(this,this._gl)):b(this._gl,this._attributes,this._indexBuffer)},w.prototype._unBind=function(){if(a.e(this._vao))this._context.glBindVertexArray(null);else{for(var e=this._attributes,n=this._gl,t=0;t<e.length;++t){var o=e[t];o.enabled&&o.disableVertexAttribArray(n)}this._indexBuffer&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)}},w.prototype.isDestroyed=function(){return!1},w.prototype.destroy=function(){for(var e=this._attributes,n=0;n<e.length;++n){var t=e[n].vertexBuffer;a.e(t)&&!t.isDestroyed()&&t.vertexArrayDestroyable&&t.destroy()}var o=this._indexBuffer;return a.e(o)&&!o.isDestroyed()&&o.vertexArrayDestroyable&&o.destroy(),a.e(this._vao)&&this._context.glDeleteVertexArray(this._vao),p.i(this)},Object.defineProperties(E.prototype,{boundingVolume:{get:function(){return this._boundingVolume},set:function(e){this._boundingVolume!==e&&(this._boundingVolume=e,this.dirty=!0)}},orientedBoundingBox:{get:function(){return this._orientedBoundingBox},set:function(e){this._orientedBoundingBox!==e&&(this._orientedBoundingBox=e,this.dirty=!0)}},cull:{get:function(){return this._cull},set:function(e){this._cull!==e&&(this._cull=e,this.dirty=!0)}},occlude:{get:function(){return this._occlude},set:function(e){this._occlude!==e&&(this._occlude=e,this.dirty=!0)}},modelMatrix:{get:function(){return this._modelMatrix},set:function(e){this._modelMatrix!==e&&(this._modelMatrix=e,this.dirty=!0)}},primitiveType:{get:function(){return this._primitiveType},set:function(e){this._primitiveType!==e&&(this._primitiveType=e,this.dirty=!0)}},vertexArray:{get:function(){return this._vertexArray},set:function(e){this._vertexArray!==e&&(this._vertexArray=e,this.dirty=!0)}},count:{get:function(){return this._count},set:function(e){this._count!==e&&(this._count=e,this.dirty=!0)}},offset:{get:function(){return this._offset},set:function(e){this._offset!==e&&(this._offset=e,this.dirty=!0)}},instanceCount:{get:function(){return this._instanceCount},set:function(e){this._instanceCount!==e&&(this._instanceCount=e,this.dirty=!0)}},shaderProgram:{get:function(){return this._shaderProgram},set:function(e){this._shaderProgram!==e&&(this._shaderProgram=e,this.dirty=!0)}},castShadows:{get:function(){return this._castShadows},set:function(e){this._castShadows!==e&&(this._castShadows=e,this.dirty=!0)}},selectCastShadows:{get:function(){return this._selectCastShadows},set:function(e){this._selectCastShadows!==e&&(this._selectCastShadows=e,this.dirty=!0)}},receiveShadows:{get:function(){return this._receiveShadows},set:function(e){this._receiveShadows!==e&&(this._receiveShadows=e,this.dirty=!0)}},uniformMap:{get:function(){return this._uniformMap},set:function(e){this._uniformMap!==e&&(this._uniformMap=e,this.dirty=!0)}},renderState:{get:function(){return this._renderState},set:function(e){this._renderState!==e&&(this._renderState=e,this.dirty=!0)}},framebuffer:{get:function(){return this._framebuffer},set:function(e){this._framebuffer!==e&&(this._framebuffer=e,this.dirty=!0)}},pass:{get:function(){return this._pass},set:function(e){this._pass!==e&&(this._pass=e,this.dirty=!0)}},executeInClosestFrustum:{get:function(){return this._executeInClosestFrustum},set:function(e){this._executeInClosestFrustum!==e&&(this._executeInClosestFrustum=e,this.dirty=!0)}},owner:{get:function(){return this._owner},set:function(e){this._owner!==e&&(this._owner=e,this.dirty=!0)}},debugShowBoundingVolume:{get:function(){return this._debugShowBoundingVolume},set:function(e){this._debugShowBoundingVolume!==e&&(this._debugShowBoundingVolume=e,this.dirty=!0)}},debugOverlappingFrustums:{get:function(){return this._debugOverlappingFrustums},set:function(e){this._debugOverlappingFrustums!==e&&(this._debugOverlappingFrustums=e,this.dirty=!0)}},pickId:{get:function(){return this._pickId},set:function(e){this._pickId!==e&&(this._pickId=e,this.dirty=!0)}},pickOnly:{get:function(){return this._pickOnly},set:function(e){this._pickOnly!==e&&(this._pickOnly=e,this.dirty=!0)}}}),E.prototype.addUniformBuffer=function(e){e.increaseRef(),this._uniformBuffers.push(e)},E.prototype.removeAllUniformBuffer=function(){if(a.e(this._uniformBuffers)){for(var e=0;e<this._uniformBuffers.length;e++)this._uniformBuffers[e].decreaseRef();this._uniformBuffers=[]}},E.shallowClone=function(e,n){if(a.e(e))return a.e(n)||(n=new E),n._boundingVolume=e._boundingVolume,n._orientedBoundingBox=e._orientedBoundingBox,n._cull=e._cull,n._occlude=e._occlude,n._modelMatrix=e._modelMatrix,n._primitiveType=e._primitiveType,n._vertexArray=e._vertexArray,n._count=e._count,n._offset=e._offset,n._instanceCount=e._instanceCount,n._shaderProgram=e._shaderProgram,n._uniformMap=e._uniformMap,n._uniformBuffers=e._uniformBuffers,n._renderState=e._renderState,n._framebuffer=e._framebuffer,n._pass=e._pass,n._executeInClosestFrustum=e._executeInClosestFrustum,n._owner=e._owner,n._debugShowBoundingVolume=e._debugShowBoundingVolume,n._debugOverlappingFrustums=e._debugOverlappingFrustums,n._castShadows=e._castShadows,n._receiveShadows=e._receiveShadows,n._selectCastShadows=e._selectCastShadows,n._pickId=e._pickId,n._pickOnly=e._pickOnly,n._pointCloudEyeDomeLighting=e._pointCloudEyeDomeLighting,n.dirty=!0,n.lastDirtyTime=0,n},E.prototype.execute=function(e,n){e.draw(this,n)};var M=new o.t;function P(e){this._size=e.size,this._datatype=e.datatype,this.getValue=e.getValue}var R={};R[C.B.FLOAT]="float",R[C.B.FLOAT_VEC2]="vec2",R[C.B.FLOAT_VEC3]="vec3",R[C.B.FLOAT_VEC4]="vec4",R[C.B.INT]="int",R[C.B.INT_VEC2]="ivec2",R[C.B.INT_VEC3]="ivec3",R[C.B.INT_VEC4]="ivec4",R[C.B.BOOL]="bool",R[C.B.BOOL_VEC2]="bvec2",R[C.B.BOOL_VEC3]="bvec3",R[C.B.BOOL_VEC4]="bvec4",R[C.B.FLOAT_MAT2]="mat2",R[C.B.FLOAT_MAT3]="mat3",R[C.B.FLOAT_MAT4]="mat4",R[C.B.SAMPLER_2D]="sampler2D",R[C.B.SAMPLER_CUBE]="samplerCube",P.prototype.getDeclaration=function(e){var n="uniform "+R[this._datatype]+" "+e,t=this._size;return n+=1===t?";":"["+t.toString()+"];"};var O={czm_viewport:new P({size:1,datatype:C.B.FLOAT_VEC4,getValue:function(e){return e.viewportCartesian4}}),czm_viewportOrthographic:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.viewportOrthographic}}),czm_viewportTransformation:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.viewportTransformation}}),czm_globeDepthTexture:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.globeDepthTexture}}),czm_model:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.model}}),czm_inverseModel:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseModel}}),czm_view:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.view}}),czm_view3D:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.view3D}}),czm_viewRotation:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.viewRotation}}),czm_viewRotation3D:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.viewRotation3D}}),czm_inverseView:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseView}}),czm_inverseView3D:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseView3D}}),czm_inverseViewRotation:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.inverseViewRotation}}),czm_inverseViewRotation3D:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.inverseViewRotation3D}}),czm_projection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.projection}}),czm_inverseProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseProjection}}),czm_infiniteProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.infiniteProjection}}),czm_modelView:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelView}}),czm_modelView3D:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelView3D}}),czm_modelViewRelativeToEye:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelViewRelativeToEye}}),czm_inverseModelView:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseModelView}}),czm_inverseModelView3D:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseModelView3D}}),czm_viewProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.viewProjection}}),czm_inverseViewProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseViewProjection}}),czm_modelViewProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelViewProjection}}),czm_inverseModelViewProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseModelViewProjection}}),czm_modelViewProjectionRelativeToEye:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelViewProjectionRelativeToEye}}),czm_modelViewInfiniteProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelViewInfiniteProjection}}),czm_orthographicIn3D:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.orthographicIn3D?1:0}}),czm_normal:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.normal}}),czm_normal3D:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.normal3D}}),czm_inverseNormal:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.inverseNormal}}),czm_inverseNormal3D:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.inverseNormal3D}}),czm_eyeHeight2D:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.eyeHeight2D}}),czm_entireFrustum:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.entireFrustum}}),czm_currentFrustum:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.currentFrustum}}),czm_frustumPlanes:new P({size:1,datatype:C.B.FLOAT_VEC4,getValue:function(e){return e.frustumPlanes}}),czm_farDepthFromNearPlusOne:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.farDepthFromNearPlusOne}}),czm_log2FarDepthFromNearPlusOne:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.log2FarDepthFromNearPlusOne}}),czm_oneOverLog2FarDepthFromNearPlusOne:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.oneOverLog2FarDepthFromNearPlusOne}}),czm_sunPositionWC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sunPositionWC}}),czm_sunPositionColumbusView:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sunPositionColumbusView}}),czm_sunDirectionEC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sunDirectionEC}}),czm_sunDirectionWC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sunDirectionWC}}),czm_moonDirectionEC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.moonDirectionEC}}),czm_lightDirectionEC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.lightDirectionEC}}),czm_lightDirectionWC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.lightDirectionWC}}),czm_lightColor:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.lightColor}}),czm_lightColorHdr:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.lightColorHdr}}),czm_encodedCameraPositionMCHigh:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.encodedCameraPositionMCHigh}}),czm_encodedCameraPositionMCLow:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.encodedCameraPositionMCLow}}),czm_cameraPositionWC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e._cameraPosition}}),czm_viewerPositionWC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return m.y.getTranslation(e.inverseView,M)}}),czm_frameNumber:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.frameState.frameNumber}}),czm_morphTime:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.frameState.morphTime}}),czm_sceneMode:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.frameState.mode}}),czm_pass:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.pass}}),czm_backgroundColor:new P({size:1,datatype:C.B.FLOAT_VEC4,getValue:function(e){return e.backgroundColor}}),czm_brdfLut:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.brdfLut}}),czm_environmentMap:new P({size:1,datatype:C.B.SAMPLER_CUBE,getValue:function(e){return e.environmentMap}}),czm_specularEnvironmentMaps:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.specularEnvironmentMaps}}),czm_specularEnvironmentMapSize:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.specularEnvironmentMapsDimensions}}),czm_specularEnvironmentMapsMaximumLOD:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.specularEnvironmentMapsMaximumLOD}}),czm_sphericalHarmonicCoefficients:new P({size:9,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sphericalHarmonicCoefficients}}),czm_SH:new P({size:7,datatype:C.B.FLOAT_VEC4,getValue:function(e){return e.sphericalHarmonics.shArr}}),czm_temeToPseudoFixed:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.temeToPseudoFixedMatrix}}),czm_pixelRatio:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.pixelRatio}}),czm_resolutionScale:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.resolutionScale}}),czm_fogDensity:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.fogDensity}}),czm_imagerySplitPosition:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.imagerySplitPosition}}),czm_globeSplitPosition:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.globeSplitPosition}}),czm_geometricToleranceOverMeter:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.geometricToleranceOverMeter}}),czm_minimumDisableDepthTestDistance:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.minimumDisableDepthTestDistance}}),czm_invertClassificationColor:new P({size:1,datatype:C.B.FLOAT_VEC4,getValue:function(e){return e.invertClassificationColor}}),czm_gamma:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.gamma}}),czm_sunColor:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sunColor}}),czm_globeDepthTextureDim:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.globeDepthTextureDim}}),czm_nonSelDepthTexture:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.nonSelDepthTexture}}),czm_maskTexture:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.maskTexture}}),czm_hdrEnvMap:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.hdrEnvMap}}),czm_toneMappingExposure:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.toneMappingExposure}})};function F(e){}function B(e){this.ifIndex=a.e(e.ifIndex)?e.ifIndex:void 0,this.elseIndex=a.e(e.elseIndex)?e.elseIndex:void 0,this.endIndex=a.e(e.endIndex)?e.endIndex:void 0,this.ifChildTokens=[],this.elseChildTokens=[],this.parentToken=a.e(e.parentToken)?e.parentToken:void 0,this.type=a.e(e.type)?e.type:void 0}function N(e,n){this.Key=e,this.String=n,this.StringLength=n.length}F.removeUnuseMacroCode=function(e,n,t){if(!function(e){return!(e.indexOf("defined",0)>=0||e.indexOf("#if ",0)>=0||e.indexOf("#elif ",0)>=0)}(t))return t;var o=function(e){for(var n=[],t=0,o=0,i=void 0;-1!==t;){var r=G(e,o);if(o=(t=r.findIndex)+r.type.StringLength,-1===t)break;switch(r.type.Key){case H.TK_IFDEF.Key:case H.TK_IFNEF.Key:var l=new B({type:r.type,ifIndex:t});a.e(i)?a.e(i.endIndex)?(a.e(i.parentToken)||n.push(l),i=l):(i.addChildToken(l),l.parentToken=i,i=l):(i=l,n.push(l));break;case H.TK_ELSE.Key:if(!a.e(i))continue;i.elseIndex=t;break;case H.TK_END.Key:if(!a.e(i))continue;i.endIndex=t,a.e(i.parentToken)&&(i=i.parentToken)}}return n}(t),i=[];return function(e,n,t,o,i){if(0!==t.length)for(var r=function(e,n,t){var o=n.defines,i={};if(a.e(o))for(var r=0;r<o.length;++r){i[o[r]]=1}if(a.e(e._sysShaderDefines))for(r=0;r<e._sysShaderDefines.length;++r){i[e._sysShaderDefines[r]]=1}for(var l=0,c=0;-1!==l&&-1!==(l=t.indexOf("#define ",c));){var s=l+8,u=t.indexOf("\n",l);i[t.substring(s,u).trim()]=1,c=u}return i}(e,n,o),l=0;l<t.length;l++){k(t[l],r,o,i)}}(e,n,o,t,i),function(e,n){for(var t=e,o=0;o<n.length;o++){var i=n[o];if(i.endIndex-i.startIndex>1){var r=e.substring(i.startIndex,i.endIndex);t=t.replace(r,"")}}return t.replace(/(#ifdef|#ifndef|#else|#endif).*/gm,"")}(t,i)},B.prototype.addChildToken=function(e){a.e(this.elseIndex)?this.elseChildTokens.push(e):this.ifChildTokens.push(e)},N.isEqual=function(e,n){return e.Key===n.Key};var H={TK_IFDEF:new N(0,"#ifdef"),TK_IFNEF:new N(1,"#ifndef"),TK_ELSE:new N(2,"#else"),TK_END:new N(3,"#endif")};function G(e,n){var t=-1,o=H.TK_IFDEF;for(var i in H){var r=H[i],a=e.indexOf(r.String,n);(-1===t||a>=0&&a<t)&&(t=a,o=r)}return{type:o,findIndex:t}}function k(e,n,t,o){var i=0,r=function(e,n,t){var o=e.indexOf("\n",t+n+1),i=t+n+1;return e.substring(i,o)}(t,e.type.StringLength,e.ifIndex),l=function(e,n,t){return!(!N.isEqual(t,H.TK_IFDEF)||!a.e(e[n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")]))||!(!N.isEqual(t,H.TK_IFNEF)||a.e(e[n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")]))}(n,r,e.type);if(l){a.e(e.elseIndex)&&(i=e.elseIndex+H.TK_ELSE.StringLength+1,o.push({startIndex:i,endIndex:e.endIndex}));for(var c=0;c<e.ifChildTokens.length;c++)k(e.ifChildTokens[c],n,t,o)}else{a.e(e.elseIndex)?o.push({startIndex:e.ifIndex+e.type.StringLength+U(t,e.ifIndex,e.type.String)+r.length,endIndex:e.elseIndex}):o.push({startIndex:e.ifIndex,endIndex:e.endIndex+H.TK_END.StringLength});for(c=0;c<e.elseChildTokens.length;c++)k(e.elseChildTokens[c],n,t,o)}}function U(e,n,t){for(var o=t.length,i=n+o;i<e.length;i++){if(" "!==e.charAt(i))break}return i-(n+o)}var W={czm_degreesPerRadian:"/**\n * A built-in GLSL floating-point constant for converting radians to degrees.\n *\n * @alias czm_degreesPerRadian\n * @glslConstant\n *\n * @see CesiumMath.DEGREES_PER_RADIAN\n *\n * @example\n * // GLSL declaration\n * const float czm_degreesPerRadian = ...;\n *\n * // Example\n * float deg = czm_degreesPerRadian * rad;\n */\nconst float czm_degreesPerRadian = 57.29577951308232;\n",czm_depthRange:"/**\n * A built-in GLSL vec2 constant for defining the depth range.\n * This is a workaround to a bug where IE11 does not implement gl_DepthRange.\n *\n * @alias czm_depthRange\n * @glslConstant\n *\n * @example\n * // GLSL declaration\n * float depthRangeNear = czm_depthRange.near;\n * float depthRangeFar = czm_depthRange.far;\n *\n */\nconst czm_depthRangeStruct czm_depthRange = czm_depthRangeStruct(0.0, 1.0);\n",czm_ellipsoidInverseRadii:"/**\n * The reciprocal of the radius of the WGS84 ellipsoid.\n *\n * @name czm_ellipsoidInverseRadii\n * @glslConstant\n */\nconst vec3 czm_ellipsoidInverseRadii = vec3(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.314245);\n",czm_ellipsoidRadii:"/**\n * The radius of the WGS84 ellipsoid.\n *\n * @name czm_ellipsoidRadii\n * @glslConstant\n */\nconst vec3 czm_ellipsoidRadii = vec3(6378137.0, 6378137.0, 6356752.314245);\n",czm_epsilon1:"/**\n * 0.1\n *\n * @name czm_epsilon1\n * @glslConstant\n */\nconst float czm_epsilon1 = 0.1;\n",czm_epsilon2:"/**\n * 0.01\n *\n * @name czm_epsilon2\n * @glslConstant\n */\nconst float czm_epsilon2 = 0.01;\n",czm_epsilon3:"/**\n * 0.001\n *\n * @name czm_epsilon3\n * @glslConstant\n */\nconst float czm_epsilon3 = 0.001;\n",czm_epsilon4:"/**\n * 0.0001\n *\n * @name czm_epsilon4\n * @glslConstant\n */\nconst float czm_epsilon4 = 0.0001;\n",czm_epsilon5:"/**\n * 0.00001\n *\n * @name czm_epsilon5\n * @glslConstant\n */\nconst float czm_epsilon5 = 0.00001;\n",czm_epsilon6:"/**\n * 0.000001\n *\n * @name czm_epsilon6\n * @glslConstant\n */\nconst float czm_epsilon6 = 0.000001;\n",czm_epsilon7:"/**\n * 0.0000001\n *\n * @name czm_epsilon7\n * @glslConstant\n */\nconst float czm_epsilon7 = 0.0000001;\n",czm_infinity:"/**\n * DOC_TBA\n *\n * @name czm_infinity\n * @glslConstant\n */\nconst float czm_infinity = 5906376272000.0;  // Distance from the Sun to Pluto in meters.  TODO: What is best given lowp, mediump, and highp?\n",czm_oneOverPi:"/**\n * A built-in GLSL floating-point constant for <code>1/pi</code>.\n *\n * @alias czm_oneOverPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverPi = ...;\n *\n * // Example\n * float pi = 1.0 / czm_oneOverPi;\n */\nconst float czm_oneOverPi = 0.3183098861837907;\n",czm_oneOverTwoPi:"/**\n * A built-in GLSL floating-point constant for <code>1/2pi</code>.\n *\n * @alias czm_oneOverTwoPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverTwoPi = ...;\n *\n * // Example\n * float pi = 2.0 * czm_oneOverTwoPi;\n */\nconst float czm_oneOverTwoPi = 0.15915494309189535;\n",czm_passCesium3DTile:"/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE}\n *\n * @name czm_passCesium3DTile\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTile = 4.0;\n",czm_passCesium3DTileClassification:"/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION}\n *\n * @name czm_passCesium3DTileClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTileClassification = 5.0;\n",czm_passCesium3DTileClassificationIgnoreShow:"/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW}\n *\n * @name czm_passCesium3DTileClassificationIgnoreShow\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTileClassificationIgnoreShow = 6.0;\n",czm_passClassification:"/**\n * The automatic GLSL constant for {@link Pass#CLASSIFICATION}\n *\n * @name czm_passClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passClassification = 7.0;\n",czm_passCompute:"/**\n * The automatic GLSL constant for {@link Pass#COMPUTE}\n *\n * @name czm_passCompute\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCompute = 1.0;\n",czm_passEnvironment:"/**\n * The automatic GLSL constant for {@link Pass#ENVIRONMENT}\n *\n * @name czm_passEnvironment\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passEnvironment = 0.0;\n",czm_passGlobe:"/**\n * The automatic GLSL constant for {@link Pass#GLOBE}\n *\n * @name czm_passGlobe\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passGlobe = 2.0;\n",czm_passGround:"/**\n * The automatic GLSL constant for {@link Pass#GROUND}\n *\n * @name czm_passGround\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passGround = 4.0;\n",czm_passOpaque:"/**\n * The automatic GLSL constant for {@link Pass#OPAQUE}\n *\n * @name czm_passOpaque\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passOpaque = 12.0;\n",czm_passOverlay:"/**\n * The automatic GLSL constant for {@link Pass#OVERLAY}\n *\n * @name czm_passOverlay\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passOverlay = 20.0;",czm_passTerrainClassification:"/**\n * The automatic GLSL constant for {@link Pass#TERRAIN_CLASSIFICATION}\n *\n * @name czm_passTerrainClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passTerrainClassification = 3.0;\n",czm_passTranslucent:"/**\n * The automatic GLSL constant for {@link Pass#TRANSLUCENT}\n *\n * @name czm_passTranslucent\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passTranslucent = 18.0;",czm_pi:"/**\n * A built-in GLSL floating-point constant for <code>Math.PI</code>.\n *\n * @alias czm_pi\n * @glslConstant\n *\n * @see CesiumMath.PI\n *\n * @example\n * // GLSL declaration\n * const float czm_pi = ...;\n *\n * // Example\n * float twoPi = 2.0 * czm_pi;\n */\nconst float czm_pi = 3.141592653589793;\n",czm_piOverFour:"/**\n * A built-in GLSL floating-point constant for <code>pi/4</code>.\n *\n * @alias czm_piOverFour\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_FOUR\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverFour = ...;\n *\n * // Example\n * float pi = 4.0 * czm_piOverFour;\n */\nconst float czm_piOverFour = 0.7853981633974483;\n",czm_piOverSix:"/**\n * A built-in GLSL floating-point constant for <code>pi/6</code>.\n *\n * @alias czm_piOverSix\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_SIX\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverSix = ...;\n *\n * // Example\n * float pi = 6.0 * czm_piOverSix;\n */\nconst float czm_piOverSix = 0.5235987755982988;\n",czm_piOverThree:"/**\n * A built-in GLSL floating-point constant for <code>pi/3</code>.\n *\n * @alias czm_piOverThree\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_THREE\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverThree = ...;\n *\n * // Example\n * float pi = 3.0 * czm_piOverThree;\n */\nconst float czm_piOverThree = 1.0471975511965976;\n",czm_piOverTwo:"/**\n * A built-in GLSL floating-point constant for <code>pi/2</code>.\n *\n * @alias czm_piOverTwo\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverTwo = ...;\n *\n * // Example\n * float pi = 2.0 * czm_piOverTwo;\n */\nconst float czm_piOverTwo = 1.5707963267948966;\n",czm_radiansPerDegree:"/**\n * A built-in GLSL floating-point constant for converting degrees to radians.\n *\n * @alias czm_radiansPerDegree\n * @glslConstant\n *\n * @see CesiumMath.RADIANS_PER_DEGREE\n *\n * @example\n * // GLSL declaration\n * const float czm_radiansPerDegree = ...;\n *\n * // Example\n * float rad = czm_radiansPerDegree * deg;\n */\nconst float czm_radiansPerDegree = 0.017453292519943295;\n",czm_sceneMode2D:"/**\n * The constant identifier for the 2D {@link SceneMode}\n *\n * @name czm_sceneMode2D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode2D = 2.0;\n",czm_sceneMode3D:"/**\n * The constant identifier for the 3D {@link SceneMode}\n *\n * @name czm_sceneMode3D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode3D = 3.0;\n",czm_sceneModeColumbusView:"/**\n * The constant identifier for the Columbus View {@link SceneMode}\n *\n * @name czm_sceneModeColumbusView\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneModeColumbusView = 1.0;\n",czm_sceneModeMorphing:"/**\n * The constant identifier for the Morphing {@link SceneMode}\n *\n * @name czm_sceneModeMorphing\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n */\nconst float czm_sceneModeMorphing = 0.0;\n",czm_solarRadius:"/**\n * A built-in GLSL floating-point constant for one solar radius.\n *\n * @alias czm_solarRadius\n * @glslConstant\n *\n * @see CesiumMath.SOLAR_RADIUS\n *\n * @example\n * // GLSL declaration\n * const float czm_solarRadius = ...;\n */\nconst float czm_solarRadius = 695500000.0;\n",czm_threePiOver2:"/**\n * A built-in GLSL floating-point constant for <code>3pi/2</code>.\n *\n * @alias czm_threePiOver2\n * @glslConstant\n *\n * @see CesiumMath.THREE_PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_threePiOver2 = ...;\n *\n * // Example\n * float pi = (2.0 / 3.0) * czm_threePiOver2;\n */\nconst float czm_threePiOver2 = 4.71238898038469;\n",czm_twoPi:"/**\n * A built-in GLSL floating-point constant for <code>2pi</code>.\n *\n * @alias czm_twoPi\n * @glslConstant\n *\n * @see CesiumMath.TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_twoPi = ...;\n *\n * // Example\n * float pi = czm_twoPi / 2.0;\n */\nconst float czm_twoPi = 6.283185307179586;\n",czm_webMercatorMaxLatitude:"/**\n * The maximum latitude, in radians, both North and South, supported by a Web Mercator\n * (EPSG:3857) projection.  Technically, the Mercator projection is defined\n * for any latitude up to (but not including) 90 degrees, but it makes sense\n * to cut it off sooner because it grows exponentially with increasing latitude.\n * The logic behind this particular cutoff value, which is the one used by\n * Google Maps, Bing Maps, and Esri, is that it makes the projection\n * square.  That is, the rectangle is equal in the X and Y directions.\n *\n * The constant value is computed as follows:\n *   czm_pi * 0.5 - (2.0 * atan(exp(-czm_pi)))\n *\n * @name czm_webMercatorMaxLatitude\n * @glslConstant\n */\nconst float czm_webMercatorMaxLatitude = 1.4844222297453324;\n",czm_depthRangeStruct:"/**\n * @name czm_depthRangeStruct\n * @glslStruct\n */\nstruct czm_depthRangeStruct\n{\n    float near;\n    float far;\n};\n",czm_ellipsoid:"/** DOC_TBA\n *\n * @name czm_ellipsoid\n * @glslStruct\n */\nstruct czm_ellipsoid\n{\n    vec3 center;\n    vec3 radii;\n    vec3 inverseRadii;\n    vec3 inverseRadiiSquared;\n};\n",czm_material:"/**\n * Holds material information that can be used for lighting. Returned by all czm_getMaterial functions.\n *\n * @name czm_material\n * @glslStruct\n *\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n * @property {float} specular Intensity of incoming light reflecting in a single direction.\n * @property {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n * @property {vec3} normal Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal.\n * @property {vec3} emission Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n * @property {float} alpha Opacity of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n */\nstruct czm_material\n{\n    vec3 diffuse;\n    float specular;\n    float shininess;\n    vec3 normal;\n    vec3 emission;\n    float alpha;\n};\n",czm_materialInput:"/**\n * Used as input to every material's czm_getMaterial function.\n *\n * @name czm_materialInput\n * @glslStruct\n *\n * @property {float} s 1D texture coordinates.\n * @property {vec2} st 2D texture coordinates.\n * @property {vec3} str 3D texture coordinates.\n * @property {vec3} normalEC Unperturbed surface normal in eye coordinates.\n * @property {mat3} tangentToEyeMatrix Matrix for converting a tangent space normal to eye space.\n * @property {vec3} positionToEyeEC Vector from the fragment to the eye in eye coordinates.  The magnitude is the distance in meters from the fragment to the eye.\n * @property {float} height The height of the terrain in meters above or below the WGS84 ellipsoid.  Only available for globe materials.\n * @property {float} slope The slope of the terrain normalized from 0 to 1.  0 is completely vertical, 1 is completely flat.  Only available for globe materials.\n */\nstruct czm_materialInput\n{\n    float s;\n    vec2 st;\n    vec3 str;\n    vec3 normalEC;\n    mat3 tangentToEyeMatrix;\n    vec3 positionToEyeEC;\n    float height;\n    float slope;\n};\n",czm_ray:"/**\n * DOC_TBA\n *\n * @name czm_ray\n * @glslStruct\n */\nstruct czm_ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n",czm_raySegment:"/**\n * DOC_TBA\n *\n * @name czm_raySegment\n * @glslStruct\n */\nstruct czm_raySegment\n{\n    float start;\n    float stop;\n};\n\n/**\n * DOC_TBA\n *\n * @name czm_emptyRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);\n\n/**\n * DOC_TBA\n *\n * @name czm_fullRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);\n",czm_s3mMaterialInput:"struct czm_s3mMaterialInput\n{\n    vec4 ambientColor;\n    vec4 diffuseColor;\n    vec4 ambientLightColor;\n    vec4 sunLightColor;\n    mat4 texMatrix;\n    float texture0Width;\n    float texture1Width;\n    vec3 sunDirectionEC;\n    float sunLightON;\n    vec3 normalWorld;\n    vec3 normalGround;\n    vec3 positionWorld;\n    vec3 sunDirectionWC;\n    vec4 surfaceAlbedo;\n};\n",czm_shadowParameters:"struct czm_shadowParameters\n{\n#ifdef USE_CUBE_MAP_SHADOW\n    vec3 texCoords;\n#else\n    vec2 texCoords;\n#endif\n\n    float depthBias;\n    float depth;\n    float nDotL;\n    vec2 texelStepSize;\n    float normalShadingSmooth;\n    float darkness;\n};\n",czm_acesTonemapping:"// See:\n\nvec3 czm_acesTonemapping(vec3 color) {\n    float g = 0.985;\n    float a = 0.065;\n    float b = 0.0001;\n    float c = 0.433;\n    float d = 0.238;\n\n    color = (color * (color + a) - b) / (color * (g * color + c) + d);\n\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n",czm_adjustColor:"uniform float uBrightness;\nuniform float uContrast;\nuniform float uHue;\nuniform float uSaturation;\nuniform float uOneOverGamma;\nvec3 czm_adjustColor(vec3 inputColor)\n{\n    vec3 outputColor = inputColor;\n    outputColor.rgb = mix(vec3(0.0), outputColor.rgb, uBrightness);\n    outputColor.rgb = mix(vec3(0.5), outputColor.rgb, uContrast);\n    outputColor.rgb = czm_hue(outputColor.rgb, uHue);\n    outputColor.rgb = clamp(outputColor.rgb, 0.0, 1.0);\n    outputColor.rgb = czm_saturation(outputColor.rgb, uSaturation);\n    outputColor.rgb = pow(outputColor.rgb, vec3(uOneOverGamma));\n    return outputColor;\n}",czm_alphaWeight:"/**\n * @private\n */\nfloat czm_alphaWeight(float a)\n{\n    float z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n\n    // See Weighted Blended Order-Independent Transparency for examples of different weighting functions:\n    return pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 0.003 / (1e-5 + pow(abs(z) / 200.0, 4.0))));\n}\n",czm_antialias:"/**\n * Procedural anti-aliasing by blurring two colors that meet at a sharp edge.\n *\n * @name czm_antialias\n * @glslFunction\n *\n * @param {vec4} color1 The color on one side of the edge.\n * @param {vec4} color2 The color on the other side of the edge.\n * @param {vec4} currentcolor The current color, either <code>color1</code> or <code>color2</code>.\n * @param {float} dist The distance to the edge in texture coordinates.\n * @param {float} [fuzzFactor=0.1] Controls the blurriness between the two colors.\n * @returns {vec4} The anti-aliased color.\n *\n * @example\n * // GLSL declarations\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor);\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist);\n *\n * // get the color for a material that has a sharp edge at the line y = 0.5 in texture space\n * float dist = abs(textureCoordinates.t - 0.5);\n * vec4 currentColor = mix(bottomColor, topColor, step(0.5, textureCoordinates.t));\n * vec4 color = czm_antialias(bottomColor, topColor, currentColor, dist, 0.1);\n */\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)\n{\n    float val1 = clamp(dist / fuzzFactor, 0.0, 1.0);\n    float val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);\n    val1 = val1 * (1.0 - val2);\n    val1 = val1 * val1 * (3.0 - (2.0 * val1));\n    val1 = pow(val1, 0.5); //makes the transition nicer\n    \n    vec4 midColor = (color1 + color2) * 0.5;\n    return mix(midColor, currentColor, val1);\n}\n\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)\n{\n    return czm_antialias(color1, color2, currentColor, dist, 0.1);\n}\n",czm_approximateSphericalCoordinates:"/**\n * Approximately computes spherical coordinates given a normal.\n * Uses approximate inverse trigonometry for speed and consistency,\n * since inverse trigonometry can differ from vendor-to-vendor and when compared with the CPU.\n *\n * @name czm_approximateSphericalCoordinates\n * @glslFunction\n *\n * @param {vec3} normal arbitrary-length normal.\n *\n * @returns {vec2} Approximate latitude and longitude spherical coordinates.\n */\nvec2 czm_approximateSphericalCoordinates(vec3 normal) {\n    // Project into plane with vertical for latitude\n    float latitudeApproximation = czm_fastApproximateAtan(sqrt(normal.x * normal.x + normal.y * normal.y), normal.z);\n    float longitudeApproximation = czm_fastApproximateAtan(normal.x, normal.y);\n    return vec2(latitudeApproximation, longitudeApproximation);\n}\n",czm_branchFreeTernary:"/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a float expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {float} a Value to return if the comparison is true.\n * @param {float} b Value to return if the comparison is false.\n *\n * @returns {float} equivalent of comparison ? a : b\n */\nfloat czm_branchFreeTernary(bool comparison, float a, float b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec2 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec2} a Value to return if the comparison is true.\n * @param {vec2} b Value to return if the comparison is false.\n *\n * @returns {vec2} equivalent of comparison ? a : b\n */\nvec2 czm_branchFreeTernary(bool comparison, vec2 a, vec2 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec3 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec3} a Value to return if the comparison is true.\n * @param {vec3} b Value to return if the comparison is false.\n *\n * @returns {vec3} equivalent of comparison ? a : b\n */\nvec3 czm_branchFreeTernary(bool comparison, vec3 a, vec3 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec4 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec3} a Value to return if the comparison is true.\n * @param {vec3} b Value to return if the comparison is false.\n *\n * @returns {vec3} equivalent of comparison ? a : b\n */\nvec4 czm_branchFreeTernary(bool comparison, vec4 a, vec4 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n",czm_cascadeColor:"\nvec4 czm_cascadeColor(vec4 weights)\n{\n    return vec4(1.0, 0.0, 0.0, 1.0) * weights.x +\n           vec4(0.0, 1.0, 0.0, 1.0) * weights.y +\n           vec4(0.0, 0.0, 1.0, 1.0) * weights.z +\n           vec4(1.0, 0.0, 1.0, 1.0) * weights.w;\n}\n",czm_cascadeDistance:"\nuniform vec4 shadowMap_cascadeDistances;\n\nfloat czm_cascadeDistance(vec4 weights)\n{\n    return dot(shadowMap_cascadeDistances, weights);\n}\n",czm_cascadeMatrix:"\nuniform mat4 shadowMap_cascadeMatrices[4];\n\nmat4 czm_cascadeMatrix(vec4 weights)\n{\n    return shadowMap_cascadeMatrices[0] * weights.x +\n           shadowMap_cascadeMatrices[1] * weights.y +\n           shadowMap_cascadeMatrices[2] * weights.z +\n           shadowMap_cascadeMatrices[3] * weights.w;\n}\n",czm_cascadeWeights:"\nuniform vec4 shadowMap_cascadeSplits[2];\n\nvec4 czm_cascadeWeights(float depthEye)\n{\n    // One component is set to 1.0 and all others set to 0.0.\n    vec4 near = step(shadowMap_cascadeSplits[0], vec4(depthEye));\n    vec4 far = step(depthEye, shadowMap_cascadeSplits[1]);\n    return near * far;\n}\n",czm_clip:"#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\nuniform float clip_mode;\nuniform vec4 clip_planes[6];\nuniform vec4 clip_line_color;\nconst float clip_lineWidth = 3.0;\n\nfloat GetClipDistance(vec3 pos, vec3 planeNormal, float disToOrigin)\n{\n\treturn dot(planeNormal, pos) + disToOrigin;\n}\n\nfloat ClipBehindAllPlane(float fBorderWidth, vec4 clip_vertex)\n{\nfloat distance = 0.0;\nfloat result = -1.0;\n#ifdef CLIPPLANE\ndistance = GetClipDistance(clip_vertex.xyz, clip_planes[0].xyz, clip_planes[0].w);\nif (distance < 0.0)\n{\nreturn 1.0;\n}\nelse if (distance < fBorderWidth)\n{\nresult = 0.0;\n}\n#else\nfor(int i = 0; i < 6; i++)\n{\ndistance = GetClipDistance(clip_vertex.xyz, clip_planes[i].xyz, clip_planes[i].w);\nif(distance < 0.0)\n{\nreturn 1.0;\n}\nelse if(distance < fBorderWidth)\n{\nresult = 0.0;\n}\n}\n#endif\nreturn result;\n}\n\nfloat ClipBehindAnyPlane(float fBorderWidth, vec4 clip_vertex)\n{\n\tfloat result = 1.0;\n\tfor(int i = 0; i < 6; i++)\n\t{\n\t\tfloat distance = GetClipDistance(clip_vertex.xyz, clip_planes[i].xyz, clip_planes[i].w);\n\t\tif((distance + fBorderWidth) < 0.0)\n\t\t{\n\t\t\treturn -1.0;\n\t\t}\n\t\telse if(distance < 0.0)\n\t\t{\n\t\t\tresult = 0.0;\n\t\t}\n\t}\n\treturn result;\n}\n\nfloat ClipAnythingButLine(float fBorderWidth, vec4 clip_vertex)\n{\n\tfloat result = -1.0;\n\tfor(int i = 0; i < 6; i++)\n\t{\n\t\tfloat distance = GetClipDistance(clip_vertex.xyz, clip_planes[i].xyz, clip_planes[i].w);\n\t\tif(distance < 0.0)\n\t\t{\n\t\t\treturn -1.0;\n\t\t}\n\t\telse if(distance < fBorderWidth)\n\t\t{\n\t\t\tresult = 0.0;\n\t\t}\n\t}\n\treturn result;\n}\n\nvec4 czm_clip(vec4 clip_vertex, float fIsFiltByID)\n{\n    if(fIsFiltByID < 0.1)\n    {\n        return vec4(1.0);\n    }\n\tif(clip_mode < 0.5)\n\t{\n\t\treturn vec4(1.0);\n\t}\n#ifdef GL_OES_standard_derivatives\n\tfloat dxc = abs(dFdx(clip_vertex.x));\n\tfloat dyc = abs(dFdy(clip_vertex.y));\n\tfloat fBorderWidth = max(dxc, dyc) * clip_lineWidth;\n#else\n\tfloat fBorderWidth = clip_lineWidth;\n#endif\n\tfloat clipResult = 1.0;\n\tif(clip_line_color.a < 0.01)\n\t{\n\t\tfBorderWidth = 0.0;\n\t}\n\tif(clip_mode < 1.5)\n\t{\n\t\tclipResult = ClipBehindAnyPlane(fBorderWidth, clip_vertex);\n\t}\n\telse if(clip_mode < 2.5)\n\t{\n\t\tclipResult = ClipBehindAllPlane(fBorderWidth, clip_vertex);\n\t}\n\telse if(clip_mode < 3.5)\n\t{\n\t\tclipResult = ClipAnythingButLine(fBorderWidth, clip_vertex);\n\t}\n\tif(clipResult < -0.5)\n\t{\n\t\tdiscard;\n\t}\n\telse if(clipResult < 0.5)\n\t{\n\t\treturn clip_line_color;\n\t}\n\telse\n\t{\n        return vec4(1.0);\n\t}\n}",czm_columbusViewMorph:"/**\n * DOC_TBA\n *\n * @name czm_columbusViewMorph\n * @glslFunction\n */\nvec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)\n{\n    // Just linear for now.\n    vec3 p = mix(position2D.xyz, position3D.xyz, time);\n    return vec4(p, 1.0);\n}\n",czm_computeLightColorInFP:"vec4 czm_computeLightColorInFP(czm_s3mMaterialInput material, vec3 positionMC, float hasNormal, vec3 normal)\n{\n    vec3 normalEC;\n    #ifdef HAS_NORMAL\n    float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n    normalEC = normalize(normal) * faceDirection;\n    #else\n    normalEC = normalize(czm_normal*czm_computeNormal(positionMC));\n    #endif\n    vec3 positionEC = vec3(czm_modelView * vec4(positionMC,1.0)).xyz;\n    return czm_directionLight(material, normalEC, -positionEC, positionMC);\n}",czm_computeLightColorInstanceInFP:"vec4 czm_computeLightColorInstanceInFP(czm_s3mMaterialInput material, vec3 positionRotateMC, vec3 positionMC, float hasNormal, vec3 normal)\n{\n    vec3 normalEC;\n    #ifdef HAS_NORMAL\n        float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n        normalEC = normalize(normal) * faceDirection;\n    #else\n        normalEC = normalize(czm_normal*czm_computeNormal(positionRotateMC));\n    #endif\n    vec3 positionEC = vec3(czm_modelView * vec4(positionMC,1.0)).xyz;\n    return czm_directionLight(material, normalEC, -positionEC, positionMC);\n}",czm_computeNormal:"#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\nvec3 czm_computeNormal(in vec3 oriVertex)\n{\n\tvec3 normal = cross(vec3(dFdx(oriVertex.x), dFdx(oriVertex.y), dFdx(oriVertex.z)), vec3(dFdy(oriVertex.x), dFdy(oriVertex.y), dFdy(oriVertex.z)));\n\tnormal = normalize(normal);\n\treturn normal;\n}",czm_computePosition:"/**\n * Returns a position in model coordinates relative to eye taking into\n * account the current scene mode: 3D, 2D, or Columbus view.\n * <p>\n * This uses standard position attributes, <code>position3DHigh</code>, \n * <code>position3DLow</code>, <code>position2DHigh</code>, and <code>position2DLow</code>, \n * and should be used when writing a vertex shader for an {@link Appearance}.\n * </p>\n *\n * @name czm_computePosition\n * @glslFunction\n *\n * @returns {vec4} The position relative to eye.\n *\n * @example\n * vec4 p = czm_computePosition();\n * v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n * gl_Position = czm_modelViewProjectionRelativeToEye * p;\n *\n * @see czm_translateRelativeToEye\n */\nvec4 czm_computePosition();\n",czm_cosineAndSine:"/**\n * @private\n */\nvec2 cordic(float angle)\n{\n// Scale the vector by the appropriate factor for the 24 iterations to follow.\n    vec2 vector = vec2(6.0725293500888267e-1, 0.0);\n// Iteration 1\n    float sense = (angle < 0.0) ? -1.0 : 1.0;\n //   float factor = sense * 1.0;  // 2^-0\n    mat2 rotation = mat2(1.0, sense, -sense, 1.0);\n    vector = rotation * vector;\n    angle -= sense * 7.8539816339744828e-1;  // atan(2^-0)\n// Iteration 2\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    float factor = sense * 5.0e-1;  // 2^-1\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.6364760900080609e-1;  // atan(2^-1)\n// Iteration 3\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.5e-1;  // 2^-2\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4497866312686414e-1;  // atan(2^-2)\n// Iteration 4\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.25e-1;  // 2^-3\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2435499454676144e-1;  // atan(2^-3)\n// Iteration 5\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.25e-2;  // 2^-4\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.2418809995957350e-2;  // atan(2^-4)\n// Iteration 6\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.125e-2;  // 2^-5\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.1239833430268277e-2;  // atan(2^-5)\n// Iteration 7\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.5625e-2;  // 2^-6\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5623728620476831e-2;  // atan(2^-6)\n// Iteration 8\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.8125e-3;  // 2^-7\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.8123410601011111e-3;  // atan(2^-7)\n// Iteration 9\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.90625e-3;  // 2^-8\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.9062301319669718e-3;  // atan(2^-8)\n// Iteration 10\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.953125e-3;  // 2^-9\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9531225164788188e-3;  // atan(2^-9)\n// Iteration 11\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.765625e-4;  // 2^-10\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.7656218955931946e-4;  // atan(2^-10)\n// Iteration 12\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.8828125e-4;  // 2^-11\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.8828121119489829e-4;  // atan(2^-11)\n// Iteration 13\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.44140625e-4;  // 2^-12\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4414062014936177e-4;  // atan(2^-12)\n// Iteration 14\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.220703125e-4;  // 2^-13\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2207031189367021e-4;  // atan(2^-13)\n// Iteration 15\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.103515625e-5;  // 2^-14\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.1035156174208773e-5;  // atan(2^-14)\n// Iteration 16\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.0517578125e-5;  // 2^-15\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.0517578115526096e-5;  // atan(2^-15)\n// Iteration 17\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.52587890625e-5;  // 2^-16\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5258789061315762e-5;  // atan(2^-16)\n// Iteration 18\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.62939453125e-6;  // 2^-17\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.6293945311019700e-6;  // atan(2^-17)\n// Iteration 19\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.814697265625e-6;  // 2^-18\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.8146972656064961e-6;  // atan(2^-18)\n// Iteration 20\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.9073486328125e-6;  // 2^-19\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9073486328101870e-6;  // atan(2^-19)\n// Iteration 21\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.5367431640625e-7;  // 2^-20\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.5367431640596084e-7;  // atan(2^-20)\n// Iteration 22\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.76837158203125e-7;  // 2^-21\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.7683715820308884e-7;  // atan(2^-21)\n// Iteration 23\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.384185791015625e-7;  // 2^-22\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.3841857910155797e-7;  // atan(2^-22)\n// Iteration 24\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.1920928955078125e-7;  // 2^-23\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n//    angle -= sense * 1.1920928955078068e-7;  // atan(2^-23)\n\n    return vector;\n}\n\n/**\n * Computes the cosine and sine of the provided angle using the CORDIC algorithm.\n *\n * @name czm_cosineAndSine\n * @glslFunction\n *\n * @param {float} angle The angle in radians.\n *\n * @returns {vec2} The resulting cosine of the angle (as the x coordinate) and sine of the angle (as the y coordinate).\n *\n * @example\n * vec2 v = czm_cosineAndSine(czm_piOverSix);\n * float cosine = v.x;\n * float sine = v.y;\n */\nvec2 czm_cosineAndSine(float angle)\n{\n    if (angle < -czm_piOverTwo || angle > czm_piOverTwo)\n    {\n        if (angle < 0.0)\n        {\n            return -cordic(angle + czm_pi);\n        }\n        else\n        {\n            return -cordic(angle - czm_pi);\n        }\n    }\n    else\n    {\n        return cordic(angle);\n    }\n}\n",czm_decompressTextureCoordinates:"/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @name czm_decompressTextureCoordinates\n * @glslFunction\n *\n * @param {float} encoded The compressed texture coordinates.\n * @returns {vec2} The decompressed texture coordinates.\n */\n vec2 czm_decompressTextureCoordinates(float encoded)\n {\n    float temp = encoded / 4096.0;\n    float xZeroTo4095 = floor(temp);\n    float stx = xZeroTo4095 / 4095.0;\n    float sty = (encoded - xZeroTo4095 * 4096.0) / 4095.0;\n    return vec2(stx, sty);\n }\n",czm_depthClampFarPlane:"// emulated noperspective\n#ifndef LOG_DEPTH\nvarying float v_WindowZ;\n#endif\n\n/**\n * Clamps a vertex to the far plane.\n *\n * @name czm_depthClampFarPlane\n * @glslFunction\n *\n * @param {vec4} coords The vertex in clip coordinates.\n * @returns {vec4} The vertex clipped to the far plane.\n *\n * @example\n * gl_Position = czm_depthClampFarPlane(czm_modelViewProjection * vec4(position, 1.0));\n *\n * @see czm_writeDepthClampedToFarPlane\n */\nvec4 czm_depthClampFarPlane(vec4 coords)\n{\n#ifndef LOG_DEPTH\n    v_WindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;\n    coords.z = min(coords.z, coords.w);\n#endif\n    return coords;\n}\n",czm_directionLight:"const vec3 SideLightColor = vec3(0.0);\nuniform vec4 uSpecularColor;\nuniform float uShininess;\nconst vec3 specular = vec3(0.066666);\nconst float shininess2 = 30.0;\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n        return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n#if POINT_LIGHTS > 0\n    uniform vec3 uPointLightPositionEC[POINT_LIGHTS];\n    uniform vec3 uPointLightColor[POINT_LIGHTS];\n    uniform vec2 uPointLightDistanceAndDecay[POINT_LIGHTS];\n#endif\n#if SPOT_LIGHTS > 0\n    uniform vec3 uSpotLightPosition[ SPOT_LIGHTS ];\n    uniform vec3 uSpotLightColor[ SPOT_LIGHTS ];\n    uniform vec3 uSpotLightPositionEC[ SPOT_LIGHTS ];\n    uniform vec3 uSpotLightDirection[ SPOT_LIGHTS ];\n    uniform float uSpotLightExponent[ SPOT_LIGHTS ];\n    uniform vec4 uSpotLightDistanceDecayCosPenumbra[ SPOT_LIGHTS ];\n#endif\n#if DIR_LIGHTS > 0\n    uniform vec3 uDirectionalLightDirection[ DIR_LIGHTS ];\n    uniform vec3 uDirectionalLightColor[ DIR_LIGHTS];\n#endif\n#if HEMISPHERE_LIGHTS > 0\n    uniform vec3 uSkyColor[ HEMISPHERE_LIGHTS ];\n    uniform vec3 uGroundColor[ HEMISPHERE_LIGHTS];\n#endif\n    vec3 calcAmbientIrradiance(vec3 normal) {\n        vec3 SH0 = czm_SH[0].xyz;\n        vec4 SH_R1 = czm_SH[1];\n        vec4 SH_G1 = czm_SH[2];\n        vec4 SH_B1 = czm_SH[3];\n        vec4 SH_R2 = czm_SH[4];\n        vec4 SH_G2 = czm_SH[5];\n        vec4 SH_B2 = czm_SH[6];\n        vec3 ambientLight = 0.282095 * SH0;\n        vec4 sh1 = vec4(\n            0.488603 * normal.x,\n            0.488603 * normal.z,\n            0.488603 * normal.y,\n            1.092548 * normal.x * normal.y\n        );\n        vec4 sh2 = vec4(\n            1.092548 * normal.y * normal.z,\n            0.315392 * (3.0 * normal.z * normal.z - 1.0),\n            1.092548 * normal.x * normal.z,\n            0.546274 * (normal.x * normal.x - normal.y * normal.y)\n        );\n        ambientLight += vec3(\n            dot(SH_R1, sh1),\n            dot(SH_G1, sh1),\n            dot(SH_B1, sh1)\n        );\n        ambientLight += vec3(\n            dot(SH_R2, sh2),\n            dot(SH_G2, sh2),\n            dot(SH_B2, sh2)\n        );\n        return ambientLight;\n    }\n\n    const float ambientBoostFactor = 0.4;\n    const float lightingGlobalFactor = 0.0000342739;\n    const float fillLightIntensity = 0.25;\n    const vec3 GROUND_REFLECTANCE = vec3(0.2);\n\n    vec3 evaluateAdditionalLighting(vec3 posWorld, vec3 mainLightDirection, vec3 mainLightIntensity) {\n        float vndl = dot(normalize(posWorld), mainLightDirection);\n        float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl * 2.0, 0.0, 1.0));\n        return additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;\n    }\n\n    vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG) {\n        return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;\n    }\n\n    vec3 calcFinalIrradiance(float NdotL, vec3 normalWorld, vec3 normalGround, vec3 positionWC, vec3 lightDirWC, vec3 mainLightIntensity, vec3 ambientLightIrradiance, vec3 surfaceAlbedo, float shadow) {\n        float NdotNG = clamp(dot(normalWorld, normalGround), -1.0, 1.0);\n        vec3 ng = normalGround;\n        vec3 ambientDir = vec3(5.0 * ng[1] - ng[0] * ng[2], -5.0 * ng[0] - ng[2] * ng[1], ng[1] * ng[1] + ng[0] * ng[0]);\n        ambientDir = ambientDir != vec3(0.0) ? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\n        float NdotAmbDir = abs(dot(normalWorld, ambientDir));\n        vec3 additionalLight = evaluateAdditionalLighting(positionWC, lightDirWC, mainLightIntensity);\n        vec3 mainLightIrradiance = NdotL * mainLightIntensity * shadow;\n        vec3 fillLightIrradiance = NdotAmbDir * mainLightIntensity * fillLightIntensity;\n        vec3 ambientLightIrradianceComponent = ambientLightIrradiance + additionalLight;\n        vec3 skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradiance + fillLightIrradiance;\n        vec3 groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradiance + fillLightIrradiance;\n        vec3 diffuseContribution = evaluateDiffuseIlluminationHemisphere(groundIrradianceToSurface, skyIrradianceToSurface, NdotNG);\n        vec3 finalIrradiance = surfaceAlbedo.rgb * diffuseContribution * 0.31830988618;\n        return finalIrradiance;\n    }\n\n    vec3 diffuseBRDF_Lambertian(vec3 diffuseColor) {\n        return diffuseColor * 0.31830988618;\n    }\n\n    vec4 czm_directionLight(czm_s3mMaterialInput material, vec3 normalEC, vec3 positionToEyeEC, vec3 positionMC)\n    {\n        vec3 totalDiffuseLight = vec3(0.0);\n        vec3 totalSpecularLight = vec3(0.0);\n        float dotNL = saturate(dot(normalEC, material.sunDirectionEC));\n        vec3 normalWorld = material.normalWorld;\n        vec3 normalGround = material.normalGround;\n        vec3 positionWorld = material.positionWorld;\n        vec3 lightDirWC = material.sunDirectionWC;\n        vec3 sunLightColor = material.sunLightColor.rgb;\n        vec4 surfaceAlbedo = material.surfaceAlbedo;\n        float shadow = 1.0;\n        vec3 ambientLightIrradiance = calcAmbientIrradiance(normalWorld);\n        vec3 finalIrradiance = calcFinalIrradiance(dotNL, normalWorld, normalGround, positionWorld, lightDirWC, sunLightColor, ambientLightIrradiance, surfaceAlbedo.rgb, shadow);\n        vec3 positionToEyeECDir = normalize(positionToEyeEC);\n\t#if HEMISPHERE_LIGHTS > 0\n        for ( int i = 0; i < HEMISPHERE_LIGHTS; i ++ )\n        {\n            vec3 dirVectorEC = normalize(czm_normal * vec3(0.0, 0.0, 1.0));\n            float dotProduct = dot( normalEC, dirVectorEC );\n\t\t\tvec3 skyColor = uSkyColor[i];\n            vec3 groundColor = uGroundColor[i];\n\t\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\t\tvec3 irradiance = mix( groundColor, skyColor, hemiDiffuseWeight );\n\t\t\tirradiance *= 3.141592653589793;\n            totalDiffuseLight += irradiance;\n        }\n    #endif\n    #if DIR_LIGHTS > 0\n        for ( int i = 0; i < DIR_LIGHTS; i ++ )\n        {\n            vec3 dirVectorEC = normalize((czm_view * vec4(uDirectionalLightDirection[ i ], 0.0)).xyz);\n            float dotProduct = dot( normalEC, dirVectorEC );\n            float dirDiffuseWeight = max( dotProduct, 0.0 );\n            totalDiffuseLight += uDirectionalLightColor[ i ] * dirDiffuseWeight * diffuseBRDF_Lambertian(surfaceAlbedo.rgb);\n        }\n    #endif\n    #if POINT_LIGHTS > 0\n        for ( int i = 0; i < POINT_LIGHTS; i ++ )\n        {\n            vec3 lVector = uPointLightPositionEC[i] + positionToEyeEC;\n            float lengthToLight = length( lVector );\n            float cutoffDis = uPointLightDistanceAndDecay[i].x;\n            if(lengthToLight > cutoffDis)\n            {\n                continue;\n            }\n            float attenuation = calcLightAttenuation( lengthToLight, cutoffDis, uPointLightDistanceAndDecay[i].y);\n            lVector = normalize( lVector );\n            float dotProduct = dot( normalEC, lVector );\n            float pointLightDiffuse = max( dotProduct, 0.0 );\n            totalDiffuseLight += uPointLightColor[i] * pointLightDiffuse * attenuation * diffuseBRDF_Lambertian(surfaceAlbedo.rgb);\n        }\n    #endif\n    #if SPOT_LIGHTS > 0\n        vec3 positionWC = (czm_model * vec4(positionMC, 1.0)).xyz;\n        for ( int i = 0; i < SPOT_LIGHTS; i ++ )\n        {\n            vec3 lVector = uSpotLightPositionEC[i] + positionToEyeEC;\n            float attenuation = calcLightAttenuation( length( lVector ), uSpotLightDistanceDecayCosPenumbra[i].x, uSpotLightDistanceDecayCosPenumbra[i].y);\n            lVector = normalize( lVector );\n            float spotEffect = dot( uSpotLightDirection[ i ], normalize( uSpotLightPosition[ i ] - positionWC ) );\n            if ( spotEffect > uSpotLightDistanceDecayCosPenumbra[i].z ) {\n                spotEffect = max( pow( max( spotEffect, 0.0 ), uSpotLightExponent[ i ] ), 0.0 );\n                float dotProduct = dot( normalEC, lVector );\n                float spotDiffuseWeight = max( dotProduct, 0.0 );\n                totalDiffuseLight += uSpotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect * diffuseBRDF_Lambertian(surfaceAlbedo.rgb);\n                vec3 spotHalfVector = normalize( lVector + positionToEyeECDir );\n                float spotDotNormalHalf = max( dot( normalEC, spotHalfVector ), 0.0 );\n                float spotSpecularWeight = max( pow( spotDotNormalHalf, shininess2 ), 0.0 );\n                float specularNormalization = ( shininess2 + 2.0 ) / 8.0;\n                vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n                totalSpecularLight += schlick * uSpotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n            }\n        }\n    #endif\n\t\tvec4 color = vec4(finalIrradiance + totalDiffuseLight + totalSpecularLight, surfaceAlbedo.a);\n        return color;\n    }\n\n",czm_eastNorthUpToEyeCoordinates:"/**\n * Computes a 3x3 rotation matrix that transforms vectors from an ellipsoid's east-north-up coordinate system \n * to eye coordinates.  In east-north-up coordinates, x points east, y points north, and z points along the \n * surface normal.  East-north-up can be used as an ellipsoid's tangent space for operations such as bump mapping.\n * <br /><br />\n * The ellipsoid is assumed to be centered at the model coordinate's origin.\n *\n * @name czm_eastNorthUpToEyeCoordinates\n * @glslFunction\n *\n * @param {vec3} positionMC The position on the ellipsoid in model coordinates.\n * @param {vec3} normalEC The normalized ellipsoid surface normal, at <code>positionMC</code>, in eye coordinates.\n *\n * @returns {mat3} A 3x3 rotation matrix that transforms vectors from the east-north-up coordinate system to eye coordinates.\n *\n * @example\n * // Transform a vector defined in the east-north-up coordinate \n * // system, (0, 0, 1) which is the surface normal, to eye \n * // coordinates.\n * mat3 m = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n * vec3 normalEC = m * vec3(0.0, 0.0, 1.0);\n */\nmat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n{\n    vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));  // normalized surface tangent in model coordinates\n    vec3 tangentEC = normalize(czm_normal3D * tangentMC);                // normalized surface tangent in eye coordiantes\n    vec3 bitangentEC = normalize(cross(normalEC, tangentEC));            // normalized surface bitangent in eye coordinates\n\n    return mat3(\n        tangentEC.x,   tangentEC.y,   tangentEC.z,\n        bitangentEC.x, bitangentEC.y, bitangentEC.z,\n        normalEC.x,    normalEC.y,    normalEC.z);\n}\n",czm_ellipsoidContainsPoint:"/**\n * DOC_TBA\n *\n * @name czm_ellipsoidContainsPoint\n * @glslFunction\n *\n */\nbool czm_ellipsoidContainsPoint(vec3 ellipsoid_inverseRadii, vec3 point)\n{\n    vec3 scaled = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;\n    return (dot(scaled, scaled) <= 1.0);\n}\n",czm_ellipsoidNew:"/**\n * DOC_TBA\n *\n * @name czm_ellipsoidNew\n * @glslFunction\n *\n */\nczm_ellipsoid czm_ellipsoidNew(vec3 center, vec3 radii)\n{\n    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\n    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\n    czm_ellipsoid temp = czm_ellipsoid(center, radii, inverseRadii, inverseRadiiSquared);\n    return temp;\n}\n",czm_ellipsoidWgs84TextureCoordinates:"/**\n * DOC_TBA\n *\n * @name czm_ellipsoidWgs84TextureCoordinates\n * @glslFunction\n */\nvec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)\n{\n    return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);\n}\n",czm_equalsEpsilon:"/**\n * Compares <code>left</code> and <code>right</code> componentwise. Returns <code>true</code>\n * if they are within <code>epsilon</code> and <code>false</code> otherwise. The inputs\n * <code>left</code> and <code>right</code> can be <code>float</code>s, <code>vec2</code>s,\n * <code>vec3</code>s, or <code>vec4</code>s.\n *\n * @name czm_equalsEpsilon\n * @glslFunction\n *\n * @param {} left The first vector.\n * @param {} right The second vector.\n * @param {float} epsilon The epsilon to use for equality testing.\n * @returns {bool} <code>true</code> if the components are within <code>epsilon</code> and <code>false</code> otherwise.\n *\n * @example\n * // GLSL declarations\n * bool czm_equalsEpsilon(float left, float right, float epsilon);\n * bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon);\n * bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon);\n * bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon);\n */\nbool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec4(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec3(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec2(epsilon)));\n}\n\nbool czm_equalsEpsilon(float left, float right, float epsilon) {\n    return (abs(left - right) <= epsilon);\n}\n",czm_executeExcavation:"#ifdef EXCAVATION\nuniform sampler2D uExcavationTexture;\nuniform float uExcavationMode;\nuniform vec4 uExcavationRect;\nvarying vec4 vExcavationVertexPos;\nvec2 CalculateExcavationPolyTexCoord(vec4 vertexPos, vec4 rectPos, out float ptInRect)\n{\n    vec2 vecRatio = vec2(rectPos.z - rectPos.x, rectPos.w - rectPos.y);\n    vec2 texCoord = vec2(vertexPos.x - rectPos.x, vertexPos.y - rectPos.y);\n    texCoord.x = texCoord.x / vecRatio.x;\n    texCoord.y = texCoord.y / vecRatio.y;\n    ptInRect = step(0.0, texCoord.x) * step(0.0, texCoord.y) * step(0.0, 1.0 - texCoord.x) * step(0.0, 1.0 - texCoord.y);\n    texCoord = clamp(texCoord, vec2(0.0), vec2(1.0));\n    return texCoord;\n}\nbool czm_executeExcavation()\n{\n    float hasExcavation = 1.0;\n    vec2 vecExcavationTexCoord = CalculateExcavationPolyTexCoord(vExcavationVertexPos, uExcavationRect, hasExcavation);\n    bool excavationInside = (uExcavationMode < 0.5);\n    if(hasExcavation < 0.1)\n    {\n        return !excavationInside;\n    }\n    if(excavationInside)\n    {\n        return texture2D(uExcavationTexture, vecExcavationTexCoord.xy).r > 0.5;\n    }\n    else\n    {\n        return texture2D(uExcavationTexture, vecExcavationTexCoord.xy).r < 0.5;\n    }\n}\n#endif",czm_eyeOffset:"/**\n * DOC_TBA\n *\n * @name czm_eyeOffset\n * @glslFunction\n *\n * @param {vec4} positionEC DOC_TBA.\n * @param {vec3} eyeOffset DOC_TBA.\n *\n * @returns {vec4} DOC_TBA.\n */\nvec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n{\n    // This equation is approximate in x and y.\n    vec4 p = positionEC;\n    vec4 zEyeOffset = normalize(p) * eyeOffset.z;\n    p.xy += eyeOffset.xy + zEyeOffset.xy;\n    p.z += zEyeOffset.z;\n    return p;\n}\n",czm_eyeToWindowCoordinates:"/**\n * Transforms a position from eye to window coordinates.  The transformation\n * from eye to clip coordinates is done using {@link czm_projection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n *\n * @name czm_eyeToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in eye coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_projection\n * @see czm_viewportTransformation\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n */\nvec4 czm_eyeToWindowCoordinates(vec4 positionEC)\n{\n    vec4 q = czm_projection * positionEC;                        // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n",czm_fastApproximateAtan:"/**\n * Approxiamtes atan over the range [0, 1]. Safe to flip output for negative input.\n *\n * Based on Michal Drobot's approximation from ShaderFastLibs, which in turn is based on\n * \"Efficient approximations for the arctangent function,\" Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.\n * Adapted from ShaderFastLibs under MIT License.\n *\n * Chosen for the following characteristics over range [0, 1]:\n * - basically no error at 0 and 1, important for getting around range limit (naive atan2 via atan requires infinite range atan)\n * - no visible artifacts from first-derivative discontinuities, unlike latitude via range-reduced sqrt asin approximations (at equator)\n *\n * The original code is x * (-0.1784 * abs(x) - 0.0663 * x * x + 1.0301);\n * Removed the abs() in here because it isn't needed, the input range is guaranteed as [0, 1] by how we're approximating atan2.\n *\n * @name czm_fastApproximateAtan\n * @glslFunction\n *\n * @param {float} x Value between 0 and 1 inclusive.\n *\n * @returns {float} Approximation of atan(x)\n */\nfloat czm_fastApproximateAtan(float x) {\n    return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);\n}\n\n/**\n * Approximation of atan2.\n *\n * Range reduction math based on nvidia's cg reference implementation for atan2:\n * However, we replaced their atan curve with Michael Drobot's (see above).\n *\n * @name czm_fastApproximateAtan\n * @glslFunction\n *\n * @param {float} x Value between -1 and 1 inclusive.\n * @param {float} y Value between -1 and 1 inclusive.\n *\n * @returns {float} Approximation of atan2(x, y)\n */\nfloat czm_fastApproximateAtan(float x, float y) {\n    // atan approximations are usually only reliable over [-1, 1], or, in our case, [0, 1] due to modifications.\n    // So range-reduce using abs and by flipping whether x or y is on top.\n    float t = abs(x); // t used as swap and atan result.\n    float opposite = abs(y);\n    float adjacent = max(t, opposite);\n    opposite = min(t, opposite);\n\n    t = czm_fastApproximateAtan(opposite / adjacent);\n\n    // Undo range reduction\n    t = czm_branchFreeTernary(abs(y) > abs(x), czm_piOverTwo - t, t);\n    t = czm_branchFreeTernary(x < 0.0, czm_pi - t, t);\n    t = czm_branchFreeTernary(y < 0.0, -t, t);\n    return t;\n}\n",czm_fog:"/**\n * Gets the color with fog at a distance from the camera.\n *\n * @name czm_fog\n * @glslFunction\n *\n * @param {float} distanceToCamera The distance to the camera in meters.\n * @param {vec3} color The original color.\n * @param {vec3} fogColor The color of the fog.\n *\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\n */\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor)\n{\n    float scalar = distanceToCamera * czm_fogDensity;\n    float fog = 1.0 - exp(-(scalar * scalar));\n    return mix(color, fogColor, fog);\n}\n\n/**\n * Gets the color with fog at a distance from the camera.\n *\n * @name czm_fog\n * @glslFunction\n *\n * @param {float} distanceToCamera The distance to the camera in meters.\n * @param {vec3} color The original color.\n * @param {vec3} fogColor The color of the fog.\n * @param {float} fogModifierConstant A constant to modify the appearance of fog.\n *\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\n */\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant)\n{\n    float scalar = distanceToCamera * czm_fogDensity;\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\n    return mix(color, fogColor, fog);\n}\n",czm_gammaCorrect:"/**\n * Converts a color from RGB space to linear space.\n *\n * @name czm_gammaCorrect\n * @glslFunction\n *\n * @param {vec3} color The color in RGB space.\n * @returns {vec3} The color in linear space.\n */\nvec3 czm_gammaCorrect(vec3 color) {\n#ifdef HDR\n    color = pow(color, vec3(czm_gamma));\n#endif\n    return color;\n}\n\nvec4 czm_gammaCorrect(vec4 color) {\n#ifdef HDR\n    color.rgb = pow(color.rgb, vec3(czm_gamma));\n#endif\n    return color;\n}\n",czm_geodeticSurfaceNormal:"/**\n * DOC_TBA\n *\n * @name czm_geodeticSurfaceNormal\n * @glslFunction\n *\n * @param {vec3} positionOnEllipsoid DOC_TBA\n * @param {vec3} ellipsoidCenter DOC_TBA\n * @param {vec3} oneOverEllipsoidRadiiSquared DOC_TBA\n * \n * @returns {vec3} DOC_TBA.\n */\nvec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n{\n    return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n}\n",czm_getDefaultMaterial:"/**\n * An czm_material with default values. Every material's czm_getMaterial\n * should use this default material as a base for the material it returns.\n * The default normal value is given by materialInput.normalEC.\n *\n * @name czm_getDefaultMaterial\n * @glslFunction\n *\n * @param {czm_materialInput} input The input used to construct the default material.\n *\n * @returns {czm_material} The default material.\n *\n * @see czm_materialInput\n * @see czm_material\n * @see czm_getMaterial\n */\nczm_material czm_getDefaultMaterial(czm_materialInput materialInput)\n{\n    czm_material material;\n    material.diffuse = vec3(0.0);\n    material.specular = 0.0;\n    material.shininess = 1.0;\n    material.normal = materialInput.normalEC;\n    material.emission = vec3(0.0);\n    material.alpha = 1.0;\n    return material;\n}\n",czm_getEmissiveTextureColor:"uniform float uMaxCategoryOrHypCeil;\nuniform float uMinCategoryOrHypFloor;\nuniform sampler2D uEmissionTexAtlas;\nuniform vec4 uEmissionTexAtlasTilingAndOffset[EMISSION_TEXTURE_COUNT];\nuniform vec4 uEmissionTexAtlasRects[EMISSION_TEXTURE_COUNT];\nuniform float uLayerCornerLength;\nvarying vec2 vLayerTexCoord;\nvarying vec2 vModIndexAndTexIndex;\nvec3 czm_getEmissiveTextureColor(float w)\n{\n    vec3 texColor = vec3(0.0);\n    vec2 emissionTexCoord;\n    int nEmissionTexTexIdx = int(floor(vModIndexAndTexIndex.y + 0.5));\n    vec2 atlasTexCoord;\n    for(int i = 0; i < EMISSION_TEXTURE_COUNT; i++){\n        if(nEmissionTexTexIdx == i){\n            emissionTexCoord.x = mod(length(vLayerTexCoord) * uLayerCornerLength / uEmissionTexAtlasTilingAndOffset[i].x, 1.0);\n            emissionTexCoord.y = mod((w - uMinCategoryOrHypFloor) / uEmissionTexAtlasTilingAndOffset[i].y, 1.0) ;\n            emissionTexCoord.x += uEmissionTexAtlasTilingAndOffset[i].z;\n            emissionTexCoord.y += vModIndexAndTexIndex.x + uEmissionTexAtlasTilingAndOffset[i].w;\n            emissionTexCoord.xy = fract(emissionTexCoord.xy);\n            atlasTexCoord = mix(uEmissionTexAtlasRects[i].xy, uEmissionTexAtlasRects[i].zw, emissionTexCoord);\n            break;\n        }\n    }\n    texColor = texture2D(uEmissionTexAtlas, atlasTexCoord).rgb;\n    return texColor;\n}\nvec3 czm_getEmissiveTextureColor(float w, vec2 texCoord)\n{\n    vec3 texColor = vec3(0.0);\n    vec2 emissionTexCoord;\n    int nEmissionTexTexIdx = int(floor(vModIndexAndTexIndex.y + 0.5));\n    vec2 atlasTexCoord;\n    for(int i = 0; i < EMISSION_TEXTURE_COUNT; i++){\n        if(nEmissionTexTexIdx == i){\n            emissionTexCoord.x = mod(texCoord.x / uEmissionTexAtlasTilingAndOffset[i].x, 1.0);\n            emissionTexCoord.y = mod(texCoord.y / uEmissionTexAtlasTilingAndOffset[i].y, 1.0);\n            emissionTexCoord.x += uEmissionTexAtlasTilingAndOffset[i].z;\n            emissionTexCoord.y += vModIndexAndTexIndex.x + uEmissionTexAtlasTilingAndOffset[i].w;\n            emissionTexCoord.xy = fract(emissionTexCoord.xy);\n            atlasTexCoord = mix(uEmissionTexAtlasRects[i].xy, uEmissionTexAtlasRects[i].zw, emissionTexCoord);\n            break;\n        }\n    }\n    texColor = texture2D(uEmissionTexAtlas, atlasTexCoord).rgb;\n    return texColor;\n}",czm_getHorizontalColor:"uniform float uHorizontalLine;\nuniform vec4 uHorizontalColor;\nfloat computeContourline(float fValue)\n{\n\tfloat distanceToContour = uHorizontalLine;\n\tfloat dxc = abs(dFdx(fValue));\n\tfloat dyc = abs(dFdy(fValue));\n\tfloat dF = max(dxc, dyc);\n\treturn (abs(distanceToContour-fValue) < dF) ? 1.0 : 0.0;\n}\n\nvec4 czm_getHorizontalColor(vec4 oriColor, float fValue)\n{\n    float finalOpacity = computeContourline(fValue);\n    return mix(oriColor,uHorizontalColor, finalOpacity);\n}",czm_getHypsometricColor:"uniform sampler2D uHypsometricTexture;\nuniform sampler2D uHypsometricRenderTexture;\nuniform float uHypsometricVisible;\nuniform float uHypOpacity;\nuniform float uHypContourInterval;\nuniform vec4 uHypLineColor;\nuniform float uHypContourFillMode;\nuniform float uHypFloor;\nuniform float uHypCeil;\nuniform float uHypMaxVisibleValue;\nuniform float uHypMinVisibleValue;\nuniform float uHypHasAnalysisRegion;\nvarying vec2 vecHypTexCoord;\nuniform float uMixColorType;\nuniform vec4 uNoValueColor;\n#ifdef Volume\nvarying vec3 vecRotioCoord;\nuniform float uDataFloor;\nuniform float uDataCeil;\nuniform float uVolumeType;\n#endif\n\n#ifdef Volume2\nuniform float uDataFloor;\nuniform float uDataCeil;\nuniform float uFilterMode;\n#endif\n\nfloat computeMixCon(float fValue)\n{\n    float distanceToContour;\n    if(abs(uHypMaxVisibleValue - uHypMinVisibleValue) > 0.1)\n    {\n\t    if(fValue < 0.5)\n        {\n            distanceToContour = mod(fValue - 0.0002, uHypContourInterval);\n        }\n        else\n        {\n            float t = floor(fValue / uHypContourInterval);\n            distanceToContour = abs(fValue - (t * uHypContourInterval) - 0.1);\n        }\n\t}\n\telse\n\t{\n\t    distanceToContour = abs(fValue - uHypMaxVisibleValue);\n\t}\n\tfloat dxc = abs(dFdx(fValue));\n\tfloat dyc = abs(dFdy(fValue));\n\tfloat dF = max(dxc, dyc);\n\treturn (distanceToContour < dF) ? 1.0 : 0.0;\n}\n\nvec4 computeContourMapColor(float fValue)\n{\n\t//float threshold = clamp(abs(uHypCeil - uHypFloor), 0.000001, 20000.0);\n\tfloat threshold = abs(uHypCeil - uHypFloor);\n\tfloat contourRate = (fValue - uHypFloor) / threshold;\n\tfloat finalCoord = clamp(contourRate, 0.0, 1.0);\n\tfloat count = floor(finalCoord * 16.0);\n\tfloat y = (count*2.0 + 1.0)/32.0;\n\tfloat x = fract(finalCoord*16.0);\n\tif(y > 1.0)\n\t{\n\t    x = 1.0;\n\t}\n\tvec2 contourCoord = vec2(x, y);\n\tvec4 color = texture2D(uHypsometricTexture, contourCoord);\n\treturn color;\n}\n#ifdef Volume2\n\nvec4 czm_getContourMapColor(vec4 oriColor, vec4 volColor)\n{\n    if(uFilterMode > 0.5)\n    {\n        vec4 finalColor = volColor * oriColor;\n\n        if(uMixColorType > 0.5)\n        {\n            finalColor = volColor;\n        }\n        return finalColor;\n    }\n\n    vec4 contourMapColor = vec4(0.0);\n    float finalOpacity = uHypOpacity;\n\n\tfloat noValue = volColor.a;\n\tfloat texTest = clamp(czm_unpackVolume(volColor.zyx),0.0,1.0);\n\n\tfloat fValue;\n\tif(noValue > 0.5)\n\t{\n        fValue = uDataFloor + texTest * (uDataCeil - uDataFloor);\n    }\n    else\n    {\n        fValue = uHypMaxVisibleValue + abs(uHypMaxVisibleValue * 0.1);\n    }\n\n    float extendHeight = czm_branchFreeTernary(uHypContourFillMode > 2.9, 0.0, czm_branchFreeTernary(uHypContourFillMode > 1.9, 5.0, 0.0));\n    if(fValue > uHypMaxVisibleValue + extendHeight || fValue < uHypMinVisibleValue - extendHeight)\n    {\n        return uNoValueColor * oriColor;\n    }\n#ifdef GL_OES_standard_derivatives\n    if(uHypContourFillMode > 2.9)\n    {\n        float mix_con = computeMixCon(fValue);\n        contourMapColor = mix(computeContourMapColor(fValue), uHypLineColor, mix_con);\n    }\n    else if(uHypContourFillMode > 1.9)\n    {\n        finalOpacity = computeMixCon(fValue);\n        contourMapColor = uHypLineColor;\n    }\n    else if(uHypContourFillMode > 0.9)\n#else\n    if(uHypContourFillMode > 0.9)\n#endif\n    {\n        contourMapColor = computeContourMapColor(fValue);\n    }\n    else\n    {\n        finalOpacity = 0.0;\n    }\n    vec4 mixColor = mix(vec4(1.0,1.0,1.0,1.0), contourMapColor, finalOpacity);\n    vec4 finalColor = mixColor * oriColor;\n#ifdef PT_CLOUD\n\tfinalColor = mixColor;\n#endif\n    if(uMixColorType > 0.5)\n    {\n        finalColor = mixColor;\n    }\n    return finalColor;\n}\n\n#else\n\nvec4 czm_getContourMapColor(vec4 oriColor, float fValue)\n{\n    vec4 contourMapColor = vec4(0.0);\n    float finalOpacity = uHypOpacity;\n#ifdef Volume\n\tvec3 aRatioT = vecRotioCoord;\n\tif((aRatioT.x < 1.0 && aRatioT.x >0.0) && (aRatioT.y < 1.0 && aRatioT.y >0.0) && (aRatioT.z < 1.0 && aRatioT.z >0.0))\n\t{\n\t    if(uVolumeType > 0.5)\n\t    {\n\t\t\tvec4 volumeColor = czm_getVolumeValue(aRatioT);\n\t\t\tif(uMixColorType > 0.5)\n\t\t\t{\n\t\t\t\tvolumeColor = volumeColor * oriColor;\n\t\t\t}\n\t\t\treturn volumeColor;\n\t    }\n\t    float noValue;\n\t    float texTest = czm_getVolumeValue(aRatioT, noValue);\n\t    if(noValue > 0.5)\n\t    {\n\t        fValue = uDataFloor + texTest * (uDataCeil - uDataFloor);\n\t    }\n\t    else\n\t    {\n\t        fValue = uHypMaxVisibleValue + abs(uHypMaxVisibleValue * 0.1);\n\t    }\n\t}\n\telse\n\t{\n\t    fValue = uHypMaxVisibleValue + abs(uHypMaxVisibleValue * 0.1);\n\t}\n#endif\n    float extendHeight = czm_branchFreeTernary(uHypContourFillMode > 2.9, 0.0, czm_branchFreeTernary(uHypContourFillMode > 1.9, 5.0, 0.0));\n    if(fValue > uHypMaxVisibleValue + extendHeight || fValue < uHypMinVisibleValue - extendHeight)\n    {\n        return uNoValueColor * oriColor;\n    }\n#ifdef GL_OES_standard_derivatives\n    if(uHypContourFillMode > 2.9)\n    {\n        float mix_con = computeMixCon(fValue);\n        contourMapColor = mix(computeContourMapColor(fValue), uHypLineColor, mix_con);\n    }\n    else if(uHypContourFillMode > 1.9)\n    {\n        finalOpacity = computeMixCon(fValue);\n        contourMapColor = uHypLineColor;\n    }\n    else if(uHypContourFillMode > 0.9)\n#else\n    if(uHypContourFillMode > 0.9)\n#endif\n    {\n        contourMapColor = computeContourMapColor(fValue);\n    }\n    else\n    {\n        finalOpacity = 0.0;\n    }\n    vec4 mixColor = mix(vec4(1.0,1.0,1.0,1.0), contourMapColor, finalOpacity);\n    vec4 finalColor = mix(oriColor, contourMapColor, finalOpacity);\n#ifdef PT_CLOUD\n\tfinalColor = mixColor;\n#endif\n#ifdef Volume\n    if(uMixColorType > 0.5)\n    {\n        finalColor = mixColor;\n    }\n#endif\n    return finalColor;\n}\n\n#endif\n\n#ifdef Volume2\nvec4 czm_getHypsometricColor(vec4 oriColor, vec4 volColor)\n{\n\tif(uHypHasAnalysisRegion > 0.1)\n    {\n\t\tvec4 hypColor = texture2D(uHypsometricRenderTexture, vecHypTexCoord);\n\t\tif(hypColor.r < 0.1)\n\t\t{\n\t\t\treturn oriColor;\n\t\t}\n\t}\n    return czm_getContourMapColor(oriColor, volColor);\n}\n#else\nvec4 czm_getHypsometricColor(vec4 oriColor, float wValue)\n{\n    float fValue = wValue;\n\tif(uHypHasAnalysisRegion > 0.1)\n    {\n\t\tvec4 hypColor = texture2D(uHypsometricRenderTexture, vecHypTexCoord);\n\t\tif(hypColor.r < 0.1)\n\t\t{\n\t\t\treturn oriColor;\n\t\t}\n\t}\n    return czm_getContourMapColor(oriColor, fValue);\n}\n\nvec4 czm_getHypsometricColorByGeoBounds(vec4 oriColor, float wValue, vec4 hypRect, vec2 vTexCoord, vec4 geoBounds)\n{\n   if(uHypHasAnalysisRegion > 0.1)\n    {\n        vec2 polyTexCoord = vTexCoord.xy;\n        polyTexCoord.x = polyTexCoord.x * (geoBounds.z - geoBounds.x) + geoBounds.x;\n        polyTexCoord.y = polyTexCoord.y * (geoBounds.w - geoBounds.y) + geoBounds.y;\n        if(polyTexCoord.x < hypRect.x || polyTexCoord.x>hypRect.z || polyTexCoord.y< hypRect.y || polyTexCoord.y > hypRect.w)\n        {\n            return oriColor;\n        }\n        vec4 hypColor = texture2D(uHypsometricRenderTexture, polyTexCoord);\n        if(hypColor.r < 0.1)\n        {\n            return oriColor;\n        }\n    }\n    return czm_getContourMapColor(oriColor, wValue);\n}\n\n#endif",czm_getLambertDiffuse:"/**\n * Calculates the intensity of diffusely reflected light.\n *\n * @name czm_getLambertDiffuse\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n *\n * @returns {float} The intensity of the diffuse reflection.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\n{\n    return max(dot(lightDirectionEC, normalEC), 0.0);\n}\n",czm_getSpecular:"/**\n * Calculates the specular intensity of reflected light.\n *\n * @name czm_getSpecular\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} toEyeEC Unit vector pointing to the eye position in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n * @param {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n *\n * @returns {float} The intensity of the specular highlight.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)\n{\n    vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);\n    float specular = max(dot(toReflectedLight, toEyeEC), 0.0);\n\n    // pow has undefined behavior if both parameters <= 0.\n    // Prevent this by making sure shininess is at least czm_epsilon2.\n    return pow(specular, max(shininess, czm_epsilon2));\n}\n",czm_getTexColorForS3M:"void CalculateMipLevel(in vec2 inTexCoord, in float vecTile, in float fMaxMip, inout float mipLevel)\n{\n\tvec2 dx = dFdx(inTexCoord * vecTile);\n\tvec2 dy = dFdy(inTexCoord * vecTile);\n\tfloat dotX = dot(dx, dx);\n\tfloat dotY = dot(dy, dy);\n\tfloat dMax = max(dotX, dotY);\n\tfloat dMin = min(dotX, dotY);\n\tfloat offset = (dMax - dMin) / (dMax + dMin);\n\toffset = clamp(offset, 0.0, 1.0);\n\tfloat d = dMax * (1.0 - offset) + dMin * offset;\n\tmipLevel = 0.5 * log2(d);\n\tmipLevel = clamp(mipLevel, 0.0, fMaxMip - 1.62);\n}\n\nvoid CalculateMipLevel(in vec2 inTexCoord, in vec2 vecTile, in float fMaxMip, inout float mipLevel)\n{\n\tvec2 dx = dFdx(inTexCoord * vecTile.x);\n\tvec2 dy = dFdy(inTexCoord * vecTile.y);\n\tfloat dotX = dot(dx, dx);\n\tfloat dotY = dot(dy, dy);\n\tfloat dMax = max(dotX, dotY);\n\tfloat dMin = min(dotX, dotY);\n\tfloat offset = (dMax - dMin) / (dMax + dMin);\n\toffset = clamp(offset, 0.0, 1.0);\n\tfloat d = dMax * (1.0 - offset) + dMin * offset;\n\tmipLevel = 0.5 * log2(d);\n\tmipLevel = clamp(mipLevel, 0.0, fMaxMip - 1.62);\n}\n\nvoid CalculateTexCoord(in vec3 inTexCoord, in float scale, in float XTran, in float YTran, in float fTile, in float mipLevel, inout vec2 outTexCoord)\n{\n    if(inTexCoord.z < -9000.0)\n    {\n        outTexCoord = inTexCoord.xy;\n    }\n    else\n    {\n\t    vec2 fTexCoord = fract(inTexCoord.xy);\n\t    float offset = 1.0 * pow(2.0, mipLevel) / fTile;\n\t    fTexCoord = clamp(fTexCoord, offset, 1.0 - offset);\n\t    outTexCoord.x = (fTexCoord.x + XTran) * scale;\n\t    outTexCoord.y = (fTexCoord.y + YTran) * scale;\n\t}\n}\n\n\nvec4 czm_getTexColorForS3M(sampler2D curTexture, vec3 oriTexCoord, float texTileWidth, float fMaxMipLev, float fTexCoordScale, vec2 vecTexCoordTranslate,float isRGBA, vec4 texUVoffset, out vec2 outTexCoord)\n{\n\tvec4 color = vec4(1.0);\n\tif(oriTexCoord.z <= -99900.0){\n\t\treturn color;\n\t}\n    float mipLevel = 0.0;\n#ifdef GL_OES_standard_derivatives\n    CalculateMipLevel(oriTexCoord.xy, texTileWidth, fMaxMipLev, mipLevel);\n#endif\n    vec2 realTexCoord;\n    CalculateTexCoord(oriTexCoord, fTexCoordScale, vecTexCoordTranslate.x, vecTexCoordTranslate.y, texTileWidth, mipLevel, realTexCoord);\n\tif(isRGBA > 0.5)\n\t{\n\t    vec2 rgbTexCoord;\n\t\trgbTexCoord.x = (realTexCoord.x + vecTexCoordTranslate.x * fTexCoordScale) * 0.5;\n\t\trgbTexCoord.y = (realTexCoord.y + vecTexCoordTranslate.y * fTexCoordScale) * 0.5;\n\t\trgbTexCoord.xy += texUVoffset.xy;\n        color = texture2D(curTexture, rgbTexCoord.xy, -10.0);\n\t\tvec2 vecAlphaTexCoord;\n\t\tvecAlphaTexCoord.x = rgbTexCoord.x;\n\t\tvecAlphaTexCoord.y = rgbTexCoord.y + fTexCoordScale * 0.5;\n\t\tvecAlphaTexCoord.xy += texUVoffset.xy;\n\t    color.a = texture2D(curTexture, vecAlphaTexCoord.xy, -10.0).r;\n\t}\n\telse\n\t{\n\t    realTexCoord = realTexCoord * texUVoffset.zw + texUVoffset.xy;\n\t    if(oriTexCoord.z < -9000.0)\n        {\n            color = texture2D(curTexture, realTexCoord.xy);\n        }\n        else\n        {\n            #ifdef GL_EXT_shader_texture_lod\n                color = texture2DLodEXT(curTexture, realTexCoord.xy, mipLevel);\n            #else\n                #ifdef WEBEL2\n                    color = textureLod(curTexture, realTexCoord.xy, mipLevel);\n                #else\n                    color = texture2D(curTexture, realTexCoord.xy, mipLevel);\n                #endif\n            #endif\n        }\n    #ifdef RGBTOBGR\n        color = color.bgra;\n    #endif\n\t}\n\toutTexCoord = realTexCoord;\n\treturn color;\n}\n\nvec4 czm_getTexColorForS3M(sampler2D texture, vec2 uv, vec2 texDim, vec2 texTran, vec2 texScale, float maxMipLevel, out vec2 outTexCoord)\n{\n    if(maxMipLevel < 0.0)\n    {\n        return vec4(1.0);\n    }\n\tvec4 colorCeil = vec4(1.0);\n    float mipLevel = 0.0;\n#ifdef GL_OES_standard_derivatives\n    CalculateMipLevel(uv, texDim, maxMipLevel, mipLevel);\n#endif\n\tfloat ceilMipLevel = ceil(mipLevel);\n\tvec2 translate = vec2(texTran.x, texTran.y);\n\tfloat temp;\n\tif(ceilMipLevel > 0.0)\n\t{\n\t\ttranslate.x = texTran.x + texScale.x;\n\t\ttemp = pow(2.0, ceilMipLevel - 1.0);\n\t\ttranslate.y = texTran.y + texScale.y * (temp - 1.0) / temp;\n\t}\n    float scale = 1.0 / pow(2.0, ceilMipLevel);\n\tvec2 texcoord = fract(uv);\n\tfloat offsetX = pow(2.0, ceilMipLevel) / texDim.x;\n\tfloat offsetY = pow(2.0, ceilMipLevel) / texDim.y;\n\ttexcoord.x = clamp(texcoord.x, 0.0 + offsetX, 1.0 - offsetX);\n\ttexcoord.y = clamp(texcoord.y, 0.0 + offsetY, 1.0 - offsetY);\n\ttexcoord.x = texcoord.x * texScale.x * scale + translate.x;\n\ttexcoord.y = texcoord.y * texScale.y * scale + translate.y;\n\t#ifdef GL_EXT_shader_texture_lod\n        colorCeil = texture2DLodEXT(texture, texcoord.xy, 0.0);\n    #else\n        #ifdef WEBEL2\n            colorCeil = textureLod(texture, texcoord.xy, 0.0);\n        #else\n            colorCeil = texture2D(texture, texcoord.xy, -10.0);\n        #endif\n    #endif\n\tvec4 colorFloor = vec4(1.0);\n\tfloat floorMipLevel = floor(mipLevel);\n\ttranslate = vec2(texTran.x, texTran.y);\n\tif(floorMipLevel > 0.0)\n\t{\n\t    translate.x = texTran.x + texScale.x;\n\t    temp = pow(2.0, floorMipLevel - 1.0);\n\t    translate.y = texTran.y + texScale.y * (temp - 1.0) / temp;\n\t}\n\tscale = 1.0 / pow(2.0, floorMipLevel);\n\ttexcoord = fract(uv);\n\toffsetX = pow(2.0, floorMipLevel) / texDim.x;\n\toffsetY = pow(2.0, floorMipLevel) / texDim.y;\n\ttexcoord.x = clamp(texcoord.x, 0.0 + offsetX, 1.0 - offsetX);\n\ttexcoord.y = clamp(texcoord.y, 0.0 + offsetY, 1.0 - offsetY);\n\ttexcoord.x = texcoord.x * texScale.x * scale + translate.x;\n\ttexcoord.y = texcoord.y * texScale.y * scale + translate.y;\n\t#ifdef GL_EXT_shader_texture_lod\n        colorFloor = texture2DLodEXT(texture, texcoord.xy, 0.0);\n    #else\n        #ifdef WEBEL2\n            colorFloor = textureLod(texture, texcoord.xy, 0.0);\n        #else\n            colorFloor = texture2D(texture, texcoord.xy, -10.0);\n        #endif\n    #endif\n\tvec4 color = colorCeil * 0.5 + colorFloor * 0.5;\n\treturn color;\n}",czm_getTextureMatrixFromZValue:"const int SHIFT_LEFT8 = 256;\n\nvoid czm_getTextureMatrixFromZValue(in int nZ, inout float XTran, inout float YTran, inout float scale, inout float isRGBA)\n{\n    if(nZ < 0){\n        return ;\n    }\n    int nDel8 = nZ / SHIFT_LEFT8;\n    int nDel16 = nDel8 / SHIFT_LEFT8;\n    YTran = float(nZ - nDel8 * SHIFT_LEFT8);\n    XTran = float(nDel8 - nDel16 * SHIFT_LEFT8);\n    int nLevel = nDel16;\n    scale = 1.0 / pow(2.0, float(nLevel));\n}",czm_getVolumeValue:"uniform sampler2D uVolumeTexture;\n#ifdef TIME_ORDER\nuniform sampler2D uNextVolumeTexture;\nuniform float uTimeRatio;\n#endif\n\n#ifdef Volume\nuniform float width;\nuniform float height;\nuniform float depth;\nuniform float sideBlockCount;\nuniform float blockLength;\nuniform float texLength;\nuniform float uFilterMode;\n#endif\n\nfloat czm_unpackVolume(vec3 packedDepth)\n{\n   return dot(packedDepth, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\n}\n\n#ifdef Volume\nvec2 computeVolumeTextureCoord(vec3 texCoord, float fLevel)\n{\n    float yOffset = floor((fLevel+0.25/sideBlockCount) / sideBlockCount);\n    float xOffset = fLevel - yOffset * sideBlockCount;\n    float texCoordV = (texCoord.y * height + yOffset * blockLength) / texLength;\n    float texCoordU = (texCoord.x * width + xOffset * blockLength) / texLength;\n    return vec2(texCoordU, texCoordV);\n}\n\nfloat computeVolumeValue(sampler2D volumeTexture, vec2 topTexCoord, vec2 bottomTexCoord, float ratio, out float noValue)\n{\n    vec4 volumeValue1 = texture2D(volumeTexture, topTexCoord);\n    vec4 volumeValue2 = texture2D(volumeTexture, bottomTexCoord);\n    float fValue1 = clamp(czm_unpackVolume(volumeValue1.xyz),0.0,1.0);\n    float fValue2 = clamp(czm_unpackVolume(volumeValue2.xyz),0.0,1.0);\n    if(uFilterMode >0.5)\n    {\n        if(ratio<0.5)\n        {\n            ratio = 0.0;\n        }\n        else\n        {\n            ratio = 1.0;\n        }\n    }\n    noValue = mix(volumeValue1.a, volumeValue2.a, ratio);\n    if(volumeValue1.a < 0.5)\n    {\n        fValue1 = fValue2;\n    }\n    if(volumeValue2.a < 0.5)\n    {\n        fValue2 = fValue1;\n    }\n    return mix(fValue1, fValue2, ratio);\n}\n\nfloat czm_getVolumeValue(vec3 texCoord, out float noValue)\n{\n    float fLevel = (depth - 1.0) * texCoord.z;\n    float bottomLevel= floor(fLevel);\n    float topLevel = bottomLevel + 1.0;\n    float ratio = topLevel - fLevel;\n    vec2 topTexCoord = computeVolumeTextureCoord(texCoord, topLevel);\n    vec2 bottomTexCoord = computeVolumeTextureCoord(texCoord, bottomLevel);\n    float fResult = computeVolumeValue(uVolumeTexture, topTexCoord, bottomTexCoord, ratio, noValue);\n#ifdef TIME_ORDER\n    float fNextResult = computeVolumeValue(uNextVolumeTexture, topTexCoord, bottomTexCoord, ratio, noValue);\n    fResult = mix(fResult, fNextResult, uTimeRatio);\n#endif\n    return fResult;\n}\n\nvec4 czm_getVolumeValue(vec3 texCoord)\n{\n\tfloat fLevel = (depth - 1.0) * texCoord.z;\n\tfloat bottomLevel= floor(fLevel);\n\tfloat topLevel = bottomLevel + 1.0;\n\tfloat ratio = topLevel - fLevel;\n\tfloat yOffset1 = floor((topLevel+0.25/sideBlockCount) / sideBlockCount);\n\tfloat xOffset1 = topLevel - yOffset1 * sideBlockCount;\n\tfloat texCoordV1 = (texCoord.y * height + yOffset1 * blockLength)/texLength;\n\tfloat texCoordU1 = (texCoord.x * width + xOffset1 * blockLength)/texLength;\n\tvec4 volumeColor1 = texture2D(uVolumeTexture, vec2(texCoordU1,texCoordV1));\n\tfloat yOffset2 = floor((bottomLevel+0.25/sideBlockCount) / sideBlockCount);\n\tfloat xOffset2 = bottomLevel - yOffset2 * sideBlockCount;\n\tfloat texCoordV2 = (texCoord.y * height + yOffset2 * blockLength)/texLength;\n\tfloat texCoordU2 = (texCoord.x * width + xOffset2 * blockLength)/texLength;\n\tvec4 volumeColor2 = texture2D(uVolumeTexture, vec2(texCoordU2, texCoordV2));\n\n\tif(uFilterMode >0.5)\n\t{\n\t\tif(ratio<0.5)\n\t\t{\n\t\t\tratio = 0.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tratio = 1.0;\n\t\t}\n\t}\n\n\tvec4 volumeColor = mix(volumeColor1, volumeColor2, ratio);\n\n\treturn volumeColor;\n}\n#endif",czm_getVolumeValueMultiResolution:"uniform sampler2D uVolumeTexture1;\nuniform sampler2D uVolumeTexture2;\nuniform sampler2D uVolumeTexture3;\n\n\nuniform mat4 uMultiResolutionPara1;\n/*\n{uMultiResolutionTranslation1\n0.0, 0.0, 0.0, 0.0,\nwidth1,height1,sideBlockCount1,blockLength1\ntexLength1, 0.0, 0.0, 0.0};\n*/\nuniform mat4 uMultiResolutionPara2;\nuniform mat4 uMultiResolutionPara3;\n\n#ifdef TIME_ORDER\nuniform sampler2D uNextVolumeTexture1;\nuniform sampler2D uNextVolumeTexture2;\nuniform sampler2D uNextVolumeTexture3;\n#endif\n\n#ifdef Volume\n\nvec2 computeVolumeTextureCoord(vec2 texCoord, float fLevel, float texWidth, float texHeight, float texSideBlockCount, float texBlockLength, float texTotalLength)\n{\n    float yOffset = floor((fLevel+0.25/texSideBlockCount) / texSideBlockCount);\n    float xOffset = fLevel - yOffset * texSideBlockCount;\n    float texCoordV = (texCoord.y * texHeight + yOffset * texBlockLength) / texTotalLength;\n    float texCoordU = (texCoord.x * texWidth + xOffset * texBlockLength) / texTotalLength;\n    return vec2(texCoordU, texCoordV);\n}\n\nfloat czm_getVolumeValueMultiResolution(vec3 texCoord, out float noValue)\n{\n    float fLevel = (depth - 1.0) * texCoord.z;\n    float bottomLevel= floor(fLevel);\n    float topLevel = bottomLevel + 1.0;\n    float ratio = topLevel - fLevel;\n\n\n    vec2 topTexCoord = computeVolumeTextureCoord(texCoord, topLevel);\n    vec2 bottomTexCoord = computeVolumeTextureCoord(texCoord, bottomLevel);\n\n    float fResult = computeVolumeValue(uVolumeTexture, topTexCoord, bottomTexCoord, ratio, noValue);\n#ifdef TIME_ORDER\n    float fNextResult = computeVolumeValue(uNextVolumeTexture, topTexCoord, bottomTexCoord, ratio, noValue);\n    fResult = mix(fResult, fNextResult, uTimeRatio);\n#endif\n\n\n    float width = uMultiResolutionPara1[2].x;\n    float height = uMultiResolutionPara1[2].y;\n    float sideBlockCount = uMultiResolutionPara1[2].z;\n    float blockLength = uMultiResolutionPara1[2].w;\n    float texLength = uMultiResolutionPara1[3].x;\n    vec4 uMultiResolutionTranslation = uMultiResolutionPara1[0];\n\n    vec2 texCoord1 = (texCoord.xy - uMultiResolutionTranslation.xy) * uMultiResolutionTranslation.zw;\n    vec2 topTexCoord1 = computeVolumeTextureCoord(texCoord1, topLevel, width, height, sideBlockCount, blockLength, texLength);\n    vec2 bottomTexCoord1 = computeVolumeTextureCoord(texCoord1, bottomLevel, width, height, sideBlockCount, blockLength, texLength);\n    float alpha1 = 5.0 * clamp( max(abs(texCoord1.x - 0.5), abs(texCoord1.y - 0.5)) - 0.3,0.0,0.2);\n\n    float fResult1 = computeVolumeValue(uVolumeTexture1, topTexCoord1, bottomTexCoord1, ratio, noValue);\n#ifdef TIME_ORDER\n    float fNextResult1 = computeVolumeValue(uNextVolumeTexture1, topTexCoord1, bottomTexCoord1, ratio, noValue);\n    fResult1 = mix(fResult1, fNextResult1, uTimeRatio);\n#endif\n\n\n    width = uMultiResolutionPara2[2].x;\n    height = uMultiResolutionPara2[2].y;\n    sideBlockCount = uMultiResolutionPara2[2].z;\n    blockLength = uMultiResolutionPara2[2].w;\n    texLength = uMultiResolutionPara2[3].x;\n    uMultiResolutionTranslation = uMultiResolutionPara2[0];\n\n    vec2 texCoord2 = (texCoord.xy - uMultiResolutionTranslation.xy) * uMultiResolutionTranslation.zw;\n    vec2 topTexCoord2 = computeVolumeTextureCoord(texCoord2, topLevel, width, height, sideBlockCount, blockLength, texLength);\n    vec2 bottomTexCoord2 = computeVolumeTextureCoord(texCoord2, bottomLevel, width, height, sideBlockCount, blockLength, texLength);\n    float alpha2 = 5.0 * clamp( max(abs(texCoord2.x - 0.5), abs(texCoord2.y - 0.5)) - 0.3,0.0,0.2);\n\n    float fResult2 = computeVolumeValue(uVolumeTexture2, topTexCoord2, bottomTexCoord2, ratio, noValue);\n#ifdef TIME_ORDER\n    float fNextResult2 = computeVolumeValue(uNextVolumeTexture2, topTexCoord2, bottomTexCoord2, ratio, noValue);\n    fResult2 = mix(fResult2, fNextResult2, uTimeRatio);\n#endif\n\n\n    width = uMultiResolutionPara3[2].x;\n    height = uMultiResolutionPara3[2].y;\n    sideBlockCount = uMultiResolutionPara3[2].z;\n    blockLength = uMultiResolutionPara3[2].w;\n    texLength = uMultiResolutionPara3[3].x;\n    uMultiResolutionTranslation = uMultiResolutionPara3[0];\n\n    vec2 texCoord3 = (texCoord.xy - uMultiResolutionTranslation.xy) * uMultiResolutionTranslation.zw;\n    vec2 topTexCoord3 = computeVolumeTextureCoord(texCoord3, topLevel, width, height, sideBlockCount, blockLength, texLength);\n    vec2 bottomTexCoord3 = computeVolumeTextureCoord(texCoord3, bottomLevel, width, height, sideBlockCount, blockLength, texLength);\n    float alpha3 = 5.0 * clamp( max(abs(texCoord3.x - 0.5), abs(texCoord3.y - 0.5)) - 0.3,0.0,0.2);\n\n    float fResult3 = computeVolumeValue(uVolumeTexture3, topTexCoord3, bottomTexCoord3, ratio, noValue);\n\n#ifdef TIME_ORDER\n    float fNextResult3 = computeVolumeValue(uNextVolumeTexture3, topTexCoord3, bottomTexCoord3, ratio, noValue);\n    fResult3 = mix(fResult3, fNextResult3, uTimeRatio);\n#endif\n\n\n    //return mix(fResult2, mix(fResult1, fResult, alpha1), alpha2);\n    return mix(fResult3, mix(fResult2, mix(fResult1, fResult, alpha1), alpha2), alpha3);\n}\n\n#endif",czm_getWaterNoise:"/**\n * @private\n */\nvec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)\n{\n    float cosAngle = cos(angleInRadians);\n    float sinAngle = sin(angleInRadians);\n\n    // time dependent sampling directions\n    vec2 s0 = vec2(1.0/17.0, 0.0);\n    vec2 s1 = vec2(-1.0/29.0, 0.0);\n    vec2 s2 = vec2(1.0/101.0, 1.0/59.0);\n    vec2 s3 = vec2(-1.0/109.0, -1.0/57.0);\n\n    // rotate sampling direction by specified angle\n    s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));\n    s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));\n    s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));\n    s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));\n\n    vec2 uv0 = (uv/103.0) + (time * s0);\n    vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);\n    vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);\n    vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);\n\n    uv0 = fract(uv0);\n    uv1 = fract(uv1);\n    uv2 = fract(uv2);\n    uv3 = fract(uv3);\n    vec4 noise = (texture2D(normalMap, uv0)) +\n                 (texture2D(normalMap, uv1)) +\n                 (texture2D(normalMap, uv2)) +\n                 (texture2D(normalMap, uv3));\n\n    // average and scale to between -1 and 1\n    return ((noise / 4.0) - 0.5) * 2.0;\n}\n",czm_getWgs84EllipsoidEC:"/**\n * Returns the WGS84 ellipsoid, with its center at the origin of world coordinates, in eye coordinates.\n *\n * @name czm_getWgs84EllipsoidEC\n * @glslFunction\n *\n * @returns {czm_ellipsoid} The WGS84 ellipsoid, with its center at the origin of world coordinates, in eye coordinates.\n *\n * @see Ellipsoid.WGS84\n *\n * @example\n * czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n */\nczm_ellipsoid czm_getWgs84EllipsoidEC()\n{\n    vec3 radii = vec3(6378137.0, 6378137.0, 6378137.0);\n    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\n    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\n    czm_ellipsoid temp = czm_ellipsoid(czm_view[3].xyz, radii, inverseRadii, inverseRadiiSquared);\n    return temp;\n}\n",czm_HSBToRGB:"/**\n * Converts an HSB color (hue, saturation, brightness) to RGB\n * HSB <-> RGB conversion with minimal branching:\n *\n * @name czm_HSBToRGB\n * @glslFunction\n * \n * @param {vec3} hsb The color in HSB.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 hsb = czm_RGBToHSB(rgb);\n * hsb.z *= 0.1;\n * rgb = czm_HSBToRGB(hsb);\n */\n\nconst vec4 K_HSB2RGB = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\nvec3 czm_HSBToRGB(vec3 hsb)\n{\n    vec3 p = abs(fract(hsb.xxx + K_HSB2RGB.xyz) * 6.0 - K_HSB2RGB.www);\n    return hsb.z * mix(K_HSB2RGB.xxx, clamp(p - K_HSB2RGB.xxx, 0.0, 1.0), hsb.y);\n}\n",czm_HSLToRGB:"/**\n * Converts an HSL color (hue, saturation, lightness) to RGB\n * HSL <-> RGB conversion: \n *\n * @name czm_HSLToRGB\n * @glslFunction\n * \n * @param {vec3} rgb The color in HSL.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 hsl = czm_RGBToHSL(rgb);\n * hsl.z *= 0.1;\n * rgb = czm_HSLToRGB(hsl);\n */\n\nvec3 hueToRGB(float hue)\n{\n    float r = abs(hue * 6.0 - 3.0) - 1.0;\n    float g = 2.0 - abs(hue * 6.0 - 2.0);\n    float b = 2.0 - abs(hue * 6.0 - 4.0);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\nvec3 czm_HSLToRGB(vec3 hsl)\n{\n    vec3 rgb = hueToRGB(hsl.x);\n    float c = (1.0 - abs(2.0 * hsl.z - 1.0)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n",czm_hue:"/**\n * Adjusts the hue of a color.\n * \n * @name czm_hue\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the hue of the color in radians.\n *\n * @returns {float} The color with the hue adjusted.\n *\n * @example\n * vec3 adjustHue = czm_hue(color, czm_pi); // The same as czm_hue(color, -czm_pi)\n */\nvec3 czm_hue(vec3 rgb, float adjustment)\n{\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\n                            0.595716, -0.274453, -0.321263,\n                            0.211456, -0.522591,  0.311135);\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\n                            1.0, -0.2721, -0.6474,\n                            1.0, -1.107,   1.7046);\n    \n    vec3 yiq = toYIQ * rgb;\n    float hue = atan(yiq.z, yiq.y) + adjustment;\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\n    \n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\n    return toRGB * color;\n}\n",czm_inverseGamma:"/**\n * Converts a color in linear space to RGB space.\n *\n * @name czm_inverseGamma\n * @glslFunction\n *\n * @param {vec3} color The color in linear space.\n * @returns {vec3} The color in RGB space.\n */\nvec3 czm_inverseGamma(vec3 color) {\n    return pow(color, vec3(1.0 / czm_gamma));\n}\n",czm_inverseMatrix:"mat3 czm_inverseMatrix(mat3 m)\n{\n    float Determinant =\n           m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])\n         - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])\n         + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);\n\n     mat3 Inverse;\n     Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);\n     Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);\n     Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);\n     Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);\n     Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);\n     Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);\n     Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);\n     Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);\n     Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);\n     Inverse /= Determinant;\n\n     return Inverse;\n}\n\nmat4 czm_inverseMatrix(mat4 m)\n{\n    float Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n     float Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];\n     float Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];\n\n     float Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n     float Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];\n     float Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];\n\n     float Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n     float Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];\n     float Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];\n\n     float Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n     float Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];\n     float Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];\n\n     float Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n     float Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];\n     float Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];\n\n     float Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n     float Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];\n     float Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];\n\n     const vec4 SignA = vec4( 1.0, -1.0,  1.0, -1.0);\n     const vec4 SignB = vec4(-1.0,  1.0, -1.0,  1.0);\n\n     vec4 Fac0 = vec4(Coef00, Coef00, Coef02, Coef03);\n     vec4 Fac1 = vec4(Coef04, Coef04, Coef06, Coef07);\n     vec4 Fac2 = vec4(Coef08, Coef08, Coef10, Coef11);\n     vec4 Fac3 = vec4(Coef12, Coef12, Coef14, Coef15);\n     vec4 Fac4 = vec4(Coef16, Coef16, Coef18, Coef19);\n     vec4 Fac5 = vec4(Coef20, Coef20, Coef22, Coef23);\n\n     vec4 Vec0 = vec4(m[1][0], m[0][0], m[0][0], m[0][0]);\n     vec4 Vec1 = vec4(m[1][1], m[0][1], m[0][1], m[0][1]);\n     vec4 Vec2 = vec4(m[1][2], m[0][2], m[0][2], m[0][2]);\n     vec4 Vec3 = vec4(m[1][3], m[0][3], m[0][3], m[0][3]);\n\n     vec4 Inv0 = SignA * (Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);\n     vec4 Inv1 = SignB * (Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);\n     vec4 Inv2 = SignA * (Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);\n     vec4 Inv3 = SignB * (Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);\n\n     mat4 Inverse = mat4(Inv0, Inv1, Inv2, Inv3);\n\n     vec4 Row0 = vec4(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);\n\n     float Determinant = dot(m[0], Row0);\n\n     Inverse /= Determinant;\n\n     return Inverse;\n}\n",czm_isEmpty:"/**\n * Determines if a time interval is empty.\n *\n * @name czm_isEmpty\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isEmpty(czm_raySegment interval)\n{\n    return (interval.stop < 0.0);\n}\n",czm_isFull:"/**\n * Determines if a time interval is empty.\n *\n * @name czm_isFull\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isFull(czm_raySegment interval)\n{\n    return (interval.start == 0.0 && interval.stop == czm_infinity);\n}\n",czm_latitudeToWebMercatorFraction:"/**\n * Computes the fraction of a Web Wercator rectangle at which a given geodetic latitude is located.\n *\n * @name czm_latitudeToWebMercatorFraction\n * @glslFunction\n *\n * @param {float} latitude The geodetic latitude, in radians.\n * @param {float} southMercatorY The Web Mercator coordinate of the southern boundary of the rectangle.\n * @param {float} oneOverMercatorHeight The total height of the rectangle in Web Mercator coordinates.\n *\n * @returns {float} The fraction of the rectangle at which the latitude occurs.  If the latitude is the southern\n *          boundary of the rectangle, the return value will be zero.  If it is the northern boundary, the return\n *          value will be 1.0.  Latitudes in between are mapped according to the Web Mercator projection.\n */ \nfloat czm_latitudeToWebMercatorFraction(float latitude, float southMercatorY, float oneOverMercatorHeight)\n{\n    float sinLatitude = sin(latitude);\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    \n    return (mercatorY - southMercatorY) * oneOverMercatorHeight;\n}\n",czm_lineDistance:"/**\n * Computes distance from an point in 2D to a line in 2D.\n *\n * @name czm_lineDistance\n * @glslFunction\n *\n * param {vec2} point1 A point along the line.\n * param {vec2} point2 A point along the line.\n * param {vec2} point A point that may or may not be on the line.\n * returns {float} The distance from the point to the line.\n */\nfloat czm_lineDistance(vec2 point1, vec2 point2, vec2 point) {\n    return abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / distance(point2, point1);\n}\n",czm_luminance:"/**\n * Computes the luminance of a color. \n *\n * @name czm_luminance\n * @glslFunction\n *\n * @param {vec3} rgb The color.\n * \n * @returns {float} The luminance.\n *\n * @example\n * float light = czm_luminance(vec3(0.0)); // 0.0\n * float dark = czm_luminance(vec3(1.0));  // ~1.0 \n */\nfloat czm_luminance(vec3 rgb)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n",czm_metersPerPixel:"/**\n * Computes the size of a pixel in meters at a distance from the eye.\n * <p>\n * Use this version when passing in a custom pixel ratio. For example, passing in 1.0 will return meters per native device pixel.\n * </p>\n * @name czm_metersPerPixel\n * @glslFunction\n *\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\n * @param {float} pixelRatio The scaling factor from pixel space to coordinate space\n *\n * @returns {float} The meters per pixel at positionEC.\n */\nfloat czm_metersPerPixel(vec4 positionEC, float pixelRatio)\n{\n    float width = czm_viewport.z;\n    float height = czm_viewport.w;\n    float pixelWidth;\n    float pixelHeight;\n\n    float top = czm_frustumPlanes.x;\n    float bottom = czm_frustumPlanes.y;\n    float left = czm_frustumPlanes.z;\n    float right = czm_frustumPlanes.w;\n\n    if (czm_sceneMode == czm_sceneMode2D || czm_orthographicIn3D == 1.0)\n    {\n        float frustumWidth = right - left;\n        float frustumHeight = top - bottom;\n        pixelWidth = frustumWidth / width;\n        pixelHeight = frustumHeight / height;\n    }\n    else\n    {\n        float distanceToPixel = -positionEC.z;\n        float inverseNear = 1.0 / czm_currentFrustum.x;\n        float tanTheta = top * inverseNear;\n        pixelHeight = 2.0 * distanceToPixel * tanTheta / height;\n        tanTheta = right * inverseNear;\n        pixelWidth = 2.0 * distanceToPixel * tanTheta / width;\n    }\n\n    return max(pixelWidth, pixelHeight) * pixelRatio;\n}\n\n/**\n * Computes the size of a pixel in meters at a distance from the eye.\n * <p>\n * Use this version when scaling by pixel ratio.\n * </p>\n * @name czm_metersPerPixel\n * @glslFunction\n *\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\n *\n * @returns {float} The meters per pixel at positionEC.\n */\nfloat czm_metersPerPixel(vec4 positionEC)\n{\n    return czm_metersPerPixel(positionEC, czm_pixelRatio);\n}\n",czm_modelToWindowCoordinates:"/**\n * Transforms a position from model to window coordinates.  The transformation\n * from model to clip coordinates is done using {@link czm_modelViewProjection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n * <br /><br />\n * This function should not be confused with {@link czm_viewportOrthographic},\n * which is an orthographic projection matrix that transforms from window \n * coordinates to clip coordinates.\n *\n * @name czm_modelToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in model coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_eyeToWindowCoordinates\n * @see czm_modelViewProjection\n * @see czm_viewportTransformation\n * @see czm_viewportOrthographic\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_modelToWindowCoordinates(positionMC);\n */\nvec4 czm_modelToWindowCoordinates(vec4 position)\n{\n    vec4 q = czm_modelViewProjection * position;                // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n",czm_multiplyWithColorBalance:"/**\n * DOC_TBA\n *\n * @name czm_multiplyWithColorBalance\n * @glslFunction\n */\nvec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    \n    vec3 target = left * right;\n    float leftLuminance = dot(left, W);\n    float rightLuminance = dot(right, W);\n    float targetLuminance = dot(target, W);\n    \n    return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;\n}\n",czm_nearFarScalar:"/**\n * Computes a value that scales with distance.  The scaling is clamped at the near and\n * far distances, and does not extrapolate.  This function works with the\n * {@link NearFarScalar} JavaScript class.\n *\n * @name czm_nearFarScalar\n * @glslFunction\n *\n * @param {vec4} nearFarScalar A vector with 4 components: Near distance (x), Near value (y), Far distance (z), Far value (w).\n * @param {float} cameraDistSq The square of the current distance from the camera.\n *\n * @returns {float} The value at this distance.\n */\nfloat czm_nearFarScalar(vec4 nearFarScalar, float cameraDistSq)\n{\n    float valueAtMin = nearFarScalar.y;\n    float valueAtMax = nearFarScalar.w;\n    float nearDistanceSq = nearFarScalar.x * nearFarScalar.x;\n    float farDistanceSq = nearFarScalar.z * nearFarScalar.z;\n\n    float t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq);\n\n    t = pow(clamp(t, 0.0, 1.0), 0.2);\n\n    return mix(valueAtMin, valueAtMax, t);\n}\n",czm_octDecode:" /**\n  * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.\n  * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n  * Cigolle et al 2014:\n  *\n  * @name czm_octDecode\n  * @param {vec2} encoded The oct-encoded, unit-length vector\n  * @param {float} range The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n  * @returns {vec3} The decoded and normalized vector\n  */\n  vec3 czm_octDecode(vec2 encoded, float range)\n  {\n      if (encoded.x == 0.0 && encoded.y == 0.0) {\n          return vec3(0.0, 0.0, 0.0);\n      }\n\n     encoded = encoded / range * 2.0 - 1.0;\n     vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\n     if (v.z < 0.0)\n     {\n         v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\n     }\n\n     return normalize(v);\n  }\n\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014:\n *\n * @name czm_octDecode\n * @param {vec2} encoded The oct-encoded, unit-length vector\n * @returns {vec3} The decoded and normalized vector\n */\n vec3 czm_octDecode(vec2 encoded)\n {\n    return czm_octDecode(encoded, 255.0);\n }\n\n /**\n * Decodes a unit-length vector in 'oct' encoding packed into a floating-point number to a normalized 3-component Cartesian vector.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014:\n *\n * @name czm_octDecode\n * @param {float} encoded The oct-encoded, unit-length vector\n * @returns {vec3} The decoded and normalized vector\n */\n vec3 czm_octDecode(float encoded)\n {\n    float temp = encoded / 256.0;\n    float x = floor(temp);\n    float y = (temp - x) * 256.0;\n    return czm_octDecode(vec2(x, y));\n }\n\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into two floating-point numbers to normalized 3-component Cartesian vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014:\n *\n * @name czm_octDecode\n * @param {vec2} encoded The packed oct-encoded, unit-length vectors.\n * @param {vec3} vector1 One decoded and normalized vector.\n * @param {vec3} vector2 One decoded and normalized vector.\n * @param {vec3} vector3 One decoded and normalized vector.\n */\n  void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)\n {\n    float temp = encoded.x / 65536.0;\n    float x = floor(temp);\n    float encodedFloat1 = (temp - x) * 65536.0;\n\n    temp = encoded.y / 65536.0;\n    float y = floor(temp);\n    float encodedFloat2 = (temp - y) * 65536.0;\n\n    vector1 = czm_octDecode(encodedFloat1);\n    vector2 = czm_octDecode(encodedFloat2);\n    vector3 = czm_octDecode(vec2(x, y));\n }\n\n",czm_packDepth:"/**\n * Packs a depth value into a vec3 that can be represented by unsigned bytes.\n *\n * @name czm_packDepth\n * @glslFunction\n *\n * @param {float} depth The floating-point depth.\n * @returns {vec3} The packed depth.\n */\nvec4 czm_packDepth(float depth)\n{\n    // See Aras Pranckevičius' post Encoding Floats to RGBA\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n    return enc;\n}\n",czm_packValue:"/**\n * Packs a float value into a vec3 that can be represented by unsigned bytes.\n *\n * @name czm_packValue\n * @glslFunction\n *\n * @param {float} value The floating-point value.\n * @returns {vec3} The packed value.\n */\nvec4 czm_packValue(float value)\n{\n    float SHIFT_LEFT8 = 256.0;\n\tfloat SHIFT_RIGHT8 = 1.0 / 256.0;\n\tvec4 result;\n\tresult.a = 255.0;\n\tfloat fPos = abs(value + 9000.0) * SHIFT_RIGHT8;\n\tresult.b = (fPos - floor(fPos)) * SHIFT_LEFT8;\n\tfPos = floor(fPos) * SHIFT_RIGHT8;\n\tresult.g = (fPos - floor(fPos)) * SHIFT_LEFT8;\n\tresult.r = floor(fPos);\n\tresult /= 255.0;\n\treturn result;\n}\n",czm_phong:"float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)\n{\n    return czm_getLambertDiffuse(lightDirectionEC, material.normal);\n}\n\nfloat czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)\n{\n    return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);\n}\n\n/**\n * Computes a color using the Phong lighting model.\n *\n * @name czm_phong\n * @glslFunction\n *\n * @param {vec3} toEye A normalized vector from the fragment to the eye in eye coordinates.\n * @param {czm_material} material The fragment's material.\n *\n * @returns {vec4} The computed color.\n *\n * @example\n * vec3 positionToEyeEC = // ...\n * czm_material material = // ...\n * vec3 lightDirectionEC = // ...\n * gl_FragColor = czm_phong(normalize(positionToEyeEC), material, lightDirectionEC);\n *\n * @see czm_getMaterial\n */\nvec4 czm_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    // Diffuse from directional light sources at eye (for top-down)\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material);\n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);\n    }\n\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n\nvec4 czm_private_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(lightDirectionEC, material);\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\n\n    vec3 ambient = vec3(0.0);\n    vec3 color = ambient + material.emission;\n    color += material.diffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n",czm_planeDistance:"/**\n * Computes distance from a point to a plane.\n *\n * @name czm_planeDistance\n * @glslFunction\n *\n * param {vec4} plane A Plane in Hessian Normal Form. See Plane.js\n * param {vec3} point A point in the same space as the plane.\n * returns {float} The distance from the point to the plane.\n */\nfloat czm_planeDistance(vec4 plane, vec3 point) {\n    return (dot(plane.xyz, point) + plane.w);\n}\n\n/**\n * Computes distance from a point to a plane.\n *\n * @name czm_planeDistance\n * @glslFunction\n *\n * param {vec3} planeNormal Normal for a plane in Hessian Normal Form. See Plane.js\n * param {float} planeDistance Distance for a plane in Hessian Normal form. See Plane.js\n * param {vec3} point A point in the same space as the plane.\n * returns {float} The distance from the point to the plane.\n */\nfloat czm_planeDistance(vec3 planeNormal, float planeDistance, vec3 point) {\n    return (dot(planeNormal, point) + planeDistance);\n}\n",czm_pointAlongRay:"/**\n * Computes the point along a ray at the given time.  <code>time</code> can be positive, negative, or zero.\n *\n * @name czm_pointAlongRay\n * @glslFunction\n *\n * @param {czm_ray} ray The ray to compute the point along.\n * @param {float} time The time along the ray.\n * \n * @returns {vec3} The point along the ray at the given time.\n * \n * @example\n * czm_ray ray = czm_ray(vec3(0.0), vec3(1.0, 0.0, 0.0)); // origin, direction\n * vec3 v = czm_pointAlongRay(ray, 2.0); // (2.0, 0.0, 0.0)\n */\nvec3 czm_pointAlongRay(czm_ray ray, float time)\n{\n    return ray.origin + (time * ray.direction);\n}\n",czm_rayEllipsoidIntersectionInterval:"/**\n * DOC_TBA\n *\n * @name czm_rayEllipsoidIntersectionInterval\n * @glslFunction\n */\nczm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, vec3 ellipsoid_center, vec3 ellipsoid_inverseRadii)\n{\n   // ray and ellipsoid center in eye coordinates.  radii in model coordinates.\n    vec3 q = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;\n    vec3 w = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;\n\n    q = q - ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ellipsoid_center, 1.0)).xyz;\n\n    float q2 = dot(q, q);\n    float qw = dot(q, w);\n\n    if (q2 > 1.0) // Outside ellipsoid.\n    {\n        if (qw >= 0.0) // Looking outward or tangent (0 intersections).\n        {\n            return czm_emptyRaySegment;\n        }\n        else // qw < 0.0.\n        {\n            float qw2 = qw * qw;\n            float difference = q2 - 1.0; // Positively valued.\n            float w2 = dot(w, w);\n            float product = w2 * difference;\n\n            if (qw2 < product) // Imaginary roots (0 intersections).\n            {\n                return czm_emptyRaySegment;\n            }\n            else if (qw2 > product) // Distinct roots (2 intersections).\n            {\n                float discriminant = qw * qw - product;\n                float temp = -qw + sqrt(discriminant); // Avoid cancellation.\n                float root0 = temp / w2;\n                float root1 = difference / temp;\n                if (root0 < root1)\n                {\n                    czm_raySegment i = czm_raySegment(root0, root1);\n                    return i;\n                }\n                else\n                {\n                    czm_raySegment i = czm_raySegment(root1, root0);\n                    return i;\n                }\n            }\n            else // qw2 == product.  Repeated roots (2 intersections).\n            {\n                float root = sqrt(difference / w2);\n                czm_raySegment i = czm_raySegment(root, root);\n                return i;\n            }\n        }\n    }\n    else if (q2 < 1.0) // Inside ellipsoid (2 intersections).\n    {\n        float difference = q2 - 1.0; // Negatively valued.\n        float w2 = dot(w, w);\n        float product = w2 * difference; // Negatively valued.\n        float discriminant = qw * qw - product;\n        float temp = -qw + sqrt(discriminant); // Positively valued.\n        czm_raySegment i = czm_raySegment(0.0, temp / w2);\n        return i;\n    }\n    else // q2 == 1.0. On ellipsoid.\n    {\n        if (qw < 0.0) // Looking inward.\n        {\n            float w2 = dot(w, w);\n            czm_raySegment i = czm_raySegment(0.0, -qw / w2);\n            return i;\n        }\n        else // qw >= 0.0.  Looking outward or tangent.\n        {\n            return czm_emptyRaySegment;\n        }\n    }\n}\n",czm_readDepth:"float czm_readDepth(sampler2D depthTexture, vec2 texCoords)\n{\n    return czm_reverseLogDepth(texture2D(depthTexture, texCoords).r);\n}\n",czm_readNonPerspective:"/**\n * Reads a value previously transformed with {@link czm_writeNonPerspective}\n * by dividing it by `w`, the value used in the perspective divide.\n * This function is intended to be called in a fragment shader to access a\n * `varying` that should not be subject to perspective interpolation.\n * For example, screen-space texture coordinates. The value should have been\n * previously written in the vertex shader with a call to\n * {@link czm_writeNonPerspective}.\n *\n * @name czm_readNonPerspective\n * @glslFunction\n *\n * @param {float|vec2|vec3|vec4} value The non-perspective value to be read.\n * @param {float} oneOverW One over the perspective divide value, `w`. Usually this is simply `gl_FragCoord.w`.\n * @returns {float|vec2|vec3|vec4} The usable value.\n */\nfloat czm_readNonPerspective(float value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec2 czm_readNonPerspective(vec2 value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec3 czm_readNonPerspective(vec3 value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec4 czm_readNonPerspective(vec4 value, float oneOverW) {\n    return value * oneOverW;\n}\n",czm_reverseLogDepth:"float czm_reverseLogDepth(float logZ)\n{\n#ifdef LOG_DEPTH\n    float near = czm_currentFrustum.x;\n    float far = czm_currentFrustum.y;\n    float log2Depth = logZ * czm_log2FarDepthFromNearPlusOne;\n    float depthFromNear = pow(2.0, log2Depth) - 1.0;\n    return far * (1.0 - near / (depthFromNear + near)) / (far - near);\n#endif\n    return logZ;\n}\n",czm_RGBToHSB:"/**\n * Converts an RGB color to HSB (hue, saturation, brightness)\n * HSB <-> RGB conversion with minimal branching:\n *\n * @name czm_RGBToHSB\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in HSB.\n *\n * @example\n * vec3 hsb = czm_RGBToHSB(rgb);\n * hsb.z *= 0.1;\n * rgb = czm_HSBToRGB(hsb);\n */\n\nconst vec4 K_RGB2HSB = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\nvec3 czm_RGBToHSB(vec3 rgb)\n{\n    vec4 p = mix(vec4(rgb.bg, K_RGB2HSB.wz), vec4(rgb.gb, K_RGB2HSB.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + czm_epsilon7)), d / (q.x + czm_epsilon7), q.x);\n}\n",czm_RGBToHSL:"/**\n * Converts an RGB color to HSL (hue, saturation, lightness)\n * HSL <-> RGB conversion: \n *\n * @name czm_RGBToHSL\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in HSL.\n *\n * @example\n * vec3 hsl = czm_RGBToHSL(rgb);\n * hsl.z *= 0.1;\n * rgb = czm_HSLToRGB(hsl);\n */\n \nvec3 RGBtoHCV(vec3 rgb)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0 / 3.0) : vec4(rgb.gb, 0.0, -1.0 / 3.0);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6.0 * c + czm_epsilon7) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 czm_RGBToHSL(vec3 rgb)\n{\n    vec3 hcv = RGBtoHCV(rgb);\n    float l = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1.0 - abs(l * 2.0 - 1.0) + czm_epsilon7);\n    return vec3(hcv.x, s, l);\n}\n",czm_RGBToXYZ:"/**\n * Converts an RGB color to CIE Yxy.\n * <p>The conversion is described in\n * </p>\n * \n * @name czm_RGBToXYZ\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in CIE Yxy.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_RGBToXYZ(vec3 rgb)\n{\n    const mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,\n                              0.3576, 0.7152, 0.1192,\n                              0.1805, 0.0722, 0.9505);\n    vec3 xyz = RGB2XYZ * rgb;\n    vec3 Yxy;\n    Yxy.r = xyz.g;\n    float temp = dot(vec3(1.0), xyz);\n    Yxy.gb = xyz.rg / temp;\n    return Yxy;\n}\n",czm_RollerShutter:"void czm_RollerShutter(vec2 coord, vec4 region)\n{\n    vec2 f = step(region.xw, coord);\n    vec2 s = step(coord, region.zy);\n    if (f.x * f.y * s.x * s.y < 1.0)\n    {\n        discard;\n    };\n}\n",czm_s3mBatchOperation:"void czm_s3mBatchOperation(vec4 operationType, vec4 color, vec4 selectedColor, inout vec4 vertexColor, inout vec4 vertexPos, inout vec4 vIsFiltByID, vec3 translation)\n{\n    float right_2 = operationType.x * 0.5;\n    float right_4 = right_2 * 0.5;\n    float right_8 = right_4 * 0.5;\n    float right_16 = right_8 * 0.5;\n    float isSetColor = fract(right_2);\n    if(isSetColor > 0.1)\n    {\n        vertexColor *= color;\n    }\n    float isPicked = fract(floor(right_2)* 0.5);\n    if(isPicked > 0.1)\n    {\n        vertexColor *= selectedColor;\n    }\n    float isHide = fract(floor(right_4)* 0.5);\n    if(isHide > 0.1)\n    {\n        vertexColor.a = 0.0;\n    }\n    float isOffset = fract(floor(right_8)* 0.5);\n    if(isOffset > 0.1)\n    {\n        vertexPos.xyz += translation;\n    }\n    float isClip = fract(floor(right_16) * 0.5);\n    if(isClip > 0.1)\n    {\n        vIsFiltByID.x = 1.0;\n    }\n}\n\nvoid czm_s3mBatchOperation(vec4 operationType, vec4 color, inout vec4 vertexColor, inout vec4 vertexPos, inout vec4 vIsFiltByID, vec3 translation, inout float fSelected)\n{\n    operationType.x += 0.001;\n    float right_2 = operationType.x * 0.5;\n    float right_4 = right_2 * 0.5;\n    float right_8 = right_4 * 0.5;\n    float right_16 = right_8 * 0.5;\n    float isSetColor = fract(right_2);\n    if(isSetColor > 0.1)\n    {\n        vertexColor *= color;\n    }\n    float isPicked = fract(floor(right_2)* 0.5);\n    if(isPicked > 0.1)\n    {\n        fSelected = 1.0;\n    }\n    float isHide = fract(floor(right_4)* 0.5);\n    if(isHide > 0.1)\n    {\n        vertexColor.a = 0.0;\n    }\n    float isOffset = fract(floor(right_8)* 0.5);\n    if(isOffset > 0.1)\n    {\n        vertexPos.xyz += translation;\n    }\n    float isClip = fract(floor(right_16) * 0.5);\n    if(isClip > 0.1)\n    {\n        vIsFiltByID.x = 1.0;\n    }\n}\n\nvoid czm_s3mBatchOperation(vec4 operationType, vec4 color, vec4 selectedColor, inout vec4 vertexColor, inout vec4 vertexPos, inout vec4 vIsFiltByID, vec3 translation, inout float fSelected)\n{\n    operationType.x += 0.001;\n    float right_2 = operationType.x * 0.5;\n    float right_4 = right_2 * 0.5;\n    float right_8 = right_4 * 0.5;\n    float right_16 = right_8 * 0.5;\n    float isSetColor = fract(right_2);\n    if(isSetColor > 0.1)\n    {\n        color.a *= vertexColor.a;\n        vertexColor = color;\n    }\n    float isPicked = fract(floor(right_2)* 0.5);\n    if(isPicked > 0.1)\n    {\n        fSelected = 1.0;\n        #ifdef REPLACE_SELECT_TYPE\n            vertexColor = selectedColor;\n        #else\n            vertexColor *= selectedColor;\n        #endif\n    }\n    float isHide = fract(floor(right_4)* 0.5);\n    if(isHide > 0.1)\n    {\n        vertexColor.a = 0.0;\n    }\n    float isOffset = fract(floor(right_8)* 0.5);\n    if(isOffset > 0.1)\n    {\n        vertexPos.xyz += translation;\n    }\n    float isClip = fract(floor(right_16) * 0.5);\n    if(isClip > 0.1)\n    {\n        vIsFiltByID.x = 1.0;\n    }\n}\n\nvoid czm_s3mBatchOperation(vec4 operationType, vec4 color, vec4 selectedColor, inout vec4 vertexColor)\n{\n    operationType.x += 0.001;\n    float right_2 = operationType.x * 0.5;\n    float right_4 = right_2 * 0.5;\n    float right_8 = right_4 * 0.5;\n    float right_16 = right_8 * 0.5;\n    float isSetColor = fract(right_2);\n    if(isSetColor > 0.1)\n    {\n        vertexColor *= color;\n    }\n    float isPicked = fract(floor(right_2)* 0.5);\n    if(isPicked > 0.1)\n    {\n        vertexColor *= selectedColor;\n    }\n    float isHide = fract(floor(right_4)* 0.5);\n    if(isHide > 0.1)\n    {\n        vertexColor.a = 0.0;\n    }\n}\n\nvoid czm_s3mBatchOperation(vec4 operationType, vec4 color, vec4 selectedColor, inout vec4 vertexColor, inout float fSelected)\n{\n    operationType.x += 0.001;\n    float right_2 = operationType.x * 0.5;\n    float right_4 = right_2 * 0.5;\n    float right_8 = right_4 * 0.5;\n    float right_16 = right_8 * 0.5;\n    float isSetColor = fract(right_2);\n    if(isSetColor > 0.1)\n    {\n        fSelected = 1.0;\n        vertexColor = color;\n    }\n    float isPicked = fract(floor(right_2)* 0.5);\n    if(isPicked > 0.1)\n    {\n        fSelected = 1.0;\n        vertexColor = selectedColor;\n    }\n    float isHide = fract(floor(right_4)* 0.5);\n    if(isHide > 0.1)\n    {\n        vertexColor.a = 0.0;\n    }\n}\n\nvoid czm_s3mBatchOperation(vec4 operationType, vec4 color, vec4 selectedColor, inout vec4 vertexColor, inout vec4 vertexPos, inout vec4 vIsFiltByID, vec3 translation, inout vec2 fSelected)\n{\n    operationType.x += 0.001;\n    float right_2 = operationType.x * 0.5;\n    float right_4 = right_2 * 0.5;\n    float right_8 = right_4 * 0.5;\n    float right_16 = right_8 * 0.5;\n    float isSetColor = fract(right_2);\n    if(isSetColor > 0.1)\n    {\n        fSelected.y = 1.0;\n        color.a *= vertexColor.a;\n        vertexColor = color;\n    }\n    float isPicked = fract(floor(right_2)* 0.5);\n    if(isPicked > 0.1)\n    {\n        fSelected.x = 1.0;\n        #ifdef REPLACE_SELECT_TYPE\n            vertexColor = selectedColor;\n        #else\n            vertexColor *= selectedColor;\n        #endif\n    }\n    float isHide = fract(floor(right_4)* 0.5);\n    if(isHide > 0.1)\n    {\n        vertexColor.a = 0.0;\n    }\n    float isOffset = fract(floor(right_8)* 0.5);\n    if(isOffset > 0.1)\n    {\n        vertexPos.xyz += translation;\n    }\n    float isClip = fract(floor(right_16) * 0.5);\n    if(isClip > 0.1)\n    {\n        vIsFiltByID.x = 1.0;\n    }\n}",czm_S3MPBR:"    uniform float u_metallicFactor;\n    uniform float u_roughnessFactor;\n    uniform vec4 u_emissiveFactor;\n    uniform vec4 u_baseColorFactor;\n    uniform float u_alphaCutoff;\n    uniform sampler2D u_baseColorTexture;\n    uniform sampler2D u_metallicRoughnessTexture;\n    uniform sampler2D u_normalTexture;\n    uniform sampler2D u_occlusionTexture;\n    uniform sampler2D u_emissiveTexture;\n    uniform vec4 u_baseColorUVOffsetAndTiling;\n    uniform vec4 u_emissiveUVOffsetAndTiling;\n\n    uniform float uSunLightON;\n    #if DIR_LIGHTS > 0\n    uniform vec3 uDirectionalLightDirectionEC[ DIR_LIGHTS ];\n    uniform vec3 uDirectionalLightColor[ DIR_LIGHTS ];\n    #endif\n    #if POINT_LIGHTS > 0\n    uniform vec3 uPointLightPositionEC[ POINT_LIGHTS ];\n    uniform vec3 uPointLightColor[ POINT_LIGHTS ];\n    uniform vec2 uPointLightDistanceAndDecay[ POINT_LIGHTS ];\n    #endif\n    #if SPOT_LIGHTS > 0\n    uniform vec3 uSpotLightColor[ SPOT_LIGHTS ];\n    uniform vec3 uSpotLightPositionEC[ SPOT_LIGHTS ];\n    uniform vec3 uSpotLightDirectionEC[ SPOT_LIGHTS ];\n    uniform vec3 uSpotLightDistanceDecayCos[ SPOT_LIGHTS ];\n    uniform vec3 uSpotLightExponent[ SPOT_LIGHTS ];\n    #endif\n\n    const float M_PI = 3.141592653589793;\n\n    vec3 lambertianDiffuse(vec3 diffuseColor)\n    {\n        return diffuseColor / M_PI;\n    }\n\n    vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH)\n    {\n        return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n    }\n\n    vec3 fresnelSchlick(float metalness, float VdotH)\n    {\n        return metalness + (vec3(1.0) - metalness) * pow(1.0 - VdotH, 5.0);\n    }\n\n    vec3 F_Schlick(float ndv, vec3 spec)\n    {\n        return spec + (vec3(1.0) - spec) * pow(1.0 - ndv, 5.0);\n    }\n\n    float D_Phong(float g, float ndh)\n    {\n        float a = pow(8192.0, g);\n        return (a + 2.0) / 8.0 * pow(ndh, a);\n    }\n\n    float smithVisibilityG1(float NdotV, float roughness)\n    {\n        float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n        return NdotV / (NdotV * (1.0 - k) + k);\n    }\n\n    float smithVisibilityGGX(float roughness, float NdotL, float NdotV)\n    {\n        return smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);\n    }\n\n    float GGX(float roughness, float NdotH)\n    {\n        float roughnessSquared = roughness * roughness;\n        float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n        return roughnessSquared / (M_PI * f * f);\n    }\n\n    void getLightColor(vec3 lightDir, vec3 viewDir, vec3 normal, vec3 lightColor, vec3 fresnelTerm, float roughness, out vec3 diffuseTerm, out vec3 specularTerm)\n    {\n        vec3 h = normalize(viewDir + lightDir);\n        float NdotL = clamp(dot(normal, lightDir), 0.001, 1.0);\n        float NdotH = clamp(dot(normal, h), 0.0, 1.0);\n        vec3 li = lightColor * NdotL;\n        diffuseTerm = li;\n        specularTerm = li * fresnelTerm * D_Phong(1.0 - roughness, NdotH);\n    }\n\n    vec3 SRGBtoLINEAR3(vec3 srgbIn)\n    {\n        return pow(srgbIn, vec3(2.2));\n    }\n\n    vec4 SRGBtoLINEAR4(vec4 srgbIn)\n    {\n        vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n        return vec4(linearOut, srgbIn.a);\n    }\n\n    vec3 LINEARtoSRGB(vec3 linearIn)\n    {\n#ifndef HDR\n        return pow(linearIn, vec3(1.0/2.2));\n#else\n        return linearIn;\n#endif\n    }\n\n    float calcLightAttenuation(float lightDistance, float cutoffDistance, float decayExponent)\n    {\n        return pow(clamp(1.0 - lightDistance / cutoffDistance, 0.0, 1.0), decayExponent);\n    }\n\n    vec4 czm_S3MPBR(vec3 normalEC, vec3 positionEC, vec2 texCoord, vec4 vertexColor)\n    {\n        vec3 ng = normalize(normalEC);\n        vec3 positionWC = (czm_inverseView * vec4(positionEC, 1.0)).xyz;\n#ifdef HAS_NORMAL_TEXTURE\n        vec3 pos_dx = dFdx(positionEC);\n        vec3 pos_dy = dFdy(positionEC);\n        vec3 tex_dx = dFdx(vec3(texCoord, 0.0));\n        vec3 tex_dy = dFdy(vec3(texCoord, 0.0));\n        vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n        t = normalize(t - ng * dot(ng, t));\n        vec3 b = normalize(cross(ng, t));\n        mat3 tbn = mat3(t, b, ng);\n        vec3 n = texture2D(u_normalTexture, texCoord).rgb;\n        n = normalize(tbn * (2.0 * n - 1.0));\n#else\n        vec3 n = ng;\n#endif\n\n        vec3 v = -normalize(positionEC);\n#ifdef DOUBLE_SIDED\n        if (dot(n, v) < 0.0) {\n            n = -n;\n        }\n#endif\n\n        // Add base color to fragment shader\n#ifdef HAS_BASECOLOR_TEXTURE\n        vec2 baseColorTexCoord = texCoord;\n        baseColorTexCoord = baseColorTexCoord * u_baseColorUVOffsetAndTiling.zw + u_baseColorUVOffsetAndTiling.xy;\n        vec4 baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, baseColorTexCoord));\n        baseColorWithAlpha *= u_baseColorFactor;\n#else\n        vec4 baseColorWithAlpha = u_baseColorFactor;\n#endif\n        baseColorWithAlpha *= vertexColor;\n        vec3 baseColor = baseColorWithAlpha.rgb;\n#ifdef HAS_METALLICROUGHNESS_TEXTURE\n        vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, texCoord).rgb;\n        float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\n        float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\n        metalness *= u_metallicFactor;\n        roughness *= u_roughnessFactor;\n#else\n        float metalness = clamp(u_metallicFactor, 0.0, 1.0);\n        float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\n#endif\n        vec3 f0 = vec3(0.04);\n        vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\n        vec3 specularColor = mix(f0, baseColor, metalness);\n        float NdotV = abs(dot(n, v)) + 0.001;\n        vec3 diffuseTerm = vec3(0.0);\n        vec3 specularTerm = vec3(0.0);\n        vec3 fresnelTerm = F_Schlick(NdotV, specularColor);\n        vec3 color = vec3(0.0);\n        // 默认加一个平行光作为太阳光\n        vec3 lightDiffuseTerm = vec3(0.0);\n        vec3 lightSpecularTerm = vec3(0.0);\n        getLightColor(czm_sunDirectionEC, v, n, vec3(0.8), fresnelTerm, roughness, lightDiffuseTerm, lightSpecularTerm);\n        diffuseTerm +=lightDiffuseTerm * uSunLightON;\n        specularTerm += lightSpecularTerm * uSunLightON;\n#if DIR_LIGHTS > 0 \n        for (int i = 0; i < DIR_LIGHTS; i++) { \n            getLightColor(uDirectionalLightDirectionEC[i], v, n, uDirectionalLightColor[i], fresnelTerm, roughness, lightDiffuseTerm, lightSpecularTerm);\n            diffuseTerm +=lightDiffuseTerm;\n            specularTerm += lightSpecularTerm;\n        } \n#endif \n#if POINT_LIGHTS > 0 \n        for (int i = 0; i < POINT_LIGHTS; i++) {\n            vec3 lVector = uPointLightPositionEC[i] - v_positionEC;\n            float lightDistance = length(lVector);\n            float lightAttenuation = calcLightAttenuation(lightDistance, uPointLightDistanceAndDecay[i].x, uPointLightDistanceAndDecay[i].y);\n            if(lightAttenuation < 0.001) {\n                continue;\n            }\n            vec3 pointLightColor = uPointLightColor[i] * lightAttenuation;\n            vec3 lightDiffuseTerm = vec3(0.0);\n            vec3 lightSpecularTerm = vec3(0.0);\n            getLightColor(normalize(lVector), v, n, pointLightColor, fresnelTerm, roughness, lightDiffuseTerm, lightSpecularTerm);\n            diffuseTerm +=lightDiffuseTerm;\n            specularTerm += lightSpecularTerm;\n        }\n#endif \n#if SPOT_LIGHTS > 0 \n        for (int i = 0; i < SPOT_LIGHTS; i++) {\n            vec3 lVector = uSpotLightPositionEC[i] - v_positionEC;\n            float lightDistance = length(lVector);\n            float lightAttenuation = calcLightAttenuation(lightDistance, uSpotLightDistanceDecayCos[i].x, uSpotLightDistanceDecayCos[i].y);\n            if(lightAttenuation < 0.001) {\n                continue;\n            }\n            float spotEffect = dot(uSpotLightDirectionEC[i], normalize(lVector));\n            if(spotEffect > uSpotLightDistanceDecayCos[i].z) {\n                vec3 spotLightColor = uSpotLightColor[i] * lightAttenuation * spotEffect;\n                vec3 lightDiffuseTerm = vec3(0.0);\n                vec3 lightSpecularTerm = vec3(0.0);\n                getLightColor(normalize(lVector), v, n, spotLightColor, fresnelTerm, roughness, lightDiffuseTerm, lightSpecularTerm);\n                diffuseTerm +=lightDiffuseTerm;\n                specularTerm += lightSpecularTerm;\n            }\n        }\n#endif \n    color = baseColor; \n    color *= max(diffuseTerm, vec3(0.0)); \n    color += max(specularTerm, vec3(0.0)); \n        // 计算环境光\n    #ifdef USE_IBL_LIGHTING\n        vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\n        // Figure out if the reflection vector hits the ellipsoid\n        float vertexRadius = length(positionWC);\n        float horizonDotNadir = 1.0 - min(1.0, 6378137.0 / vertexRadius);\n        float reflectionDotNadir = dot(r, normalize(positionWC));\n        // Flipping the X vector is a cheap way to get the inverse of czm_temeToPseudoFixed, since that's a rotation about Z.\n        r.x = -r.x;\n        r = -normalize(czm_temeToPseudoFixed * r);\n        r.x = -r.x;\n        float inverseRoughness = 1.04 - roughness;\n        inverseRoughness *= inverseRoughness;\n        vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\n        float atmosphereHeight = 0.05;\n        float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\n        float blendRegionOffset = roughness * -1.0;\n        float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\n        float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\n        float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\n        float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\n        vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\n        vec3 nadirColor = belowHorizonColor * 0.5;\n        vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\n        vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\n        vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\n\n        vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\n        float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\n        float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\n        vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\n\n        float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\n        vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\n        specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\n        specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\n\n        vec2 iblFactor = vec2(1.0);\n        float luminanceAtZenith = 0.5;\n    #ifdef USE_SUN_LUMINANCE\n        // Angle between sun and zenith\n        float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * czm_sunDirectionEC), normalize(positionWC * -1.0)), 0.001, 1.0);\n        float S = acos(LdotZenith);\n        // Angle between zenith and current pixel\n        float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\n        // Angle between sun and current pixel\n        float sunNdotL = clamp(dot(n, czm_sunDirectionEC), 0.001, 1.0);\n        float gamma = acos(sunNdotL);\n        float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(sunNdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\n        float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\n        float luminance = luminanceAtZenith * (numerator / denominator);\n#endif\n\n        vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, 1.0 - roughness)).rg;\n        vec3 IBLColor = (diffuseIrradiance * diffuseColor * iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * iblFactor.y);\n#ifdef USE_SUN_LUMINANCE\n        color += IBLColor * luminance;\n#else\n        color += IBLColor;\n#endif // end of USE_SUN_LUMINANCE\n#endif // end of USE_IBL_LIGHTING\n\n#ifdef HAS_OCCLUSION_TEXTURE\n        color *= texture2D(u_occlusionTexture, texCoord).r;\n#endif\n\n#ifdef HAS_EMISSIVE_TEXTURE\n        vec2 emissiveTexCoord = texCoord;\n        emissiveTexCoord = emissiveTexCoord * u_emissiveUVOffsetAndTiling.zw + u_emissiveUVOffsetAndTiling.xy;\n        vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, emissiveTexCoord).rgb);\n        emissive *= u_emissiveFactor.rgb;\n        color += emissive;\n#else\n        color += u_emissiveFactor.rgb;\n#endif\n        color = LINEARtoSRGB(color);\n        vec4 resultColor = vec4(color, 1.0);\n#ifdef MASK\n        if (baseColorWithAlpha.a < u_alphaCutoff)\n        {\n            discard;\n        }\n        resultColor = vec4(color, 1.0);\n#endif\n#ifdef BLEND\n        resultColor = vec4(color, baseColorWithAlpha.a);\n#endif\n        return resultColor;\n    }",czm_sampleAndBlend:"uniform float uParentMixDirection;\nuniform vec4 u_pickIDColor;\n#ifdef Apply_ImageryClip\nuniform sampler2D uModifyRasterTexture;\n#endif\nvec4 czm_sampleAndBlend(\n    vec4 previousColor,\n    sampler2D textureToSample,\n    vec2 tileTextureCoordinates,\n    vec4 textureCoordinateRectangle,\n    vec4 textureCoordinateTranslationAndScale,\n    vec4 transparentBackColor,\n    bool imageryClipEnable,\n    bool flipY,\n    float textureAlpha,\n    float textureBrightness,\n    float textureContrast,\n    float textureHue,\n    float textureSaturation,\n    float textureOneOverGamma,\n    vec2 split,\n    vec4 swipe,\n    float textureMinAlpha)\n{\n    // This crazy step stuff sets the alpha to 0.0 if this following condition is true:\n    //    tileTextureCoordinates.s < textureCoordinateRectangle.s ||\n    //    tileTextureCoordinates.s > textureCoordinateRectangle.p ||\n    //    tileTextureCoordinates.t < textureCoordinateRectangle.t ||\n    //    tileTextureCoordinates.t > textureCoordinateRectangle.q\n    // In other words, the alpha is zero if the fragment is outside the rectangle\n    // covered by this texture.  Would an actual 'if' yield better performance?\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n\n    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\n    if(flipY)\n    {\n        textureCoordinates.y = 1.0 - textureCoordinates.y;\n    }\n    vec4 value = texture2D(textureToSample, textureCoordinates);\n    vec3 color = value.rgb;\n    float alpha = value.a;\n    if(transparentBackColor.a > 0.01)\n    {\n        float rDiff = abs(transparentBackColor.r - color.r);\n        float gDiff = abs(transparentBackColor.g - color.g);\n        float bDiff = abs(transparentBackColor.b - color.b);\n        if(rDiff < transparentBackColor.a && gDiff < transparentBackColor.a && bDiff < transparentBackColor.a)\n        {\n            alpha = 0.0;\n        }\n    }\n\n    if(imageryClipEnable)\n    {\n    #ifdef Apply_ImageryClip\n        if(texture2D(uModifyRasterTexture, tileTextureCoordinates).w < 0.1)\n        {\n            alpha = 0.0;\n        }\n    #else\n        alpha = 0.0;\n    #endif\n    }\n\n\n#if !defined(APPLY_GAMMA)\n    vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));\n    color = tempColor.rgb;\n    alpha = tempColor.a;\n#else\n    color = pow(color, vec3(textureOneOverGamma));\n#endif\n\n#ifdef APPLY_SPLIT\n    vec2 splitPosition = czm_imagerySplitPosition;\n    // Split to the left\n    if (split.x < 0.0 && gl_FragCoord.x > splitPosition.x) {\n       alpha = 0.0;\n    }\n    // Split to the right\n    else if (split.x > 0.0 && gl_FragCoord.x < splitPosition.x) {\n       alpha = 0.0;\n    }\n    if(split.y < 0.0 && gl_FragCoord.y > splitPosition.y) {\n        alpha = 0.0;\n    }\n    else if(split.y > 0.0 && gl_FragCoord.y < splitPosition.y) {\n        alpha = 0.0;\n    }\n#if TEXTURE_UNITS < 2\n    if(alpha == 0.0)\n    {\n        discard;\n    }\n#endif\n#endif\n\n#ifdef APPLY_SWIPE\n    if (gl_FragCoord.x < swipe.x || gl_FragCoord.y > swipe.y) {\n       alpha = 0.0;\n    }\n    else if (gl_FragCoord.x > swipe.z || gl_FragCoord.y < swipe.w) {\n       alpha = 0.0;\n    }\n#if TEXTURE_UNITS < 2\n    if(alpha == 0.0)\n    {\n        discard;\n    }\n#endif\n\n#endif\n\n#ifdef APPLY_BRIGHTNESS\n    color = mix(vec3(0.0), color, textureBrightness);\n#endif\n\n#ifdef APPLY_CONTRAST\n    color = mix(vec3(0.5), color, textureContrast);\n#endif\n\n#ifdef APPLY_HUE\n    color = czm_hue(color, textureHue);\n#endif\n\n#ifdef APPLY_SATURATION\n    color = czm_saturation(color, textureSaturation);\n#endif\n\n#ifdef ALPHAFILTER\n    if(alpha <= textureMinAlpha)\n    {\n        return previousColor.rgba;\n    }\n#endif\n\n    float sourceAlpha = alpha * textureAlpha;\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\n    return vec4(outColor, outAlpha);\n}\n\nvec4 sampleAndBlendParent(\n    vec4 previousColor,\n    sampler2D textureToSample,\n    vec2 tileTextureCoordinates,\n    vec4 textureCoordinateRectangle,\n    vec4 textureCoordinateTranslationAndScale,\n    vec4 transparentBackColor,\n    bool flipY,\n    float textureAlpha,\n    float textureBrightness,\n    float textureContrast,\n    float textureHue,\n    float textureSaturation,\n    float textureOneOverGamma,\n    vec2 split,\n    vec4 swipe,\n    float textureMinAlpha)\n{\n    // This crazy step stuff sets the alpha to 0.0 if this following condition is true:\n    //    tileTextureCoordinates.s < textureCoordinateRectangle.s ||\n    //    tileTextureCoordinates.s > textureCoordinateRectangle.p ||\n    //    tileTextureCoordinates.t < textureCoordinateRectangle.t ||\n    //    tileTextureCoordinates.t > textureCoordinateRectangle.q\n    // In other words, the alpha is zero if the fragment is outside the rectangle\n    // covered by this texture.  Would an actual 'if' yield better performance?\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n\n    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\n    if(flipY)\n    {\n        textureCoordinates.y = 1.0 - textureCoordinates.y;\n    }\n    vec4 value = texture2D(textureToSample, textureCoordinates);\n\tif(uParentMixDirection > 0.0 && value.a > 0.01)\n\t{\n\t\tvalue.a = 0.0;\n\t\tbool blend = false;\n\t\tfloat mixDirection = uParentMixDirection;\n\t\tif( mixDirection > 7.0 )\n\t\t{\n\t\t    //南\n\t\t\tif(tileTextureCoordinates.y <0.3)\n\t\t\t{\n\t\t\t\tblend = true;\n\t\t\t}\n\t\t\tmixDirection-=8.0;\n\t\t}\n\t\telse if( mixDirection > 3.0)\n\t\t{\n\t\t    //北\n\t\t\tif(tileTextureCoordinates.y >0.7)\n\t\t\t{\n\t\t\t\tblend = true;\n\t\t\t}\n\t\t\tmixDirection-=4.0;\n\t\t}\n\t\tif(blend)\n\t\t{\n\t\t\t//纹理坐标0-0.5，中心是0边缘是0.5\n\t\t\tfloat mixY = abs(tileTextureCoordinates.y-0.5);\n\t\t\t//mixValue0-5，中心是0边缘是5\n\t\t\tfloat mixValue = 10.0*mixY;\n\t\t\t//mixValue0-1，中心是0边缘3/5处开始0-1渐变\n\t\t\t//mixValue = clamp(0.5*(mixValue - 3.0), 0.0, 1.0);\n\t\t\tmixValue = clamp((mixValue - 4.0), 0.0, 1.0);\n\t\t\tvalue.a = mixValue;\n\t\t}\n\t\tblend = false;\n\t\tif( mixDirection > 1.5)\n\t\t{\n\t\t    //东\n\t\t\tif(tileTextureCoordinates.x >0.7)\n\t\t\t{\n\t\t\t\tblend = true;\n\t\t\t}\n\t\t\tmixDirection-=2.0;\n\t\t}\n\t\telse if( mixDirection > 0.5)\n\t\t{\n\t\t    //西\n\t\t\tif(tileTextureCoordinates.x <0.3)\n\t\t\t{\n\t\t\t\tblend = true;\n\t\t\t}\n\t\t}\n\t\tif(blend)\n\t\t{\n\t\t\tfloat mixValue = 10.0*abs(tileTextureCoordinates.x-0.5);\n\t\t\tmixValue = clamp((mixValue - 4.0), 0.0, 1.0);\n\t\t\tvalue.a = max(mixValue, value.a);\n\t\t}\n\t}\n    vec3 color = value.rgb;\n    float alpha = value.a;\n    if(transparentBackColor.a > 0.01)\n    {\n        float rDiff = abs(transparentBackColor.r - color.r);\n        float gDiff = abs(transparentBackColor.g - color.g);\n        float bDiff = abs(transparentBackColor.b - color.b);\n        if(rDiff < transparentBackColor.a && gDiff < transparentBackColor.a && bDiff < transparentBackColor.a)\n        {\n            alpha = 0.0;\n        }\n    }\n#if !defined(APPLY_GAMMA)\n    vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));\n    color = tempColor.rgb;\n    alpha = tempColor.a;\n#else\n    color = pow(color, vec3(textureOneOverGamma));\n#endif\n#ifdef APPLY_SPLIT\n    vec2 splitPosition = czm_imagerySplitPosition;\n    // Split to the left\n    if (split.x < 0.0 && gl_FragCoord.x > splitPosition.x) {\n       alpha = 0.0;\n    }\n    // Split to the right\n    else if (split.x > 0.0 && gl_FragCoord.x < splitPosition.x) {\n       alpha = 0.0;\n    }\n    if(split.y < 0.0 && gl_FragCoord.y > splitPosition.y) {\n        alpha = 0.0;\n    }\n    else if(split.y > 0.0 && gl_FragCoord.y < splitPosition.y) {\n        alpha = 0.0;\n    }\n#if TEXTURE_UNITS < 2\n    if(alpha == 0.0)\n    {\n        discard;\n    }\n#endif\n#endif\n#ifdef APPLY_SWIPE\n    if (gl_FragCoord.x < swipe.x || gl_FragCoord.y > swipe.y) {\n       alpha = 0.0;\n    }\n    else if (gl_FragCoord.x > swipe.z || gl_FragCoord.y < swipe.w) {\n       alpha = 0.0;\n    }\n#if TEXTURE_UNITS < 2\n    if(alpha == 0.0)\n    {\n        discard;\n    }\n#endif\n#endif\n#ifdef APPLY_BRIGHTNESS\n    color = mix(vec3(0.0), color, textureBrightness);\n#endif\n#ifdef APPLY_CONTRAST\n    color = mix(vec3(0.5), color, textureContrast);\n#endif\n#ifdef APPLY_HUE\n    color = czm_hue(color, textureHue);\n#endif\n#ifdef APPLY_SATURATION\n    color = czm_saturation(color, textureSaturation);\n#endif\n#ifdef ALPHAFILTER\n    if(alpha <= textureMinAlpha)\n    {\n        return previousColor.rgba;\n    }\n#endif\n    float sourceAlpha = alpha * textureAlpha;\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\n    return vec4(outColor, outAlpha);\n}\n\nvec4 mvtTextureSampleAndBlend(\n    vec4 previousColor,\n    sampler2D textureToSample,\n    sampler2D idTextureToSample,\n    vec2 tileTextureCoordinates,\n    vec4 textureCoordinateRectangle,\n    vec4 textureCoordinateTranslationAndScale,\n    vec4 selectColor,\n    float textureAlpha,\n    float textureOneOverGamma,\n    vec4 swipe)\n{\n#ifdef APPLY_SWIPE\n    vec2 f = step(swipe.xw, vec2(gl_FragCoord.xy));\n    vec2 s = step(vec2(gl_FragCoord.xy), swipe.zy);\n    if (f.x * f.y * s.x * s.y < 1.0) {\n        return previousColor;\n    };\n#endif\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n\n    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\n    vec4 value = texture2D(textureToSample, textureCoordinates);\n    vec4 idColor = texture2D(idTextureToSample, textureCoordinates);\n    if(idColor.r == u_pickIDColor.r && idColor.g == u_pickIDColor.g && idColor.b == u_pickIDColor.b){\n        value.rgb = selectColor.rgb;\n    }\n    vec3 color = value.rgb;\n    float alpha = value.a;\n#if !defined(APPLY_GAMMA)\n    vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));\n    color = tempColor.rgb;\n    alpha = tempColor.a;\n#else\n    color = pow(color, vec3(textureOneOverGamma));\n#endif\n    float sourceAlpha = alpha * textureAlpha;\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\n    return vec4(outColor, outAlpha);\n}\n\nvec4 gridTextureSampleAndBlend(\n    vec4 previousColor,\n    sampler2D textureToSample,\n    vec2 tileTextureCoordinates,\n    vec4 textureCoordinateRectangle,\n    vec4 textureCoordinateTranslationAndScale)\n{\n    float textureAlpha = 1.0;\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\n    vec4 value = texture2D(textureToSample, textureCoordinates);\n    vec3 color = value.rgb;\n    float alpha = value.a;\n    float sourceAlpha = alpha * textureAlpha;\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\n    return vec4(outColor, outAlpha);\n}",czm_sampleOctahedralProjection:"/**\n * Samples the 4 neighboring pixels and return the weighted average.\n *\n * @private\n */\nvec3 czm_sampleOctahedralProjectionWithFiltering(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod)\n{\n    direction /= dot(vec3(1.0), abs(direction));\n    vec2 rev = abs(direction.zx) - vec2(1.0);\n    vec2 neg = vec2(direction.x < 0.0 ? rev.x : -rev.x,\n                    direction.z < 0.0 ? rev.y : -rev.y);\n    vec2 uv = direction.y < 0.0 ? neg : direction.xz;\n    vec2 coord = 0.5 * uv + vec2(0.5);\n    vec2 pixel = 1.0 / textureSize;\n\n    if (lod > 0.0)\n    {\n        // Each subseqeuent mip level is half the size\n        float scale = 1.0 / pow(2.0, lod);\n        float offset = ((textureSize.y + 1.0) / textureSize.x);\n\n        coord.x *= offset;\n        coord *= scale;\n\n        coord.x += offset + pixel.x;\n        coord.y += (1.0 - (1.0 / pow(2.0, lod - 1.0))) + pixel.y * (lod - 1.0) * 2.0;\n    }\n    else\n    {\n        coord.x *= (textureSize.y / textureSize.x);\n    }\n\n    // Do bilinear filtering\n    #ifndef OES_texture_float_linear\n        vec3 color1 = texture2D(projectedMap, coord + vec2(0.0, pixel.y)).rgb;\n        vec3 color2 = texture2D(projectedMap, coord + vec2(pixel.x, 0.0)).rgb;\n        vec3 color3 = texture2D(projectedMap, coord + pixel).rgb;\n        vec3 color4 = texture2D(projectedMap, coord).rgb;\n\n        vec2 texturePosition = coord * textureSize;\n\n        float fu = fract(texturePosition.x);\n        float fv = fract(texturePosition.y);\n\n        vec3 average1 = mix(color4, color2, fu);\n        vec3 average2 = mix(color1, color3, fu);\n\n        vec3 color = mix(average1, average2, fv);\n    #else\n        vec3 color = texture2D(projectedMap, coord).rgb;\n    #endif\n\n    return color;\n}\n\n\n/**\n * Samples from a cube map that has been projected using an octahedral projection from the given direction.\n *\n * @name czm_sampleOctahedralProjection\n * @glslFunction\n *\n * @param {sampler2D} projectedMap The texture with the octahedral projected cube map.\n * @param {vec2} textureSize The width and height dimensions in pixels of the projected map.\n * @param {vec3} direction The normalized direction used to sample the cube map.\n * @param {float} lod The level of detail to sample.\n * @param {float} maxLod The maximum level of detail.\n * @returns {vec3} The color of the cube map at the direction.\n */\nvec3 czm_sampleOctahedralProjection(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod, float maxLod) {\n    float currentLod = floor(lod + 0.5);\n    float nextLod = min(currentLod + 1.0, maxLod);\n\n    vec3 colorCurrentLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, currentLod);\n    vec3 colorNextLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, nextLod);\n\n    return mix(colorNextLod, colorCurrentLod, nextLod - lod);\n}\n",czm_saturation:"/**\n * Adjusts the saturation of a color.\n * \n * @name czm_saturation\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the saturation of the color.\n *\n * @returns {float} The color with the saturation adjusted.\n *\n * @example\n * vec3 greyScale = czm_saturation(color, 0.0);\n * vec3 doubleSaturation = czm_saturation(color, 2.0);\n */\nvec3 czm_saturation(vec3 rgb, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n",czm_shadowDepthCompare:"\nfloat czm_sampleShadowMap(samplerCube shadowMap, vec3 d)\n{\n    return czm_unpackDepth(textureCube(shadowMap, d));\n}\n\nfloat czm_sampleShadowMap(sampler2D shadowMap, vec2 uv)\n{\n#ifdef USE_SHADOW_DEPTH_TEXTURE\n    return texture2D(shadowMap, uv).r;\n#else\n    return czm_unpackDepth(texture2D(shadowMap, uv));\n#endif\n}\n\nfloat czm_shadowDepthCompare(samplerCube shadowMap, vec3 uv, float depth)\n{\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\n\nfloat czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth)\n{\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\n",czm_shadowVisibility:"\nfloat czm_private_shadowVisibility(float visibility, float nDotL, float normalShadingSmooth, float darkness)\n{\n#ifdef USE_NORMAL_SHADING\n#ifdef USE_NORMAL_SHADING_SMOOTH\n    float strength = clamp(nDotL / normalShadingSmooth, 0.0, 1.0);\n#else\n    float strength = step(0.0, nDotL);\n#endif\n    visibility *= strength;\n#endif\n\n    visibility = max(visibility, darkness);\n    return visibility;\n}\n\n#ifdef USE_CUBE_MAP_SHADOW\nfloat czm_shadowVisibility(samplerCube shadowMap, czm_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec3 uvw = shadowParameters.texCoords;\n\n    depth -= depthBias;\n    float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth);\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#else\nfloat czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec2 uv = shadowParameters.texCoords;\n\n    depth -= depthBias;\n#ifdef USE_SOFT_SHADOWS\n    vec2 texelStepSize = shadowParameters.texelStepSize;\n    float radius = 1.0;\n    float dx0 = -texelStepSize.x * radius;\n    float dy0 = -texelStepSize.y * radius;\n    float dx1 = texelStepSize.x * radius;\n    float dy1 = texelStepSize.y * radius;\n    float visibility = (\n        czm_shadowDepthCompare(shadowMap, uv, depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n    ) * (1.0 / 9.0);\n#else\n    float visibility = czm_shadowDepthCompare(shadowMap, uv, depth);\n#endif\n\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#endif\n",czm_signNotZero:"/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.  This is similar to the GLSL\n * built-in function <code>sign</code> except that returns 1.0 instead of 0.0 when the input value is 0.0.\n * \n * @name czm_signNotZero\n * @glslFunction\n *\n * @param {} value The value for which to determine the sign.\n * @returns {} 1.0 if the value is positive or zero, -1.0 if the value is negative.\n */\nfloat czm_signNotZero(float value)\n{\n    return value >= 0.0 ? 1.0 : -1.0;\n}\n\nvec2 czm_signNotZero(vec2 value)\n{\n    return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\n}\n\nvec3 czm_signNotZero(vec3 value)\n{\n    return vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z));\n}\n\nvec4 czm_signNotZero(vec4 value)\n{\n    return vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w));\n}\n",czm_sketchMode:"uniform sampler2D uNormalDepthTexture;\nuniform int uFillStyle;\nfloat edgeDetection(float lineWidth)\n{\n    vec2 center = gl_FragCoord.xy / czm_globeDepthTextureDim.xy;\n    vec2 off = lineWidth / czm_globeDepthTextureDim.xy;\n    vec4 tex_nw = vec4(center.x+off.x, center.y+off.y, 1.0, 1.0);\n    vec4 val_nw = texture2D(uNormalDepthTexture, tex_nw.xy);\n    val_nw.xyz = (val_nw.xyz * 2.0) - 1.0;\n    vec4 tex_ne = vec4(center.x-off.x, center.y+off.y, 1.0, 1.0);\n    vec4 val_ne =  texture2D(uNormalDepthTexture, tex_ne.xy);\n    val_ne.xyz = (val_ne.xyz * 2.0) - 1.0;\n    vec4 tex_sw = vec4(center.x+off.x, center.y-off.y, 1.0, 1.0);\n    vec4 val_sw = texture2D(uNormalDepthTexture, tex_sw.xy);\n    val_sw.xyz = (val_sw.xyz * 2.0 ) - 1.0;\n    vec4 tex_se = vec4(center.x-off.x, center.y-off.y, 1.0, 1.0);\n    vec4 val_se = texture2D(uNormalDepthTexture, tex_se.xy);\n    val_se.xyz = (val_se.xyz * 2.0) - 1.0;\n    float discontinuity = 0.0;\n    float dot0 = dot(val_nw.xyz, val_se.xyz);\n    float dot1 = dot(val_ne.xyz, val_sw.xyz);\n    discontinuity = 0.5*(dot0+dot1);\n    return discontinuity;\n}\nvec4 czm_sketchMode(vec4 inputColor, vec4 lineColor, float lineWidth)\n{\n    vec4 outputColor = inputColor;\n    float discontinuity = edgeDetection(lineWidth);\n    discontinuity = clamp(discontinuity, 0.0, 1.0);\n    if(uFillStyle == 1)\n    {\n        outputColor = lineColor;\n        outputColor.a = (1.0 - sign(discontinuity - 0.5)) * 0.5;\n        outputColor.a *= lineColor.a;\n    }\n    else\n    {\n        vec3 mixLineColor = mix(inputColor.rgb, vec3(lineColor.rgb), lineColor.a);\n        outputColor.rgb = mix(mixLineColor, inputColor.rgb, discontinuity);\n    }\n    return outputColor;\n}",czm_sphericalHarmonics:"/**\n * Computes a color from the third order spherical harmonic coefficients and a normalized direction vector.\n * <p>\n * The order of the coefficients is [L00, L1_1, L10, L11, L2_2, L2_1, L20, L21, L22].\n * </p>\n *\n * @name czm_sphericalHarmonics\n * @glslFunction\n *\n * @param {vec3} normal The normalized direction.\n * @param {vec3[9]} coefficients The third order spherical harmonic coefficients.\n * @returns {vec3} The color at the direction.\n *\n */\nvec3 czm_sphericalHarmonics(vec3 normal, vec3 coefficients[9])\n{\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n\n    vec3 L00 = coefficients[0];\n    vec3 L1_1 = coefficients[1];\n    vec3 L10 = coefficients[2];\n    vec3 L11 = coefficients[3];\n    vec3 L2_2 = coefficients[4];\n    vec3 L2_1 = coefficients[5];\n    vec3 L20 = coefficients[6];\n    vec3 L21 = coefficients[7];\n    vec3 L22 = coefficients[8];\n\n    float x = normal.x;\n    float y = normal.y;\n    float z = normal.z;\n\n    return c1 * L22 * (x * x - y * y) + c3 * L20 * z * z + c4 * L00 - c5 * L20 +\n           2.0 * c1 * (L2_2 * x * y + L21 * x * z + L2_1 * y * z) +\n           2.0 * c2 * (L11 * x + L1_1 * y + L10 * z);\n}\n",czm_tangentToEyeSpaceMatrix:"/**\n * Creates a matrix that transforms vectors from tangent space to eye space.\n *\n * @name czm_tangentToEyeSpaceMatrix\n * @glslFunction\n *\n * @param {vec3} normalEC The normal vector in eye coordinates.\n * @param {vec3} tangentEC The tangent vector in eye coordinates.\n * @param {vec3} bitangentEC The bitangent vector in eye coordinates.\n *\n * @returns {mat3} The matrix that transforms from tangent space to eye space.\n *\n * @example\n * mat3 tangentToEye = czm_tangentToEyeSpaceMatrix(normalEC, tangentEC, bitangentEC);\n * vec3 normal = tangentToEye * texture2D(normalMap, st).xyz;\n */\nmat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 bitangentEC)\n{\n    vec3 normal = normalize(normalEC);\n    vec3 tangent = normalize(tangentEC);\n    vec3 bitangent = normalize(bitangentEC);\n    return mat3(tangent.x  , tangent.y  , tangent.z,\n                bitangent.x, bitangent.y, bitangent.z,\n                normal.x   , normal.y   , normal.z);\n}\n",czm_transformPlane:"vec4 czm_transformPlane(vec4 clippingPlane, mat4 transform) {\n    vec3 transformedDirection = normalize((transform * vec4(clippingPlane.xyz, 0.0)).xyz);\n    vec3 transformedPosition = (transform * vec4(clippingPlane.xyz * -clippingPlane.w, 1.0)).xyz;\n    vec4 transformedPlane;\n    transformedPlane.xyz = transformedDirection;\n    transformedPlane.w = -dot(transformedDirection, transformedPosition);\n    return transformedPlane;\n}\n",czm_translateRelativeToEye:"/**\n * Translates a position (or any <code>vec3</code>) that was encoded with {@link EncodedCartesian3},\n * and then provided to the shader as separate <code>high</code> and <code>low</code> bits to\n * be relative to the eye.  As shown in the example, the position can then be transformed in eye\n * or clip coordinates using {@link czm_modelViewRelativeToEye} or {@link czm_modelViewProjectionRelativeToEye},\n * respectively.\n * <p>\n * This technique, called GPU RTE, eliminates jittering artifacts when using large coordinates as\n * described in .\n * </p>\n *\n * @name czm_translateRelativeToEye\n * @glslFunction\n *\n * @param {vec3} high The position's high bits.\n * @param {vec3} low The position's low bits.\n * @returns {vec3} The position translated to be relative to the camera's position.\n *\n * @example\n * attribute vec3 positionHigh;\n * attribute vec3 positionLow;\n *\n * void main()\n * {\n *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n * }\n *\n * @see czm_modelViewRelativeToEye\n * @see czm_modelViewProjectionRelativeToEye\n * @see czm_computePosition\n * @see EncodedCartesian3\n */\nvec4 czm_translateRelativeToEye(vec3 high, vec3 low)\n{\n    vec3 highDifference = high - czm_encodedCameraPositionMCHigh;\n    // This check handles the case when NaN values have gotten into `highDifference`\n    // Such a thing could happen on devices running iOS\n    if(length(highDifference) == 0.0) {\n        highDifference = vec3(0);\n    }\n    vec3 lowDifference = low - czm_encodedCameraPositionMCLow;\n\n    return vec4(highDifference + lowDifference, 1.0);\n}\n",czm_translucentPhong:"/**\n * @private\n */\nvec4 czm_translucentPhong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    // Diffuse from directional light sources at eye (for top-down and horizon views)\n    float diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal);\n\n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal);\n    }\n\n    diffuse = clamp(diffuse, 0.0, 1.0);\n\n    float specular = czm_getSpecular(lightDirectionEC, toEye, material.normal, material.shininess);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n",czm_transpose:"/**\n * Returns the transpose of the matrix.  The input <code>matrix</code> can be\n * a <code>mat2</code>, <code>mat3</code>, or <code>mat4</code>.\n *\n * @name czm_transpose\n * @glslFunction\n *\n * @param {} matrix The matrix to transpose.\n *\n * @returns {} The transposed matrix.\n *\n * @example\n * // GLSL declarations\n * mat2 czm_transpose(mat2 matrix);\n * mat3 czm_transpose(mat3 matrix);\n * mat4 czm_transpose(mat4 matrix);\n *\n * // Transpose a 3x3 rotation matrix to find its inverse.\n * mat3 eastNorthUpToEye = czm_eastNorthUpToEyeCoordinates(\n *     positionMC, normalEC);\n * mat3 eyeToEastNorthUp = czm_transpose(eastNorthUpToEye);\n */\nmat2 czm_transpose(mat2 matrix)\n{\n    return mat2(\n        matrix[0][0], matrix[1][0],\n        matrix[0][1], matrix[1][1]);\n}\n\nmat3 czm_transpose(mat3 matrix)\n{\n    return mat3(\n        matrix[0][0], matrix[1][0], matrix[2][0],\n        matrix[0][1], matrix[1][1], matrix[2][1],\n        matrix[0][2], matrix[1][2], matrix[2][2]);\n}\n\nmat4 czm_transpose(mat4 matrix)\n{\n    return mat4(\n        matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\n        matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\n        matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\n        matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n}\n",czm_unpackDepth:"/**\n * Unpacks a vec4 depth value to a float in [0, 1) range.\n *\n * @name czm_unpackDepth\n * @glslFunction\n *\n * @param {vec4} packedDepth The packed depth.\n *\n * @returns {float} The floating-point depth in [0, 1) range.\n */\n float czm_unpackDepth(vec4 packedDepth)\n {\n    // See Aras Pranckevičius' post Encoding Floats to RGBA\n    return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n }\n",czm_unpackFloat:"#define SHIFT_RIGHT_8 0.00390625 //1.0 / 256.0\n#define SHIFT_RIGHT_16 0.00001525878 //1.0 / 65536.0\n#define SHIFT_RIGHT_24 5.960464477539063e-8//1.0 / 16777216.0\n\n#define BIAS 38.0\n\n/**\n * Unpacks a vec4 value containing values expressable as uint8 to an arbitrary float.\n *\n * @name czm_unpackFloat\n * @glslFunction\n *\n * @param {vec4} packedFloat The packed float.\n *\n * @returns {float} The floating-point depth in arbitrary range.\n */\n float czm_unpackFloat(vec4 packedFloat)\n{\n    packedFloat *= 255.0;\n    float temp = packedFloat.w / 2.0;\n    float exponent = floor(temp);\n    float sign = (temp - exponent) * 2.0;\n    exponent = exponent - float(BIAS);\n    sign = sign * 2.0 - 1.0;\n    sign = -sign;\n    float unpacked = sign * packedFloat.x * float(SHIFT_RIGHT_8);\n    unpacked += sign * packedFloat.y * float(SHIFT_RIGHT_16);\n    unpacked += sign * packedFloat.z * float(SHIFT_RIGHT_24);\n    return unpacked * pow(10.0, exponent);\n}\n",czm_unpackValue:"/**\n * Unpacks a vec4 value to a float.\n *\n * @name czm_unpackValue\n * @glslFunction\n *\n * @param {vec3} packedValue The packed value.\n *\n * @returns {float} The floating-point value.\n */\n float czm_unpackValue(vec4 packedValue)\n {\n    float SHIFT_LEFT16 = 65536.0;\n\tfloat SHIFT_LEFT8 = 256.0;\n\tvec4 value = packedValue * 255.0;\n\treturn value.r * SHIFT_LEFT16 + value.g * SHIFT_LEFT8 + value.b - 9000.0;\n }\n",czm_vertexLogDepth:"#ifdef LOG_DEPTH\n// 1.0 at the near plane, increasing linearly from there.\nvarying float v_depthFromNearPlusOne;\n#ifdef SHADOW_MAP\nvarying vec3 v_logPositionEC;\n#endif\n#endif\n\nvec4 czm_updatePositionDepth(vec4 coords) {\n#if defined(LOG_DEPTH)\n\n#ifdef SHADOW_MAP\n    vec3 logPositionEC = (czm_inverseProjection * coords).xyz;\n    v_logPositionEC = logPositionEC;\n#endif\n\n    // With the very high far/near ratios used with the logarithmic depth\n    // buffer, floating point rounding errors can cause linear depth values\n    // to end up on the wrong side of the far plane, even for vertices that\n    // are really nowhere near it. Since we always write a correct logarithmic\n    // depth value in the fragment shader anyway, we just need to make sure\n    // such errors don't cause the primitive to be clipped entirely before\n    // we even get to the fragment shader.\n    coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;\n#endif\n\n    return coords;\n}\n\n/**\n * Writes the logarithmic depth to gl_Position using the already computed gl_Position.\n *\n * @name czm_vertexLogDepth\n * @glslFunction\n */\nvoid czm_vertexLogDepth()\n{\n#ifdef LOG_DEPTH\n    v_depthFromNearPlusOne = 1.0 - czm_currentFrustum.x + gl_Position.w;\n    gl_Position = czm_updatePositionDepth(gl_Position);\n#endif\n}\n\n/**\n * Writes the logarithmic depth to gl_Position using the provided clip coordinates.\n * <p>\n * An example use case for this function would be moving the vertex in window coordinates\n * before converting back to clip coordinates. Use the original vertex clip coordinates.\n * </p>\n * @name czm_vertexLogDepth\n * @glslFunction\n *\n * @param {vec4} clipCoords The vertex in clip coordinates.\n *\n * @example\n * czm_vertexLogDepth(czm_projection * vec4(positionEyeCoordinates, 1.0));\n */\nvoid czm_vertexLogDepth(vec4 clipCoords)\n{\n#ifdef LOG_DEPTH\n    v_depthFromNearPlusOne = 1.0 - czm_currentFrustum.x + clipCoords.w;\n    czm_updatePositionDepth(clipCoords);\n#endif\n}\n",czm_windowToEyeCoordinates:"/**\n * Transforms a position from window to eye coordinates.\n * The transform from window to normalized device coordinates is done using components\n * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating\n * the inverse of <code>czm_viewportTransformation</code>. The transformation from\n * normalized device coordinates to clip coordinates is done using <code>fragmentCoordinate.w</code>,\n * which is expected to be the scalar used in the perspective divide. The transformation\n * from clip to eye coordinates is done using {@link czm_inverseProjection}.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec4} fragmentCoordinate The position in window coordinates to transform.\n *\n * @returns {vec4} The transformed position in eye coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @example\n * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord);\n */\nvec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\n{\n    // Reconstruct NDC coordinates\n    float x = 2.0 * (fragmentCoordinate.x - czm_viewport.x) / czm_viewport.z - 1.0;\n    float y = 2.0 * (fragmentCoordinate.y - czm_viewport.y) / czm_viewport.w - 1.0;\n    float z = (fragmentCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n    vec4 q = vec4(x, y, z, 1.0);\n\n    // Reverse the perspective division to obtain clip coordinates.\n    q /= fragmentCoordinate.w;\n\n    // Reverse the projection transformation to obtain eye coordinates.\n    if (!(czm_inverseProjection == mat4(0.0))) // IE and Edge sometimes do something weird with != between mat4s\n    {\n        q = czm_inverseProjection * q;\n    }\n    else\n    {\n        float top = czm_frustumPlanes.x;\n        float bottom = czm_frustumPlanes.y;\n        float left = czm_frustumPlanes.z;\n        float right = czm_frustumPlanes.w;\n\n        float near = czm_currentFrustum.x;\n        float far = czm_currentFrustum.y;\n\n        q.x = (q.x * (right - left) + left + right) * 0.5;\n        q.y = (q.y * (top - bottom) + bottom + top) * 0.5;\n        q.z = (q.z * (near - far) - near - far) * 0.5;\n        q.w = 1.0;\n    }\n\n    return q;\n}\n\n/**\n * Transforms a position given as window x/y and a depth or a log depth from window to eye coordinates.\n * This function produces more accurate results for window positions with log depth than\n * conventionally unpacking the log depth using czm_reverseLogDepth and using the standard version\n * of czm_windowToEyeCoordinates.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec2} fragmentCoordinateXY The XY position in window coordinates to transform.\n * @param {float} depthOrLogDepth A depth or log depth for the fragment.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @returns {vec4} The transformed position in eye coordinates.\n */\nvec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)\n{\n    // See reverseLogDepth.glsl. This is separate to re-use the pow.\n#ifdef LOG_DEPTH\n    float near = czm_currentFrustum.x;\n    float far = czm_currentFrustum.y;\n    float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;\n    float depthFromNear = pow(2.0, log2Depth) - 1.0;\n    float depthFromCamera = depthFromNear + near;\n    vec4 windowCoord = vec4(fragmentCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);\n    eyeCoordinate.w = 1.0 / depthFromCamera; // Better precision\n    return eyeCoordinate;\n#else\n    vec4 windowCoord = vec4(fragmentCoordinateXY, depthOrLogDepth, 1.0);\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);\n#endif\n    return eyeCoordinate;\n}\n",czm_writeDepthClampedToFarPlane:"// emulated noperspective\n#ifndef LOG_DEPTH\nvarying float v_WindowZ;\n#endif\n/**\n * Clamps a vertex to the far plane by writing the fragments depth.\n * <p>\n * The shader must enable the GL_EXT_frag_depth extension.\n * </p>\n *\n * @name czm_writeDepthClampedToFarPlane\n * @glslFunction\n *\n * @example\n * gl_FragColor = color;\n * czm_writeDepthClampedToFarPlane();\n *\n * @see czm_depthClampFarPlane\n */\nvoid czm_writeDepthClampedToFarPlane()\n{\n#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)\n    gl_FragDepthEXT = min(v_WindowZ * gl_FragCoord.w, 1.0);\n#endif\n}\n",czm_writeLogDepth:"#ifdef LOG_DEPTH\nvarying float v_depthFromNearPlusOne;\n\n#ifdef POLYGON_OFFSET\nuniform vec2 u_polygonOffset;\n#endif\n\n#endif\n\n/**\n * Writes the fragment depth to the logarithmic depth buffer.\n * <p>\n * Use this when the vertex shader does not call {@link czm_vertexlogDepth}, for example, when\n * ray-casting geometry using a full screen quad.\n * </p>\n * @name czm_writeLogDepth\n * @glslFunction\n *\n * @param {float} depth The depth coordinate, where 1.0 is on the near plane and\n *                      depth increases in eye-space units from there\n *\n * @example\n * czm_writeLogDepth((czm_projection * v_positionEyeCoordinates).w + 1.0);\n */\nvoid czm_writeLogDepth(float depth)\n{\n#if (defined(GL_EXT_frag_depth) || defined(WEBGL2)) && defined(LOG_DEPTH)\n    // Discard the vertex if it's not between the near and far planes.\n    // We allow a bit of epsilon on the near plane comparison because a 1.0\n    // from the vertex shader (indicating the vertex should be _on_ the near\n    // plane) will not necessarily come here as exactly 1.0.\n    if (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) {\n        discard;\n    }\n\n#ifdef POLYGON_OFFSET\n    // Polygon offset: m * factor + r * units\n    float factor = u_polygonOffset[0];\n    float units = u_polygonOffset[1];\n\n    // If we can't compute derivatives, just leave out the factor I guess?\n#ifdef GL_OES_standard_derivatives\n    // m = sqrt(dZdX^2 + dZdY^2);\n    float x = dFdx(depth);\n    float y = dFdy(depth);\n    float m = sqrt(x * x + y * y);\n\n    // Apply the factor before computing the log depth.\n    depth += m * factor;\n#endif\n\n#endif\n\n    gl_FragDepthEXT = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;\n\n#ifdef POLYGON_OFFSET\n    // Apply the units after the log depth.\n    gl_FragDepthEXT += czm_epsilon7 * units;\n#endif\n\n#endif\n}\n\n/**\n * Writes the fragment depth to the logarithmic depth buffer.\n * <p>\n * Use this when the vertex shader calls {@link czm_vertexlogDepth}.\n * </p>\n *\n * @name czm_writeLogDepth\n * @glslFunction\n */\nvoid czm_writeLogDepth() {\n#ifdef LOG_DEPTH\n    czm_writeLogDepth(v_depthFromNearPlusOne);\n#endif\n}\n",czm_writeNonPerspective:"/**\n * Transforms a value for non-perspective interpolation by multiplying\n * it by w, the value used in the perspective divide. This function is\n * intended to be called in a vertex shader to compute the value of a\n * `varying` that should not be subject to perspective interpolation.\n * For example, screen-space texture coordinates. The fragment shader\n * must call {@link czm_readNonPerspective} to retrieve the final\n * non-perspective value.\n *\n * @name czm_writeNonPerspective\n * @glslFunction\n *\n * @param {float|vec2|vec3|vec4} value The value to be interpolated without accounting for perspective.\n * @param {float} w The perspective divide value. Usually this is the computed `gl_Position.w`.\n * @returns {float|vec2|vec3|vec4} The transformed value, intended to be stored in a `varying` and read in the\n *          fragment shader with {@link czm_readNonPerspective}.\n */\nfloat czm_writeNonPerspective(float value, float w) {\n    return value * w;\n}\n\nvec2 czm_writeNonPerspective(vec2 value, float w) {\n    return value * w;\n}\n\nvec3 czm_writeNonPerspective(vec3 value, float w) {\n    return value * w;\n}\n\nvec4 czm_writeNonPerspective(vec4 value, float w) {\n    return value * w;\n}\n",czm_XYZToRGB:"/**\n * Converts a CIE Yxy color to RGB.\n * <p>The conversion is described in\n * </p>\n * \n * @name czm_XYZToRGB\n * @glslFunction\n * \n * @param {vec3} Yxy The color in CIE Yxy.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_XYZToRGB(vec3 Yxy)\n{\n    const mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,\n                              -1.5371,  1.8760, -0.2040,\n                              -0.4985,  0.0416,  1.0572);\n    vec3 xyz;\n    xyz.r = Yxy.r * Yxy.g / Yxy.b;\n    xyz.g = Yxy.r;\n    xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;\n    \n    return XYZ2RGB * xyz;\n}\n"};const q={rainDecl:"\n#ifdef HAS_RAIN\nuniform float uAnimationSpeed;\nuniform sampler2D uRippleTexture;\nuniform float uRippleScale;\nuniform float uWindIntensity;\nuniform float uRain;\nuniform float uCameraDepth;\n    \nvoid getTimeInfo(float animationSpeed, out vec2 timeVec)\n{\n\tfloat time = czm_frameNumber * animationSpeed;\n\ttime = floor(30.0 * time);\n\tfloat time_diff = floor(time*0.25);\n\ttime = mod(time, 4.0);\n\ttime_diff = mod(time_diff, 4.0);\n\ttimeVec = vec2(time, time_diff);\n}\n\nvoid getPosInfo(vec4 posMC, out vec2 posMC_frac1, out vec2 posMC_frac2)\n{\n\tfloat ripple_scale = 1.0 / uRippleScale;\n\tvec2 posXY = posMC.xy * ripple_scale;\n\tposMC_frac1 = fract(posXY);\n\tvec2 posStep = vec2(0.5);\n\tposMC_frac2 = fract(posXY + posStep);\n}\n\nfloat getAlpha(vec2 posMC_frac1)\n{\n\tvec2 dist = (posMC_frac1 - vec2(0.5)) * 2.0;\n\tdist = vec2(abs(dist.x), abs(dist.y));\n\tvec2 result = pow(dist, vec2(5.0));\n\treturn result.x + result.y;\n}\n\nvec4 getRippleValue(sampler2D uRippleTexture, vec2 timeVec, vec2 posMC_frac1, vec2 posMC_frac2, float alpha)\n{\n\tvec2 rippleUV_1 = (timeVec + posMC_frac1)*0.25;\n\tvec2 rippleUV_2 = (timeVec + posMC_frac2)*0.25;\n\tvec4 rippleValue_1 = texture2D(uRippleTexture, rippleUV_1.xy);\n\tvec4 rippleValue_2 = texture2D(uRippleTexture, rippleUV_2.xy);\n\treturn mix(rippleValue_1, rippleValue_2, alpha);\n}\n\nvec3 getRippleNormal(vec4 rippleValue, float wind_intensity, float rain, float depthFade)\n{\n\tvec2 rippleValueXY = rippleValue.xy;\n\tvec2 rippleValueZW = rippleValue.zw;\n\tconst vec2 _value = vec2(0.5);\n\tvec2 part_1 = (rippleValueZW - _value) * wind_intensity * 0.13;\n\tvec2 part_2 = (rippleValueXY - _value) * 0.6;\n\tvec2 mergedValue = mix(part_1, part_2, rain) * depthFade;\n\treturn vec3(mergedValue, 1.0);\n}\n\nfloat getNormalAlpha(vec3 normalWS,float wetness)\n{\n\tfloat valueZ = normalWS.z - 0.5;\n\tfloat wet_correction = wetness * clamp(valueZ * 2.5, 0.0, 1.0);\n\treturn pow(wet_correction, 15.0);\n}\n\nvec3 rippleNormalCorrection(vec3 rippleNormal,float normalAlpha)\n{\n\tconst vec3 blueNormal = vec3(0.0, 0.0, 1.0);\n\treturn mix(blueNormal, rippleNormal, normalAlpha);\n}\n\nvec3 rippleGenerator(sampler2D uRippleTexture, float animationSpeed,vec3 normalWS,float wetness)\n{\n\tvec2 timeVec = vec2(1.0);\n\tgetTimeInfo(animationSpeed, timeVec);\n\tvec2 posMC_frac1 = vec2(1.0);\n\tvec2 posMC_frac2 = vec2(1.0);\n\tgetPosInfo(vPositionMC, posMC_frac1, posMC_frac2);\n\tfloat alpha = getAlpha(posMC_frac1);\n\tvec4 rippleValue = getRippleValue(uRippleTexture, timeVec, posMC_frac1, posMC_frac2, alpha);\n\tvec3 rippleNormal = getRippleNormal(rippleValue, uWindIntensity, uRain, uCameraDepth);\n\tfloat normalAlpha = getNormalAlpha(normalWS, wetness);\n\treturn normalize(rippleNormalCorrection(rippleNormal, normalAlpha));\n}\n#endif\n",snowDecl:"\n#ifdef HAS_SNOW\nuniform float uSnowCoverageFactor;\nuniform sampler2D uSnowMaskTexture;\nuniform sampler2D uSnowNormalTexture;\n\nvec3 getSnowMaskValue(sampler2D uSnowMaskTexture, vec2 snowUV)\n{\n\treturn texture2D(uSnowMaskTexture, snowUV).rgb;\n}\n\nfloat getSnowCoverage(float snow_coverage, float max_snow_coverage, vec3 normalWS, float z_mask)\n{\n\tfloat normal_z = normalWS.z;\n\tnormal_z += 1.1 + z_mask;\n\tnormal_z = clamp(normal_z * 0.5, 0.0, 1.0);\n\tfloat final_snow_coverage = clamp(snow_coverage, 0.0, max_snow_coverage);\n\tfinal_snow_coverage = clamp(final_snow_coverage*normal_z, 0.0, 1.0);\n\treturn final_snow_coverage;\n}\n\nfloat getSnowCoverageWithMaskTexture(float finalSnowCoverage, float heightValue, float snow_scatter_value, float snow_scatter_alpha, float tighten_value)\n{\n\tfloat scatter_value = mix(heightValue, snow_scatter_value, snow_scatter_alpha);\n\treturn clamp((tighten_value + 1.0) * finalSnowCoverage - tighten_value * scatter_value, 0.0, 1.0);\n}\n\nfloat getSnowAlpha(vec3 normalWS, float snow_coverage, float z_mask)\n{\n\treturn clamp((normalWS.z + z_mask) * 5.0, 0.0, 1.0) * snow_coverage;\n}\n\nvec3 getFinalBaseColor(vec3 baseColor, vec3 snow_baseColor, float snowAlpha)\n{\n\treturn mix(baseColor, snow_baseColor, snowAlpha);\n}\n\nfloat getFinalRoughness(float roughness, float snow_roughness, float snowAlpha)\n{\n\treturn mix(roughness, snow_roughness, snowAlpha);\n}\n\nvec3 getFinalNormal(vec3 normalWS, vec3 snowNormal, float blendNormalValue, float snow_coverage)\n{\n\tvec3 snowNormal_part2 = vec3(snowNormal.xy - vec2(0.5), 1.0);\n\tfloat normal_alpha = (1.0 - blendNormalValue)* snow_coverage;\n\treturn mix(normalWS, snowNormal_part2, normal_alpha);\n}\n\nvoid snowGenerator(sampler2D uSnowMaskTexture, sampler2D uSnowNormalTexture, vec2 snowUV, float snow_coverage, inout vec3 normalWS, inout vec3 baseColor, inout float roughness)\n{\n\tvec3 snowMaskValue = texture2D(uSnowMaskTexture, snowUV).rgb;\n\tconst float max_snow_coverage = 1.0;\n\tconst float z_mask = 0.0;\n\tfloat snowCoverage = getSnowCoverage(snow_coverage, max_snow_coverage, normalWS, z_mask);\n\tconst float heightValue = 0.5;\n\tfloat snow_scatter_value = snowMaskValue.g;\n\tconst float snow_scatter_alpha = 0.5;\n\tconst float tighten_value = 4.0;\n    snowCoverage = getSnowCoverageWithMaskTexture(snowCoverage, heightValue, snow_scatter_value, snow_scatter_alpha, tighten_value);\n\tfloat snow_alpha = getSnowAlpha(normalWS, snowCoverage, z_mask);\n\tbaseColor = getFinalBaseColor(baseColor, vec3(snowMaskValue.r), snow_alpha);\n\troughness = getFinalRoughness(roughness, snowMaskValue.b, snow_alpha);\n\tvec3 snowNormalValue = texture2D(uSnowNormalTexture, snowUV).rgb;\n\tconst float blendNormalValue = 0.3;\n\tnormalWS = getFinalNormal(normalWS, snowNormalValue, blendNormalValue, snowCoverage);\n}\n\n#endif\n",hemisphereLightDecl:"\n#ifdef HAS_HEMISPHERE_LIGHTS\n\nuniform vec3 uSkyColor[ HEMISPHERE_LIGHTS ];\nuniform vec3 uGroundColor[ HEMISPHERE_LIGHTS ];\nuniform vec3 uHemisphereLightDirectionEC[ HEMISPHERE_LIGHTS ];\n    \nstruct HemisphereLight {\n    vec3 direction;\n    vec3 skyColor;\n    vec3 groundColor;\n};\n\nvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n    float dotNL = dot( geometry.normal, hemiLight.direction );\n    float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n    vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n    return irradiance;\n}\n\n#endif\n",pointLightDecl:"\n#ifdef HAS_POINT_LIGHTS\n\nuniform vec3 uPointLightPositionEC[ POINT_LIGHTS ];\nuniform vec3 uPointLightColor[ POINT_LIGHTS ];\nuniform vec2 uPointLightDistanceAndDecay[ POINT_LIGHTS ];\n\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float distance;\n    float decay;\n};\n\nvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n    vec3 lVector = pointLight.position - geometry.position;\n    directLight.direction = normalize( lVector );\n    float lightDistance = length( lVector );\n    directLight.color = pointLight.color;\n    directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n    directLight.visible = ( directLight.color != vec3( 0.0 ) );\n}\n\n#endif\n",spotLightDecl:"\n#ifdef HAS_SPOT_LIGHTS\n\nuniform vec3 uSpotLightColor[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightPositionEC[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightDirectionEC[ SPOT_LIGHTS ];\nuniform vec4 uSpotLightDistanceDecayCosPenumbra[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightExponent[ SPOT_LIGHTS ];\n    \nstruct SpotLight {\n    vec3 position;\n    vec3 direction;\n    vec3 color;\n    float distance;\n    float decay;\n    float coneCos;\n    float penumbraCos;\n};\n\nvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n    vec3 lVector = spotLight.position - geometry.position;\n    directLight.direction = normalize( lVector );\n    float lightDistance = length( lVector );\n    float angleCos = dot( directLight.direction, spotLight.direction );\n    if ( angleCos > spotLight.coneCos ) {\n        float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n        directLight.color = spotLight.color;\n        directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n        directLight.visible = true;\n    } else {\n        directLight.color = vec3( 0.0 );\n        directLight.visible = false;\n    }\n}\n\n#endif\n",directionLightDecl:"\n#ifdef HAS_DIR_LIGHTS\n\nuniform vec3 uDirectionalLightDirectionEC[ DIR_LIGHTS ];\nuniform vec3 uDirectionalLightColor[ DIR_LIGHTS ];\n    \n#endif\n",lightSourceImpl:"\n\n#ifdef HAS_DIR_LIGHTS\nfor (int i = 0; i < DIR_LIGHTS; i++) {\n    directLight.color = uDirectionalLightColor[i];\n    directLight.direction = uDirectionalLightDirectionEC[i];\n    directLight.visible = true;\n    directPhysical( directLight, geometry, material, reflectedLight );\n}\n#endif\n\n#ifdef HAS_POINT_LIGHTS\nPointLight pointLight;\nfor (int i = 0; i < POINT_LIGHTS; i++) {\n    pointLight.position = uPointLightPositionEC[i];\n    pointLight.color = uPointLightColor[i];\n    pointLight.distance = uPointLightDistanceAndDecay[i].x;\n    pointLight.decay = uPointLightDistanceAndDecay[i].y;\n    getPointDirectLightIrradiance( pointLight, geometry, directLight );\n    if(!directLight.visible) continue;\n    directPhysical( directLight, geometry, material, reflectedLight );\n}\n#endif\n\n#ifdef HAS_SPOT_LIGHTS\nSpotLight spotLight;\nfor (int i = 0; i < SPOT_LIGHTS; i++) {\n    spotLight.position = uSpotLightPositionEC[i];\n    spotLight.color = uSpotLightColor[i];\n    spotLight.direction = uSpotLightDirectionEC[i];\n    spotLight.coneCos = uSpotLightDistanceDecayCosPenumbra[i].z;\n    spotLight.penumbraCos = uSpotLightDistanceDecayCosPenumbra[i].w;\n    getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n    if(!directLight.visible) continue;\n    directPhysical( directLight, geometry, material, reflectedLight );\n}\n#endif\n",brdf:"\n#ifdef BRDF\n#define RECIPROCAL_PI 0.31830988618\n#define M_PI 3.141592653589793\n#define EPSILON 1e-6\n#define CUBEUV_MAX_MIP 8.0\n#define CUBEUV_TEXEL_WIDTH 0.0013020833333333333\n#define CUBEUV_TEXEL_HEIGHT 0.0009765625\n#define saturate(a) clamp( a, 0.0, 1.0 )\nfloat pow2( const in float x ) { return x * x; }\n\nuniform vec4 uBaseColorFactor;\nuniform vec4 uEmissiveFactor;\nuniform float uMetallicFactor;\nuniform float uRoughnessFactor;\nuniform float uAlphaCutoff;\nuniform float uEnvMapIntensity;\nuniform float uCameraReflect;\nstruct IncidentLight {\n    vec3 direction;\n    vec3 color;\n    bool visible;\n};\n\nstruct GeometricContext {\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n};\n\nstruct PhysicalMaterial {\n    vec3\tdiffuseColor;\n    float\troughness;\n    vec3\tspecularColor;\n    float specularF90;\n};\n\nstruct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n};\n\n#ifdef HAS_BASE_TEXTURE\n    uniform sampler2D uBaseTexture;\n#endif\n\n#ifdef HAS_NORMAL_TEXTURE\n    uniform sampler2D uNormalTexture;\n    uniform float uNormalTextureScale;\n#ifdef HAS_ANISOTROPY\n    uniform vec4 uAnisotropy;\n#endif\n#endif\n\n#ifdef HAS_EMISSIVE_TEXTURE\n    uniform sampler2D uEmissionTexture;\n    uniform vec4 uEmissiveUVOffsetAndTiling;\n#endif\n\n#ifdef HAS_MetallicRoughness_TEXTURE\n    uniform sampler2D uMetallicRoughnessTexture;\n#endif\n\n#ifdef HAS_OCCLUSION_TEXTURE\n    uniform sampler2D uOcclusionTexture;\n#endif\n\n#ifdef REFRACTION\n    uniform float uIndexOfRefraction;\n#endif\n\n#ifdef HAS_TRANSMISSION\n    uniform float uTransmissionFactor;\n#endif\n\n#ifdef HAS_WETNESS\n    uniform float uWetnessFactor;\n#endif\n\n#ifdef HAS_VOLUME\n    uniform vec4 uTintColor;\n    uniform vec4 uDiffusionDistance;\n    uniform float uThickness;\n#endif\n\n#ifdef HAS_CLEARCOAT\n    uniform float uClearcoatFactor;\n    uniform float uClearcoatRoughnessFactor;\n#endif\n\n//参考UE4.24实现计算精确光源的衰减\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n    // float d = lightDistance;\n    // float r = cutoffDistance;\n    // float d2 = d * d;\n    // float attenuation = 1.0 / (d2 + 1.0); \n    // float m = saturate(1.0 - pow(d / r, 4.0));\n    // float m2 = m * m;\n    // return attenuation * m2;\n    if ( decayExponent > 0.0 ) {\n        return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\n#include <hemisphereLightDecl>\n#include <directionLightDecl>\n#include <pointLightDecl>\n#include <spotLightDecl>\n#include <snowDecl>\n#include <rainDecl>\n\n#ifdef HAS_ANISOTROPY\nvec3 getAnisotropicBentNormals(const vec3 T, const vec3 B, const vec3 N, const vec3 V, float anisotropy) {\n    vec3 anisotropicFrameDirection = anisotropy >= 0.0 ? B : T;\n    vec3 anisotropicFrameTangent = cross(normalize(anisotropicFrameDirection), V);\n    vec3 anisotropicFrameNormal = cross(anisotropicFrameTangent, anisotropicFrameDirection);\n    vec3 anisotropicNormal = normalize(mix(N, anisotropicFrameNormal, abs(anisotropy)));\n    return anisotropicNormal;\n}\n#endif\n\n#ifdef HAS_VOLUME\nvec3 computeColorAtDistanceInMedia(vec3 color, float distance) {\n    return -log(color) / distance;\n}\nvec3 cocaLambert(vec3 alpha, float distance) {\n    return exp(-alpha * distance);\n}\n#endif\n\n\nvec3 sRGBToLinear(vec3 srgbIn) \n{\n    return pow(srgbIn, vec3(2.2));\n}\n\nvec4 sRGBToLinear(vec4 srgbIn)\n{\n    srgbIn = srgbIn ;\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n    return vec4(linearOut, srgbIn.a);\n}\n\nvec3 LinearTosRGB(vec3 linearIn) \n{\n#ifndef HDR \n    return pow(linearIn, vec3(1.0/2.2));\n#else \n    return linearIn;\n#endif \n}\n\nvec3 lambertianDiffuse(vec3 diffuseColor) \n{\n    return diffuseColor * RECIPROCAL_PI;\n}\n\nvec3 applyTonemapping(vec3 linearIn) \n{\n    vec3 color = linearIn * czm_toneMappingExposure;\n    return czm_acesTonemapping(color);\n}\n\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n    float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n    return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\n\nfloat GeometrySchlickGGX(float roughness, float NoV)\n{\n    float k = pow(roughness + 1.0, 2.0) / 8.0;\n    return NoV / (NoV * (1.0 - k) + k);\n}\n\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n    float a2 = pow2( alpha );\n    float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n    return RECIPROCAL_PI * a2 / pow2( denom );\n}\n\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n    float alpha = roughness * roughness;\n    vec3 halfDir = normalize( lightDir + viewDir );\n    float dotNL = clamp( dot( normal, lightDir ), 0.001, 1.0 );\n    float dotNV = abs( dot( normal, viewDir ) ) + 0.001;\n    float dotNH = saturate( dot( normal, halfDir ) );\n    float dotLH = saturate( dot( lightDir, halfDir ) );\n    float dotVH = saturate( dot( viewDir, halfDir ) );\n    vec3 F = F_Schlick( f0, f90, dotVH );\n    float G = GeometrySchlickGGX(alpha, dotNV) * GeometrySchlickGGX(alpha, dotNL);\n    float D = D_GGX( alpha, dotNH );\n    return F * ( G * D ) / (4.0 * dotNL * dotNV);\n}\n\nvoid directPhysical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n    vec3 irradiance = dotNL * directLight.color;\n    reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n    reflectedLight.directDiffuse += irradiance * lambertianDiffuse( material.diffuseColor );\n}\n\n#ifdef HAS_NORMAL_TEXTURE\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv, vec3 mapN) {\n    float fNormalLength = length(mapN);\n    if(fNormalLength < 0.5) {\n        return surf_norm;\n    }\n    mapN = mapN * 2.0 - 1.0;\n    vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n    vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n    vec2 st0 = dFdx( uv.st );\n    vec2 st1 = dFdy( uv.st );\n    float scale = sign( st1.t * st0.s - st0.t * st1.s );\n    vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n    vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n    vec3 N = normalize( surf_norm );\n    mat3 tsn = mat3( S, T, N );\n    mapN.xy *= uNormalTextureScale;\n    mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n    return normalize( tsn * mapN );\n}\n#endif\n\n#include <cubeUV_reflection>\n\nvec3 inverseTransformDirection( in vec3 dir ) {\n    mat3 fixedToENU = mat3(czm_modelView[0][0], czm_modelView[1][0], czm_modelView[2][0], czm_modelView[0][1], czm_modelView[1][1], czm_modelView[2][1], czm_modelView[0][2], czm_modelView[1][2], czm_modelView[2][2]);\n    const mat3 yUpToZUp = mat3(1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0);\n    return normalize( yUpToZUp * fixedToENU * dir );\n}\n\nvoid indirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n    reflectedLight.indirectDiffuse += irradiance * lambertianDiffuse( material.diffuseColor );\n}\n\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n    float dotNV = saturate( dot( normal, viewDir ) );\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n    vec4 r = roughness * c0 + c1;\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n    vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n    return fab;\n}\n\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n    vec2 fab = DFGApprox( normal, viewDir, roughness );\n    vec3 Fr = specularColor;\n    vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n    float Ess = fab.x + fab.y;\n    float Ems = 1.0 - Ess;\n    vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\n    vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n    singleScatter += FssEss;\n    multiScatter += Fms * Ems;\n}\n\nvoid indirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n    vec3 singleScattering = vec3( 0.0 );\n    vec3 multiScattering = vec3( 0.0 );\n    vec3 cosineWeightedIrradiance = irradiance;\n    computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n    vec3 totalScattering = singleScattering + multiScattering;\n    vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n    reflectedLight.indirectSpecular += radiance * singleScattering;\n    reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n    reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n\nvec3 getIBLIrradiance( const in vec3 normal ) {\n    vec3 worldNormal = inverseTransformDirection( normal );\n    vec4 envMapColor = textureCubeUV( czm_hdrEnvMap, worldNormal, 1.0 );\n    return envMapColor.rgb;\n}\n\nvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n    vec3 reflectVec = reflect( - viewDir, normal );\n    reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n    reflectVec = inverseTransformDirection( reflectVec );\n    vec4 envMapColor = textureCubeUV( czm_hdrEnvMap, reflectVec, roughness );\n    return envMapColor.rgb;\n}\n\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n    return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n\nuniform float uPbrParTextureWidth;\nvoid calculateMipLevel(in vec2 inTexCoord, in vec2 vecTile, in float fMaxMip, inout float mipLevel)\n{\n\tvec2 dx = dFdx(inTexCoord * vecTile.x);\n\tvec2 dy = dFdy(inTexCoord * vecTile.y);\n\tfloat dotX = dot(dx, dx);\n\tfloat dotY = dot(dy, dy);\n\tfloat dMax = max(dotX, dotY);\n\tfloat dMin = min(dotX, dotY);\n\tfloat offset = (dMax - dMin) / (dMax + dMin);\n\toffset = clamp(offset, 0.0, 1.0);\n\tfloat d = dMax * (1.0 - offset) + dMin * offset;\n\tmipLevel = 0.5 * log2(d);\n\tmipLevel = clamp(mipLevel, 0.0, fMaxMip - 1.62);\n}\n\nvec3 getTexcoordAndMipmapLevel(vec2 uv, vec4 texMatrix, float texCoordZ) {\n    vec2 translate = texMatrix.xy;\n    float textureWidth = texMatrix.z * uPbrParTextureWidth;\n    float scale = texMatrix.z;\n    float maxMipmapLevel = texMatrix.w;\n    float mipLevel = 0.0;\n        calculateMipLevel(uv, vec2(textureWidth), maxMipmapLevel, mipLevel);\n    vec2 texCoord;\n    if(texCoordZ < -9000.0)\n    {\n        texCoord = vec2(uv.x, uv.y);\n    }\n    else\n    {\n        texCoord = fract(uv);\n        float offset = pow(2.0, mipLevel) / textureWidth;\n        texCoord = clamp(texCoord, offset, 1.0 - offset);\n        texCoord.x = (texCoord.x + translate.x) * scale;\n        texCoord.y = (texCoord.y + translate.y) * scale;\n    }\n    \n    return vec3(texCoord.xy, mipLevel);\n}\n\nvec4 brdf(in vec4 baseColorWithAlpha, vec2 texCoord, vec2 oriTexCoord, vec3 posEC, vec3 posMC, vec3 vertexNormalEC, vec4 sunLightColor, float sunLightON) {\n    vec2 uv = oriTexCoord;\n    float mipmapLevel = 0.0;\n#ifdef USE_BatchPBR\n    vec3 uvAndMiplevel = getTexcoordAndMipmapLevel(oriTexCoord, vTexMatrix, vTexCoordZ.x);\n    uv = uvAndMiplevel.xy;\n    mipmapLevel = uvAndMiplevel.z;\n#endif\n#ifndef USE_BatchPBR\n    baseColorWithAlpha = baseColorWithAlpha * uBaseColorFactor;\n#endif\n#ifdef BaseColorReplace\n    baseColorWithAlpha = uBaseColorFactor;\n#endif\n    float faceDirection = (gl_FrontFacing ? 1.0 : - 1.0) * uCameraReflect;\n    vec3 ng = normalize(vertexNormalEC);\n    #ifndef HAS_NORMAL\n        ng = normalize(czm_normal * czm_computeNormal(posMC.xyz));\n    #else\n        ng = ng * faceDirection;\n    #endif\n    \n#ifdef HAS_BASE_TEXTURE\n    #ifdef USE_BatchPBR\n        baseColorWithAlpha *= sRGBToLinear(texture2DLodEXT(uBaseTexture, uv * uTexUVOffset.zw + uTexUVOffset.xy, mipmapLevel));\n    #else\n        baseColorWithAlpha = sRGBToLinear(texture2D(uBaseTexture, oriTexCoord * uTexUVOffset.zw + uTexUVOffset.xy)) * uBaseColorFactor * vColor;\n    #endif\n#endif\n#ifdef HAS_NORMAL_TEXTURE\n    #ifdef USE_BatchPBR\n        vec3 mapN = texture2DLodEXT( uNormalTexture, uv, mipmapLevel).xyz;\n    #else\n        vec3 mapN = texture2D( uNormalTexture, uv).xyz;\n    #endif\n    vec3 n = perturbNormal2Arb(posEC, ng, oriTexCoord, mapN);\n#ifdef HAS_ANISOTROPY\n    float anisotropy = uAnisotropy.b;\n    vec3 anisotropyDirection = vec3(uAnisotropy.xy, 0.0);\n    vec3 anisotropicTangent = normalize(tbn * anisotropyDirection);\n    vec3 anisotropicBitangent = normalize(cross(tbn[2], anisotropicTangent));\n    n = getAnisotropicBentNormals(anisotropicTangent, anisotropicBitangent, n, v, anisotropy);\n#endif\n#else\n    vec3 n = ng;\n#endif\n#ifdef HAS_WETNESS\n    mat3 fixedToENU_wetness = mat3(czm_modelView[0][0], czm_modelView[1][0], czm_modelView[2][0], czm_modelView[0][1], czm_modelView[1][1], czm_modelView[2][1], czm_modelView[0][2], czm_modelView[1][2], czm_modelView[2][2]);\n    vec3 normalWS_wetness = normalize(fixedToENU_wetness * n);\n#endif\n#ifdef HAS_RAIN\n    n = rippleGenerator(uRippleTexture,uAnimationSpeed,normalWS_wetness,uWetnessFactor);\n#endif\n    vec3 baseColor = baseColorWithAlpha.rgb;\n    float roughness = uRoughnessFactor;\n    float metalness = uMetallicFactor;\n    vec4 emissiveFactor = uEmissiveFactor;\n    vec2 emissiveTexCoord = texCoord.xy;\n#ifdef PBR_THEME\n    int pbrIndex = int(vPBRIndex);\n    if(vPBRIndex < 0.0)\n    {\n        return baseColorWithAlpha;\n    }\n    mat4 pbrPar = mat4(0.0);\n    for(int i = 0;i < NUM_PBR_MATERIALS;i++)\n    {\n        if(i == pbrIndex)\n        {\n            pbrPar = uPBRMaterials[i];\n            break;\n        }\n    }\n    roughness = clamp(pbrPar[0][0], 0.04, 1.0);\n    metalness = clamp(pbrPar[0][1], 0.0, 1.0);\n    baseColor = (baseColorWithAlpha / uBaseColorFactor * vec4(pbrPar[0][2], pbrPar[0][3], pbrPar[1][0], pbrPar[1][1])).rgb;\n#endif\n#ifdef USE_BatchPBR\n    metalness = vMetallicRoughness.x;\n    roughness = vMetallicRoughness.y;\n    emissiveFactor = vEmissiveFactor;\n    emissiveTexCoord = texCoord.xy;\n#endif\n    metalness = clamp(metalness, 0.0, 1.0);\n    roughness = clamp(roughness, 0.0, 1.0);\n    \n#ifdef HAS_MetallicRoughness_TEXTURE\n    #ifdef USE_BatchPBR\n        vec3 metallicRoughness = texture2DLodEXT(uMetallicRoughnessTexture, uv, mipmapLevel).rgb;\n    #else\n        vec3 metallicRoughness = texture2D(uMetallicRoughnessTexture, oriTexCoord).rgb;\n    #endif\n    metalness = clamp(metalness * metallicRoughness.r, 0.0, 1.0);\n    roughness = clamp(roughness * metallicRoughness.g, 0.04, 1.0);\n#ifdef HAS_WETNESS\n    float fWetness = clamp(uWetnessFactor,0.0,1.0);\n    float fWetness_correction = pow(4.0*fWetness,2.0);\n    fWetness_correction = clamp(fWetness_correction,clamp(fWetness,0.0,0.9),1.0);\n    float fWerness_normalized = fWetness_correction * clamp(normalWS_wetness.z + 0.85,0.0,1.0);\n    baseColor = mix(baseColor,baseColor*0.7,fWerness_normalized);\n    roughness = mix(roughness,0.05,fWerness_normalized);\n#endif\n#ifdef HAS_SNOW\n    mat3 fixedToENU_snow = mat3(czm_modelView[0][0], czm_modelView[1][0], czm_modelView[2][0], czm_modelView[0][1], czm_modelView[1][1], czm_modelView[2][1], czm_modelView[0][2], czm_modelView[1][2], czm_modelView[2][2]);\n    vec3 normalWS_snow = normalize(fixedToENU_snow * n);\n    snowGenerator(uSnowMaskTexture,uSnowNormalTexture, oriTexCoord,uSnowCoverageFactor,normalWS_snow,baseColor,roughness);\n#endif\n#endif\n\n    vec3 lightColorHdr = vec3(2.0) * uSunLightON;   // 太阳光\n    vec3 l = normalize(czm_lightDirectionEC);\n    vec3 v = -normalize(posEC);\n    vec3 h = normalize(v + l);\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\n    vec3 specularColor = mix(f0, baseColor, metalness);\n    \n    float alpha = roughness * roughness;\n    float dotNL = clamp( dot( n, l ), 0.001, 1.0 );\n    float dotNV = abs( dot( n, v ) ) + 0.001;\n    float dotNH = saturate( dot( n, h ) );\n    float dotLH = saturate( dot( l, h ) );\n    float dotVH = saturate( dot( v, h ) );\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n    float f90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 F = F_Schlick( specularColor, f90, dotVH );\n    float G = GeometrySchlickGGX(alpha, dotNV) * GeometrySchlickGGX(alpha, dotNL);\n    float D = D_GGX( alpha, dotNH );\n    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n    vec3 specularContribution = F * G * D / (4.0 * dotNL * dotNV);\n    \n    vec3 geometryNormal = ng;\n    PhysicalMaterial material;\n    material.diffuseColor = diffuseColor;\n    vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\n    float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n    material.roughness = max( roughness, 0.0525 );\n    material.roughness += geometryRoughness;\n    material.roughness = min( material.roughness, 1.0 );\n    material.specularColor = specularColor;\n    material.specularF90 = 1.0;\n    \n    GeometricContext geometry;\n    geometry.position = posEC;\n    geometry.normal = n;\n    geometry.viewDir = v;\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    reflectedLight.directDiffuse += dotNL * lightColorHdr * diffuseContribution;\n    reflectedLight.directSpecular += dotNL * lightColorHdr * specularContribution;\n    \n    IncidentLight directLight; \n    #include <lightSourceImpl>\n    \n    vec3 irradiance = vec3(0.0);\n    vec3 radiance = vec3(0.0);\n  \n#ifdef HAS_HEMISPHERE_LIGHTS\n    HemisphereLight hemiLight;\n    hemiLight.skyColor = uSkyColor[0];\n    hemiLight.groundColor = uGroundColor[0];\n    hemiLight.direction = normalize(czm_normal * vec3(0.0, 0.0, 1.0));\n    irradiance += getHemisphereLightIrradiance( hemiLight, geometry );\n#endif\n\n#ifdef IBL\n\n#ifdef KtxEnvMap\n    mat3 fixedToENU = mat3(czm_modelView[0][0], czm_modelView[1][0], czm_modelView[2][0], czm_modelView[0][1], czm_modelView[1][1], czm_modelView[2][1], czm_modelView[0][2], czm_modelView[1][2], czm_modelView[2][2]);\n    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0);\n    vec3 cubeDir = normalize( yUpToZUp * fixedToENU * reflect(-v, n) );\n    vec3 worldNormal = normalize( yUpToZUp * fixedToENU * n );\n    irradiance += czm_sphericalHarmonics(worldNormal, czm_sphericalHarmonicCoefficients);\n    radiance += czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);\n#else\n    irradiance += getIBLIrradiance( geometry.normal );\n    radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n#endif\n    \n#else\n    vec3 positionWC = vec3(czm_inverseView * vec4(posEC, 1.0));\n    vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\n    float vertexRadius = length(positionWC);\n    float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);\n    float reflectionDotNadir = dot(r, normalize(positionWC));\n    r.x = -r.x;\n    r = -normalize(czm_temeToPseudoFixed * r);\n    r.x = -r.x;\n    float inverseRoughness = 1.04 - roughness;\n    inverseRoughness *= inverseRoughness;\n    vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\n    float atmosphereHeight = 0.05;\n    float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\n    float blendRegionOffset = roughness * -1.0;\n    float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\n    float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\n    float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\n    float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\n    vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\n    vec3 nadirColor = belowHorizonColor * 0.5;\n    vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\n    vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\n    vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\n    vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\n    float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\n    float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\n    vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\n    float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\n    vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\n    specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\n    specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\n    \n    float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * czm_sunDirectionEC), normalize(positionWC * -1.0)), 0.001, 1.0);\n    float S = acos(LdotZenith);\n    float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\n    float sunNdotL = clamp(dot(n, czm_sunDirectionEC), 0.001, 1.0);\n    float gamma = acos(sunNdotL);\n    float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(sunNdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\n    float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\n    float luminance = 0.2 * (numerator / denominator);\n    irradiance += diffuseIrradiance * luminance;\n    radiance += specularIrradiance * luminance;\n#endif\n    irradiance *= uEnvMapIntensity;\n    radiance *= uEnvMapIntensity;\n\n    indirectSpecular_Physical(radiance, irradiance, geometry, material, reflectedLight);\n\n#ifdef HAS_OCCLUSION_TEXTURE\n    #ifdef USE_BatchPBR\n        float ambientOcclusion = texture2DLodEXT(uOcclusionTexture, uv, mipmapLevel).r;\n    #else\n        float ambientOcclusion = texture2D(uOcclusionTexture, oriTexCoord.xy).r;\n    #endif\n    reflectedLight.indirectDiffuse *= ambientOcclusion;\n#ifdef IBL\n    reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n#endif\n#endif\n\nvec3 color = reflectedLight.directDiffuse + reflectedLight.directSpecular + reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;\n\n#ifdef HAS_EMISSIVE_TEXTURE\n    emissiveTexCoord = emissiveTexCoord * uEmissiveUVOffsetAndTiling.zw + uEmissiveUVOffsetAndTiling.xy;\n    vec3 emissive = texture2D(uEmissionTexture, emissiveTexCoord).rgb;\n    emissive *= emissiveFactor.rgb;\n    color += emissive;\n#else\n    color += emissiveFactor.rgb;\n#endif\n\n    color = applyTonemapping(color);\n    color = LinearTosRGB(color);\n    \n#ifdef MASK\n    if (baseColorWithAlpha.a < uAlphaCutoff)\n    {\n        discard;\n    }\n    return vec4(color.rgb, 1.0);\n#endif\n    return vec4(color.rgb, baseColorWithAlpha.a);\n}\n#endif\n",executeServerExcavationDecl:"\n#ifdef SERVEREXCAVATION\nuniform sampler2D uServerExcavationTexture;\nuniform float uServerExcavationMode;\nuniform vec4 uServerExcavationRect;\nvarying vec4 vServerExcavationVertexPos;\nvec2 CalculateServerExcavationPolyTexCoord(vec4 vertexPos, vec4 rectPos, out float ptInRect)\n{\n    vec2 vecRatio = vec2(rectPos.z - rectPos.x, rectPos.w - rectPos.y);\n    vec2 texCoord = vec2(vertexPos.x - rectPos.x, vertexPos.y - rectPos.y);\n    texCoord.x = texCoord.x / vecRatio.x;\n    texCoord.y = texCoord.y / vecRatio.y;\n    ptInRect = step(0.0, texCoord.x) * step(0.0, texCoord.y) * step(0.0, 1.0 - texCoord.x) * step(0.0, 1.0 - texCoord.y);\n    texCoord = clamp(texCoord, vec2(0.0), vec2(1.0));\n    return texCoord;\n}\nbool executeServerExcavation()\n{\n    float hasExcavation = 1.0;\n    vec2 vecExcavationTexCoord = CalculateServerExcavationPolyTexCoord(vServerExcavationVertexPos, uServerExcavationRect, hasExcavation);\n    bool excavationInside = (uServerExcavationMode < 0.5);\n    if(hasExcavation < 0.1)\n    {\n        return !excavationInside;\n    }\n    if(excavationInside)\n    {\n        return texture2D(uServerExcavationTexture, vecExcavationTexCoord.xy).r > 0.5;\n    }\n    else\n    {\n        return texture2D(uServerExcavationTexture, vecExcavationTexCoord.xy).r < 0.5;\n    }\n}\n#endif",cubeUV_reflection:"\n    #define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\t#ifdef WEBGL2\n\t\t#define texture2DGradEXT textureGrad \n\t#endif\n\n\t// These shader functions convert between the UV coordinates of a single face of\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t// sampling a textureCube (not generally normalized ).\n\n\tfloat getFace( vec3 direction ) {\n\n\t\tvec3 absDirection = abs( direction );\n\n\t\tfloat face = - 1.0;\n\n\t\tif ( absDirection.x > absDirection.z ) {\n\n\t\t\tif ( absDirection.x > absDirection.y )\n\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t} else {\n\n\t\t\tif ( absDirection.z > absDirection.y )\n\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t}\n\n\t\treturn face;\n\n\t}\n\n\t// RH coordinate system; PMREM face-indexing convention\n\tvec2 getUV( vec3 direction, float face ) {\n\n\t\tvec2 uv;\n\n\t\tif ( face == 0.0 ) {\n\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n\t\t} else if ( face == 1.0 ) {\n\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n\t\t} else if ( face == 2.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n\t\t} else if ( face == 3.0 ) {\n\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n\t\t} else if ( face == 4.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n\t\t} else {\n\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n\t\t}\n\n\t\treturn 0.5 * ( uv + 1.0 );\n\n\t}\n\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n\t\tfloat face = getFace( direction );\n\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\n\t\tfloat faceSize = exp2( mipInt );\n\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\n\t\tif ( face > 2.0 ) {\n\n\t\t\tuv.y += faceSize;\n\n\t\t\tface -= 3.0;\n\n\t\t}\n\n\t\tuv.x += face * faceSize;\n\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\n\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering\n\n\t}\n\n\t// These defines must match with PMREMGenerator\n\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\n\tfloat roughnessToMip( float roughness ) {\n\n\t\tfloat mip = 0.0;\n\n\t\tif ( roughness >= cubeUV_r1 ) {\n\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\n\t\t} else {\n\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n\t\t}\n\n\t\treturn mip;\n\n\t}\n\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\n\t\tfloat mipF = fract( mip );\n\n\t\tfloat mipInt = floor( mip );\n\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\n\t\tif ( mipF == 0.0 ) {\n\n\t\t\treturn vec4( color0, 1.0 );\n\n\t\t} else {\n\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\n\t\t}\n\n\t}\n"};function X(e){return(e=e.replace(/\/\/.*/g,"")).replace(/\/\*\*[\s\S]*?\*\//gm,(function(e){for(var n=e.match(/\n/gm).length,t="",o=0;o<n;++o)t+="\n";return t}))}function Y(e,n,t){for(var o,i=0;i<t.length;++i)t[i].name===e&&(o=t[i]);return a.e(o)||(o={name:e,glslSource:n=X(n),dependsOn:[],requiredBy:[],evaluated:!1},t.push(o)),o}function j(e,n){if(!e.evaluated){e.evaluated=!0;var t=e.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g);a.e(t)&&null!==t&&(t=t.filter((function(e,n){return t.indexOf(e)===n})),t.forEach((function(t){if(t!==e.name&&J._czmBuiltinsAndUniforms.hasOwnProperty(t)){var o=Y(t,J._czmBuiltinsAndUniforms[t],n);e.dependsOn.push(o),o.requiredBy.push(e),j(o,n)}})))}}function Z(e,n,t){var o=[],i=Y("main",n,o);j(i,o),function(e){for(var n=[],t=[];e.length>0;){var o=e.pop();t.push(o),0===o.requiredBy.length&&n.push(o)}for(;n.length>0;){var i=n.shift();e.push(i);for(var a=0;a<i.dependsOn.length;++a){var l=i.dependsOn[a],c=l.requiredBy.indexOf(i);l.requiredBy.splice(c,1),0===l.requiredBy.length&&n.push(l)}}for(var s=[],u=0;u<t.length;++u)0!==t[u].requiredBy.length&&s.push(t[u]);if(0!==s.length){for(var m="A circular dependency was found in the following built-in functions/structs/constants: \n",f=0;f<s.length;++f)m=m+s[f].name+"\n";throw new r.t(m)}}(o);for(var a="",l=o.length-1;l>=0;--l)K(t,e)&&(o[l].glslSource=F.removeUnuseMacroCode(t,e,o[l].glslSource)),a=a+o[l].glslSource+"\n";return a.replace(i.glslSource,"")}function K(e,n){return!(!a.e(e)||!a.e(n)||!e.shaderPreprocess)}function $(e){return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm,(function(e,n){var t=q[n];if(void 0===t)throw new Error("Can not resolve #include <"+n+">");return $(t)}))}function Q(e,n,t){var o,i,l,c="",s=e.sources;if(a.e(s))for(o=0,i=s.length;o<i;++o)c+="\n#line 0\n"+s[o];c=(c=X(c)).replace(/#version\s+(.*?)\n/gm,(function(e,n){if(a.e(l)&&l!==n)throw new r.t("inconsistent versions found: "+l+" and "+n);return l=n,"\n"}));var u=[];c=c.replace(/#extension.*\n/gm,(function(e){return u.push(e),"\n"})),c=c.replace(/precision\s(lowp|mediump|highp)\s(float|int);/,"");var m=e.pickColorQualifier;a.e(m)&&(c=J.createPickFragmentShaderSource(c,m));var f="";a.e(l)&&(f="#version "+l+"\n");var d=u.length;for(o=0;o<d;o++)f+=u[o];n&&(f+="#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n");var p=e.defines;if(a.e(p))for(o=0,i=p.length;o<i;++o){var h=p[o];0!==h.length&&(f+="#define "+h+"\n")}if(t.webgl2&&(f+="#define OUTPUT_DECLARATION\n\n",f+="#define WEBGL2\n\n",f+="#define texture2DLodEXT textureLod\n\n"),c=$(c),t.textureFloatLinear&&(f+="#define OES_texture_float_linear\n\n"),K(t,e)&&(c=F.removeUnuseMacroCode(t,e,c)),e.includeBuiltIns){var v=Z(e,c,t);for(u.length=0,v=v.replace(/#extension.*\n/gm,(function(e){return u.push(e),"\n"})),d=u.length,o=0;o<d;o++)f=u[o]+f;f+=v}return f+="\n#line 0\n",f+=c,t.webgl2&&(f=D(f,n)),f}function J(e){var n=(e=a.u(e,a.u.EMPTY_OBJECT)).pickColorQualifier;if(a.e(n)&&"uniform"!==n&&"varying"!==n)throw new r.t("options.pickColorQualifier must be 'uniform' or 'varying'.");this.defines=a.e(e.defines)?e.defines.slice(0):[],this.sources=a.e(e.sources)?e.sources.slice(0):[],this.pickColorQualifier=n,this.includeBuiltIns=a.u(e.includeBuiltIns,!0),this.name=a.e(e.name)?e.name:void 0}for(var ee in J.prototype.clone=function(){return new J({sources:this.sources,defines:this.defines,name:this.name,pickColorQualifier:this.pickColorQualifier,includeBuiltIns:this.includeBuiltIns})},J.replaceMain=function(e,n){return n="void "+n+"()",e.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g,n)},J.prototype.getCacheKey=function(e){const n=this.defines.slice().sort().join(","),t=this.pickColorQualifier||"";this.includeBuiltIns;return`${n}:${t}:${this.sources.join("\n")}`},J.prototype.createCombinedVertexShader=function(e){return Q(this,!1,e)},J.prototype.createCombinedFragmentShader=function(e){return Q(this,!0,e)},J._czmBuiltinsAndUniforms={},W)W.hasOwnProperty(ee)&&(J._czmBuiltinsAndUniforms[ee]=W[ee]);for(var ne in O)if(O.hasOwnProperty(ne)){var te=O[ne];"function"==typeof te.getDeclaration&&(J._czmBuiltinsAndUniforms[ne]=te.getDeclaration(ne))}J.createPickVertexShaderSource=function(e){return J.replaceMain(e,"czm_old_main")+"\nattribute vec4 pickColor; \nvarying vec4 czm_pickColor; \nvoid main() \n{ \n    czm_old_main(); \n    czm_pickColor = pickColor; \n}"},J.createPickFragmentShaderSource=function(e,n){return J.replaceMain(e,"czm_old_main")+"\n"+(n+" vec4 czm_pickColor; \nvoid main() \n{ \n    czm_old_main(); \n    if (gl_FragColor.a == 0.0) { \n       discard; \n    } \n    gl_FragColor = czm_pickColor; \n}")},J.findVarying=function(e,n){for(var t=e.sources,o=n.length,i=0;i<o;++i)for(var r=n[i],a=t.length,l=0;l<a;++l)if(-1!==t[l].indexOf(r))return r};var oe=["v_normalEC","v_normal","aNormal"];J.findNormalVarying=function(e){return J.findVarying(e,oe)};var ie=["v_positionEC"];function re(e,n,t,o){switch(n.type){case e.FLOAT:return new ae(e,n,t,o);case e.FLOAT_VEC2:return new le(e,n,t,o);case e.FLOAT_VEC3:return new ce(e,n,t,o);case e.FLOAT_VEC4:return new se(e,n,t,o);case e.SAMPLER_2D:case e.SAMPLER_CUBE:return new ue(e,n,t,o);case e.SAMPLER_2D_ARRAY:return new me(e,n,t,o);case e.INT:case e.BOOL:return new fe(e,n,t,o);case e.INT_VEC2:case e.BOOL_VEC2:return new de(e,n,t,o);case e.INT_VEC3:case e.BOOL_VEC3:return new pe(e,n,t,o);case e.INT_VEC4:case e.BOOL_VEC4:return new he(e,n,t,o);case e.FLOAT_MAT2:return new ge(e,n,t,o);case e.FLOAT_MAT3:return new xe(e,n,t,o);case e.FLOAT_MAT4:return new ye(e,n,t,o);default:throw new _.t("Unrecognized uniform type: "+n.type+' for uniform "'+t+'".')}}function ae(e,n,t,o){this.name=t,this.value=void 0,this._value=0,this._gl=e,this._location=o}function le(e,n,o,i){this.name=o,this.value=void 0,this._value=new t.o,this._gl=e,this._location=i}function ce(e,n,t,o){this.name=t,this.value=void 0,this._value=void 0,this._gl=e,this._location=o}function se(e,n,t,o){this.name=t,this.value=void 0,this._value=void 0,this._gl=e,this._location=o}function ue(e,n,t,o){this.name=t,this.value=void 0,this._gl=e,this._location=o,this.textureUnitIndex=void 0}function me(e,n,t,o){this.name=t,this.value=void 0,this._gl=e,this._location=o,this.textureUnitIndex=void 0,this.lastBindTextureID=void 0}function fe(e,n,t,o){this.name=t,this.value=void 0,this._value=0,this._gl=e,this._location=o}function de(e,n,o,i){this.name=o,this.value=void 0,this._value=new t.o,this._gl=e,this._location=i}function pe(e,n,t,i){this.name=t,this.value=void 0,this._value=new o.t,this._gl=e,this._location=i}function he(e,n,t,o){this.name=t,this.value=void 0,this._value=new i.e,this._gl=e,this._location=o}J.findPositionVarying=function(e){return J.findVarying(e,ie)},ae.prototype.set=function(){this.value!==this._value&&(this._value=this.value,this._gl.uniform1f(this._location,this.value))},le.prototype.set=function(){var e=this.value;t.o.equals(e,this._value)||(t.o.clone(e,this._value),this._gl.uniform2f(this._location,e.x,e.y))},ce.prototype.set=function(){var e=this.value;if(a.e(e.red))T.e.equals(e,this._value)||(this._value=T.e.clone(e,this._value),this._gl.uniform3f(this._location,e.red,e.green,e.blue));else{if(!a.e(e.x))throw new r.t('Invalid vec3 value for uniform "'+this.name+'".');o.t.equals(e,this._value)||(this._value=o.t.clone(e,this._value),this._gl.uniform3f(this._location,e.x,e.y,e.z))}},se.prototype.set=function(){var e=this.value;if(a.e(e.red))T.e.equals(e,this._value)||(this._value=T.e.clone(e,this._value),this._gl.uniform4f(this._location,e.red,e.green,e.blue,e.alpha));else{if(!a.e(e.x))throw new r.t('Invalid vec4 value for uniform "'+this.name+'".');i.e.equals(e,this._value)||(this._value=i.e.clone(e,this._value),this._gl.uniform4f(this._location,e.x,e.y,e.z,e.w))}},ue.prototype.set=function(){var e=this._gl;e.activeTexture(e.TEXTURE0+this.textureUnitIndex);var n=this.value;e.bindTexture(n._target,n._texture)},ue.prototype._setSampler=function(e){return this.textureUnitIndex=e,this._gl.uniform1i(this._location,e),e+1},me.prototype.set=function(){var e=this.value;if(!a.e(e.id)||this.lastBindTextureID!==e.id){var n=this._gl;n.activeTexture(n.TEXTURE0+this.textureUnitIndex),n.bindTexture(e._target,e._texture),this.lastBindTextureID=e.id}},me.prototype._setSampler=function(e){return this.textureUnitIndex=e,this._gl.uniform1i(this._location,e),e+1},fe.prototype.set=function(){this.value!==this._value&&(this._value=this.value,this._gl.uniform1i(this._location,this.value))},de.prototype.set=function(){var e=this.value;t.o.equals(e,this._value)||(t.o.clone(e,this._value),this._gl.uniform2i(this._location,e.x,e.y))},pe.prototype.set=function(){var e=this.value;o.t.equals(e,this._value)||(o.t.clone(e,this._value),this._gl.uniform3i(this._location,e.x,e.y,e.z))},he.prototype.set=function(){var e=this.value;i.e.equals(e,this._value)||(i.e.clone(e,this._value),this._gl.uniform4i(this._location,e.x,e.y,e.z,e.w))};var ve=new Float32Array(4);function ge(e,n,t,o){this.name=t,this.value=void 0,this._value=new g.f,this._gl=e,this._location=o}ge.prototype.set=function(){if(!g.f.equalsArray(this.value,this._value,0)){g.f.clone(this.value,this._value);var e=g.f.toArray(this.value,ve);this._gl.uniformMatrix2fv(this._location,!1,e)}};var _e=new Float32Array(9);function xe(e,n,t,o){this.name=t,this.value=void 0,this._value=new m.p,this._gl=e,this._location=o}xe.prototype.set=function(){if(!m.p.equalsArray(this.value,this._value,0)){m.p.clone(this.value,this._value);var e=m.p.toArray(this.value,_e);this._gl.uniformMatrix3fv(this._location,!1,e)}};var Ce=new Float32Array(16);function ye(e,n,t,o){this.name=t,this.value=void 0,this._value=new m.y,this._gl=e,this._location=o}function Te(e,n,t,o){switch(n.type){case e.FLOAT:return new ze(e,n,t,o);case e.FLOAT_VEC2:return new be(e,n,t,o);case e.FLOAT_VEC3:return new we(e,n,t,o);case e.FLOAT_VEC4:return new Se(e,n,t,o);case e.SAMPLER_2D:case e.SAMPLER_CUBE:return new Le(e,n,t,o);case e.INT:case e.BOOL:return new Ee(e,n,t,o);case e.INT_VEC2:case e.BOOL_VEC2:return new De(e,n,t,o);case e.INT_VEC3:case e.BOOL_VEC3:return new Ae(e,n,t,o);case e.INT_VEC4:case e.BOOL_VEC4:return new Ie(e,n,t,o);case e.FLOAT_MAT2:return new Ve(e,n,t,o);case e.FLOAT_MAT3:return new Me(e,n,t,o);case e.FLOAT_MAT4:return new Pe(e,n,t,o);default:throw new _.t("Unrecognized uniform type: "+n.type+' for uniform "'+t+'".')}}function ze(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Float32Array(i),this._gl=e,this._location=o[0]}function be(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Float32Array(2*i),this._gl=e,this._location=o[0]}function we(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Float32Array(3*i),this._gl=e,this._location=o[0]}function Se(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Float32Array(4*i),this._gl=e,this._location=o[0]}function Le(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Float32Array(i),this._gl=e,this._locations=o,this.textureUnitIndex=void 0}function Ee(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Int32Array(i),this._gl=e,this._location=o[0]}function De(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Int32Array(2*i),this._gl=e,this._location=o[0]}function Ae(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Int32Array(3*i),this._gl=e,this._location=o[0]}function Ie(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Int32Array(4*i),this._gl=e,this._location=o[0]}function Ve(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Float32Array(4*i),this._gl=e,this._location=o[0]}function Me(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Float32Array(9*i),this._gl=e,this._location=o[0]}function Pe(e,n,t,o){var i=o.length;this.name=t,this.value=new Array(i),this._value=new Float32Array(16*i),this._gl=e,this._location=o[0]}ye.prototype.set=function(){if(!m.y.equalsArray(this.value,this._value,0)){m.y.clone(this.value,this._value);var e=m.y.toArray(this.value,Ce);this._gl.uniformMatrix4fv(this._location,!1,e)}},ze.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,i=0;i<n;++i){var r=e[i];r!==t[i]&&(t[i]=r,o=!0)}o&&this._gl.uniform1fv(this._location,t)},be.prototype.set=function(){for(var e=this.value,n=e.length,o=this._value,i=!1,r=0,a=0;a<n;++a){var l=e[a];t.o.equalsArray(l,o,r)||(t.o.pack(l,o,r),i=!0),r+=2}i&&this._gl.uniform2fv(this._location,o)},we.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,i=!1,l=0,c=0;c<n;++c){var s=e[c];if(a.e(s.red))(s.red!==t[l]||s.green!==t[l+1]||s.blue!==t[l+2])&&(t[l]=s.red,t[l+1]=s.green,t[l+2]=s.blue,i=!0);else{if(!a.e(s.x))throw new r.t("Invalid vec3 value.");o.t.equalsArray(s,t,l)||(o.t.pack(s,t,l),i=!0)}l+=3}i&&this._gl.uniform3fv(this._location,t)},Se.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,l=0,c=0;c<n;++c){var s=e[c];if(a.e(s.red))T.e.equalsArray(s,t,l)||(T.e.pack(s,t,l),o=!0);else{if(!a.e(s.x))throw new r.t("Invalid vec4 value.");i.e.equalsArray(s,t,l)||(i.e.pack(s,t,l),o=!0)}l+=4}o&&this._gl.uniform4fv(this._location,t)},Le.prototype.set=function(){for(var e=this._gl,n=e.TEXTURE0+this.textureUnitIndex,t=this.value,o=t.length,i=0;i<o;++i){var r=t[i];e.activeTexture(n+i),e.bindTexture(r._target,r._texture)}},Le.prototype._setSampler=function(e){this.textureUnitIndex=e;for(var n=this._locations,t=n.length,o=0;o<t;++o){var i=e+o;this._gl.uniform1i(n[o],i)}return e+t},Ee.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,i=0;i<n;++i){var r=e[i];r!==t[i]&&(t[i]=r,o=!0)}o&&this._gl.uniform1iv(this._location,t)},De.prototype.set=function(){for(var e=this.value,n=e.length,o=this._value,i=!1,r=0,a=0;a<n;++a){var l=e[a];t.o.equalsArray(l,o,r)||(t.o.pack(l,o,r),i=!0),r+=2}i&&this._gl.uniform2iv(this._location,o)},Ae.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,i=!1,r=0,a=0;a<n;++a){var l=e[a];o.t.equalsArray(l,t,r)||(o.t.pack(l,t,r),i=!0),r+=3}i&&this._gl.uniform3iv(this._location,t)},Ie.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,r=0,a=0;a<n;++a){var l=e[a];i.e.equalsArray(l,t,r)||(i.e.pack(l,t,r),o=!0),r+=4}o&&this._gl.uniform4iv(this._location,t)},Ve.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,i=0,r=0;r<n;++r){var a=e[r];g.f.equalsArray(a,t,i)||(g.f.pack(a,t,i),o=!0),i+=4}o&&this._gl.uniformMatrix2fv(this._location,!1,t)},Me.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,i=0,r=0;r<n;++r){var a=e[r];m.p.equalsArray(a,t,i)||(m.p.pack(a,t,i),o=!0),i+=9}o&&this._gl.uniformMatrix3fv(this._location,!1,t)},Pe.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,i=0,r=0;r<n;++r){var a=e[r];m.y.equalsArray(a,t,i)||(m.y.pack(a,t,i),o=!0),i+=16}o&&this._gl.uniformMatrix4fv(this._location,!1,t)};var Re=0;function Oe(e){var n=function(e,n){var t={};if(!x.e.highpFloatSupported||!x.e.highpIntSupported){var o,i,r,a,l=Fe(e),c=Fe(n),s=l.length,u=c.length;for(o=0;o<s;o++)for(i=0;i<u;i++)if(l[o]===c[i]){a="czm_mediump_"+(r=l[o]);var m=new RegExp(r+"\\b","g");n=n.replace(m,a),t[a]=r}}return{fragmentShaderText:n,duplicateUniformNames:t}}(e.vertexShaderText,e.fragmentShaderText);this._gl=e.gl,this._logShaderCompilation=e.logShaderCompilation,this._debugShaders=e.debugShaders,this._attributeLocations=e.attributeLocations,this._varyings=e.varyings,this._bufferMode=e.bufferMode,this._program=void 0,this._numberOfVertexAttributes=void 0,this._vertexAttributes=void 0,this._uniformsByName=void 0,this._uniforms=void 0,this._automaticUniforms=void 0,this._manualUniforms=void 0,this._duplicateUniformNames=n.duplicateUniformNames,this._cachedShader=void 0,this._uniformBlockLocation={},this.maximumTextureUnitIndex=void 0,this._vertexShaderSource=e.vertexShaderSource,this._vertexShaderText=e.vertexShaderText,this._fragmentShaderSource=e.fragmentShaderSource,this._fragmentShaderText=n.fragmentShaderText,this.id=Re++}function Fe(e){var n=[],t=e.match(/uniform.*?(?![^{]*})(?=[=\[;])/g);if(a.e(t))for(var o=t.length,i=0;i<o;i++){var r=t[i].trim(),l=r.slice(r.lastIndexOf(" ")+1);n.push(l)}return n}Oe.fromCache=function(e){return e=a.u(e,a.u.EMPTY_OBJECT),r.o.defined("options.context",e.context),e.context.shaderCache.getShaderProgram(e)},Oe.replaceCache=function(e){return e=a.u(e,a.u.EMPTY_OBJECT),r.o.defined("options.context",e.context),e.context.shaderCache.replaceShaderProgram(e)},Object.defineProperties(Oe.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},vertexAttributes:{get:function(){return Ne(this),this._vertexAttributes}},numberOfVertexAttributes:{get:function(){return Ne(this),this._numberOfVertexAttributes}},allUniforms:{get:function(){return Ne(this),this._uniformsByName}}});var Be="[Cesium WebGL] ";function Ne(e){if(!a.e(e._program)){var n=e._gl,t=function(e,n){var t=n._vertexShaderText,o=n._fragmentShaderText,i=e.createShader(e.VERTEX_SHADER);e.shaderSource(i,t),e.compileShader(i);var r=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(r,o),e.compileShader(r);var l=e.createProgram();e.attachShader(l,i),e.attachShader(l,r),e.deleteShader(i),e.deleteShader(r);var c=n._attributeLocations;if(a.e(c))for(var s in c)c.hasOwnProperty(s)&&e.bindAttribLocation(l,c[s],s);var u,m=n._varyings,f=n._bufferMode;if(a.e(m)&&a.e(f)&&e.transformFeedbackVaryings(l,m,f),e.linkProgram(l),!e.getProgramParameter(l,e.LINK_STATUS)){var d=n._debugShaders;if(!e.getShaderParameter(r,e.COMPILE_STATUS)){if(u=e.getShaderInfoLog(r),console.error(Be+"Fragment shader compile log: "+u),a.e(d)){var p=d.getTranslatedShaderSource(r);console.error(""!==p?Be+"Translated fragment shader source:\n"+p:Be+"Fragment shader translation failed.")}throw e.deleteProgram(l),new _.t("Fragment shader failed to compile.  Compile log: "+u)}if(!e.getShaderParameter(i,e.COMPILE_STATUS)){if(u=e.getShaderInfoLog(i),console.error(Be+"Vertex shader compile log: "+u),a.e(d)){var h=d.getTranslatedShaderSource(i);console.error(""!==h?Be+"Translated vertex shader source:\n"+h:Be+"Vertex shader translation failed.")}throw e.deleteProgram(l),new _.t("Vertex shader failed to compile.  Compile log: "+u)}throw u=e.getProgramInfoLog(l),console.error(Be+"Shader program link log: "+u),a.e(d)&&(console.error(Be+"Translated vertex shader source:\n"+d.getTranslatedShaderSource(i)),console.error(Be+"Translated fragment shader source:\n"+d.getTranslatedShaderSource(r))),e.deleteProgram(l),new _.t("Program failed to link.  Link log: "+u)}var v=n._logShaderCompilation;return v&&(u=e.getShaderInfoLog(i),a.e(u)&&u.length>0&&console.log(Be+"Vertex shader compile log: "+u)),v&&(u=e.getShaderInfoLog(r),a.e(u)&&u.length>0&&console.log(Be+"Fragment shader compile log: "+u)),v&&(u=e.getProgramInfoLog(l),a.e(u)&&u.length>0&&console.log(Be+"Shader program link log: "+u)),l}(n,e,e._debugShaders),o=n.getProgramParameter(t,n.ACTIVE_ATTRIBUTES),i=function(e,n){for(var t={},o=[],i=[],r=e.getProgramParameter(n,e.ACTIVE_UNIFORMS),l=0;l<r;++l){var c=e.getActiveUniform(n,l),s=-1!==c.name.indexOf("[0]",c.name.length-"[0]".length)?c.name.slice(0,c.name.length-3):c.name;if(0!==s.indexOf("gl_"))if(c.name.indexOf("[")<0){var u=e.getUniformLocation(n,s);if(null!==u){var m=re(e,c,s,u);t[s]=m,o.push(m),m._setSampler&&i.push(m)}}else{var f,d,p,h,v=s.indexOf("[");if(v>=0){if(f=t[s.slice(0,v)],!a.e(f))continue;(d=f._locations).length<=1&&(p=f.value,null!==(h=e.getUniformLocation(n,s))&&(d.push(h),p.push(e.getUniform(n,h))))}else{d=[];for(var g=0;g<c.size;++g)null!==(h=e.getUniformLocation(n,s+"["+g+"]"))&&d.push(h);f=Te(e,c,s,d),t[s]=f,o.push(f),f._setSampler&&i.push(f)}}}return{uniformsByName:t,uniforms:o,samplerUniforms:i}}(n,t),r=function(e,n){var t=[],o=[];for(var i in n)if(n.hasOwnProperty(i)){var r=n[i],l=i,c=e._duplicateUniformNames[l];a.e(c)&&(r.name=c,l=c);var s=O[l];a.e(s)?t.push({uniform:r,automaticUniform:s}):o.push(r)}return{automaticUniforms:t,manualUniforms:o}}(e,i.uniformsByName);e._program=t,e._numberOfVertexAttributes=o,e._vertexAttributes=function(e,n,t){for(var o={},i=0;i<t;++i){var r=e.getActiveAttrib(n,i),a=e.getAttribLocation(n,r.name);o[r.name]={name:r.name,type:r.type,index:a}}return o}(n,t,o),e._uniformsByName=i.uniformsByName,e._uniforms=i.uniforms,e._automaticUniforms=r.automaticUniforms,e._manualUniforms=r.manualUniforms,e.maximumTextureUnitIndex=function(e,n,t){e.useProgram(n);for(var o=0,i=t.length,r=0;r<i;++r)o=t[r]._setSampler(o);return e.useProgram(null),o}(n,t,i.samplerUniforms)}}Oe.prototype._bind=function(){Ne(this),this._gl.useProgram(this._program)},Oe.prototype._setUniforms=function(e,n,t){var o,i;if(a.e(e)){var l=this._manualUniforms;for(o=l.length,i=0;i<o;++i){var c=l[i];c.value=e[c.name]()}}var s=this._automaticUniforms;for(o=s.length,i=0;i<o;++i){var u=s[i];u.uniform.value=u.automaticUniform.getValue(n)}var m=this._uniforms;for(o=m.length,i=0;i<o;++i)m[i].set();if(t){var f=this._gl,d=this._program;if(f.validateProgram(d),!f.getProgramParameter(d,f.VALIDATE_STATUS))throw new r.t("Program validation failed.  Program info log: "+f.getProgramInfoLog(d))}},Oe.prototype.isDestroyed=function(){return!1},Oe.prototype.destroy=function(){this._cachedShader.cache.releaseShaderProgram(this)},Oe.prototype.finalDestroy=function(){return this._gl.deleteProgram(this._program),p.i(this)};var He=Object.freeze({ENVIRONMENT:0,COMPUTE:1,GLOBE:2,TERRAIN_CLASSIFICATION:3,CESIUM_3D_TILE:4,CESIUM_3D_TILE_CLASSIFICATION:5,CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW:6,S3MTiles:8,S3MTilesClampObjectStencil:9,S3MTilesClampObjectColor:10,ProjectionImage:11,OPAQUE:12,ClampObject:13,NonClampObject:14,Label_Billboard:15,Voxel_Billboard:16,Particle:17,TRANSLUCENT:18,ANALYSIS:19,LOG_DEPTH_OVERLAY:20,OVERLAY:21,OVERLAY_AGAINST_DEPTH:22,NUMBER_OF_PASSES:23}),Ge={FRONT:C.B.FRONT,BACK:C.B.BACK,FRONT_AND_BACK:C.B.FRONT_AND_BACK},ke=Object.freeze(Ge),Ue={NEVER:C.B.NEVER,LESS:C.B.LESS,EQUAL:C.B.EQUAL,LESS_OR_EQUAL:C.B.LEQUAL,GREATER:C.B.GREATER,NOT_EQUAL:C.B.NOTEQUAL,GREATER_OR_EQUAL:C.B.GEQUAL,ALWAYS:C.B.ALWAYS},We=Object.freeze(Ue),qe={ZERO:C.B.ZERO,KEEP:C.B.KEEP,REPLACE:C.B.REPLACE,INCREMENT:C.B.INCR,DECREMENT:C.B.DECR,INVERT:C.B.INVERT,INCREMENT_WRAP:C.B.INCR_WRAP,DECREMENT_WRAP:C.B.DECR_WRAP},Xe=Object.freeze(qe),Ye={CESIUM_3D_TILE_MASK:128,S3M_TILE:2,MODEL:6,SKIP_LOD_MASK:112,SKIP_LOD_BIT_SHIFT:4,CLASSIFICATION_MASK:15,setCesium3DTileBit:function(){return{enabled:!0,frontFunction:We.ALWAYS,frontOperation:{fail:Xe.KEEP,zFail:Xe.KEEP,zPass:Xe.REPLACE},backFunction:We.ALWAYS,backOperation:{fail:Xe.KEEP,zFail:Xe.KEEP,zPass:Xe.REPLACE},reference:Ye.CESIUM_3D_TILE_MASK,mask:Ye.CESIUM_3D_TILE_MASK}}},je=Object.freeze(Ye),Ze=[];function Ke(e,n){this.center=o.t.clone(a.u(e,o.t.ZERO)),this.halfAxes=m.p.clone(a.u(n,m.p.ZERO)),this.areaDirty=1}Ze[0]={num:0,des:"inside"},Ze[1]={num:4,data:[0,4,7,3],des:"left"},Ze[2]={num:4,data:[1,2,6,5],des:"right"},Ze[3]={num:0},Ze[4]={num:4,data:[0,1,5,4],des:"bottom"},Ze[5]={num:6,data:[0,1,5,4,7,3],des:"bottom, left"},Ze[6]={num:6,data:[0,1,2,6,5,4],des:"bottom, right"},Ze[7]={num:0},Ze[8]={num:4,data:[2,3,7,6],des:"top"},Ze[9]={num:6,data:[4,7,6,2,3,0],des:"top, left"},Ze[10]={num:6,data:[2,3,7,6,5,1],des:"top, right"},Ze[11]={num:0},Ze[12]={num:0},Ze[13]={num:0},Ze[14]={num:0},Ze[15]={num:0},Ze[16]={num:4,data:[0,3,2,1],des:"front"},Ze[17]={num:6,data:[0,4,7,3,2,1],des:"front, left"},Ze[18]={num:6,data:[0,3,2,6,5,1],des:"front, right"},Ze[19]={num:0},Ze[20]={num:6,data:[0,3,2,1,5,4],des:"front, bottom"},Ze[21]={num:6,data:[2,1,5,4,7,3],des:"front, bottom, left"},Ze[22]={num:6,data:[0,3,2,6,5,4],des:"front, bottom, right"},Ze[23]={num:0},Ze[24]={num:6,data:[0,3,7,6,2,1],des:"front, top"},Ze[25]={num:6,data:[0,4,7,6,2,1],des:"front, top, left"},Ze[26]={num:6,data:[0,3,7,6,5,1],des:"front, top, right"},Ze[27]={num:0},Ze[28]={num:0},Ze[29]={num:0},Ze[30]={num:0},Ze[31]={num:0},Ze[32]={num:4,data:[4,5,6,7],des:"back"},Ze[33]={num:6,data:[4,5,6,7,3,0],des:"back, left"},Ze[34]={num:6,data:[1,2,6,7,4,5],des:"back, right"},Ze[35]={num:0},Ze[36]={num:6,data:[0,1,5,6,7,4],des:"back, bottom"},Ze[37]={num:6,data:[0,1,5,6,7,3],des:"back, bottom, left"},Ze[38]={num:6,data:[0,1,2,6,7,4],des:"back, bottom, right"},Ze[39]={num:0},Ze[40]={num:6,data:[2,3,7,4,5,6],des:"back, top"},Ze[41]={num:6,data:[0,4,5,6,2,3],des:"back, top, left"},Ze[42]={num:6,data:[1,2,3,7,4,5],des:"back, top, right"},Ke.packedLength=o.t.packedLength+m.p.packedLength,Ke.pack=function(e,n,t){return r.o.typeOf.object("value",e),r.o.defined("array",n),t=a.u(t,0),o.t.pack(e.center,n,t),m.p.pack(e.halfAxes,n,t+o.t.packedLength),n},Ke.unpack=function(e,n,t){return r.o.defined("array",e),n=a.u(n,0),a.e(t)||(t=new Ke),o.t.unpack(e,n,t.center),m.p.unpack(e,n+o.t.packedLength,t.halfAxes),t};var $e=new o.t,Qe=new o.t,Je=new o.t,en=new o.t,nn=new o.t,tn=new o.t,on=new m.p,rn={unitary:new m.p,diagonal:new m.p},an=new o.t,ln=new o.t,cn=new o.t;Ke.fromPoints=function(e,n){if(a.e(n)||(n=new Ke),!a.e(e)||0===e.length)return n.halfAxes=m.p.ZERO,n.center=o.t.ZERO,n;var t,i=e.length,r=o.t.clone(e[0],$e);for(t=1;t<i;t++)o.t.add(r,e[t],r);var l=1/i;o.t.multiplyByScalar(r,l,r);var c,s=0,u=0,f=0,d=0,p=0,h=0;for(t=0;t<i;t++)s+=(c=o.t.subtract(e[t],r,Qe)).x*c.x,u+=c.x*c.y,f+=c.x*c.z,d+=c.y*c.y,p+=c.y*c.z,h+=c.z*c.z;s*=l,u*=l,f*=l,d*=l,p*=l,h*=l;var v=on;v[0]=s,v[1]=u,v[2]=f,v[3]=u,v[4]=d,v[5]=p,v[6]=f,v[7]=p,v[8]=h;var g=m.p.computeEigenDecomposition(v,rn),_=m.p.clone(g.unitary,n.halfAxes),x=m.p.getColumn(_,0,en),C=m.p.getColumn(_,1,nn),y=m.p.getColumn(_,2,tn),T=-Number.MAX_VALUE,z=-Number.MAX_VALUE,b=-Number.MAX_VALUE,w=Number.MAX_VALUE,S=Number.MAX_VALUE,L=Number.MAX_VALUE;for(t=0;t<i;t++)c=e[t],T=Math.max(o.t.dot(x,c),T),z=Math.max(o.t.dot(C,c),z),b=Math.max(o.t.dot(y,c),b),w=Math.min(o.t.dot(x,c),w),S=Math.min(o.t.dot(C,c),S),L=Math.min(o.t.dot(y,c),L);x=o.t.multiplyByScalar(x,.5*(w+T),x),C=o.t.multiplyByScalar(C,.5*(S+z),C),y=o.t.multiplyByScalar(y,.5*(L+b),y);var E=o.t.add(x,C,n.center);o.t.add(E,y,E);var D=Je;return D.x=T-w,D.y=z-S,D.z=b-L,o.t.multiplyByScalar(D,.5,D),m.p.multiplyByScale(n.halfAxes,D,n.halfAxes),n};var sn=new o.t,un=new o.t;function mn(e,n,t,i,l,c,s,u,f,d,p){if(!(a.e(l)&&a.e(c)&&a.e(s)&&a.e(u)&&a.e(f)&&a.e(d)))throw new r.t("all extents (minimum/maximum X/Y/Z) are required.");a.e(p)||(p=new Ke);var h=p.halfAxes;m.p.setColumn(h,0,n,h),m.p.setColumn(h,1,t,h),m.p.setColumn(h,2,i,h);var v=sn;v.x=(l+c)/2,v.y=(s+u)/2,v.z=(f+d)/2;var g=un;g.x=(c-l)/2,g.y=(u-s)/2,g.z=(d-f)/2;var _=p.center;return v=m.p.multiplyByVector(h,v,v),o.t.add(e,v,_),m.p.multiplyByScale(h,g,h),p}var fn=new o.t$1,dn=new o.t,pn=new o.t$1,hn=new o.t$1,vn=new o.t$1,gn=new o.t$1,_n=new o.t$1,xn=new o.t,Cn=new o.t,yn=new o.t,Tn=new o.t,zn=new o.t,bn=new t.o,wn=new t.o,Sn=new t.o,Ln=new t.o,En=new t.o,Dn=new o.t,An=new o.t,In=new o.t,Vn=new o.t,Mn=new t.o,Pn=new o.t,Rn=new o.t,On=new o.t,Fn=new f.o(o.t.UNIT_X,0);Ke.fromRectangle=function(e,n,t,i,s){if(!a.e(e))throw new r.t("rectangle is required");if(e.width<0||e.width>u.e.TWO_PI)throw new r.t("Rectangle width must be between 0 and 2*pi");if(e.height<0||e.height>u.e.PI)throw new r.t("Rectangle height must be between 0 and pi");if(a.e(i)&&!u.e.equalsEpsilon(i.radii.x,i.radii.y,u.e.EPSILON15))throw new r.t("Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)");var m,d,p,h,v,g,_;if(n=a.u(n,0),t=a.u(t,0),i=a.u(i,l.t.WGS84),e.width<=u.e.PI){var x=l.h.center(e,fn),C=i.cartographicToCartesian(x,dn),y=new c.f(C,i);_=y.plane;var T=x.longitude,z=e.south<0&&e.north>0?0:x.latitude,b=o.t$1.fromRadians(T,e.north,t,pn),w=o.t$1.fromRadians(e.west,e.north,t,hn),S=o.t$1.fromRadians(e.west,z,t,vn),L=o.t$1.fromRadians(e.west,e.south,t,gn),E=o.t$1.fromRadians(T,e.south,t,_n),D=i.cartographicToCartesian(b,xn),A=i.cartographicToCartesian(w,Cn),I=i.cartographicToCartesian(S,yn),V=i.cartographicToCartesian(L,Tn),M=i.cartographicToCartesian(E,zn),P=y.projectPointToNearestOnPlane(D,bn),R=y.projectPointToNearestOnPlane(A,wn),O=y.projectPointToNearestOnPlane(I,Sn),F=y.projectPointToNearestOnPlane(V,Ln),B=y.projectPointToNearestOnPlane(M,En);return d=-(m=Math.min(R.x,O.x,F.x)),h=Math.max(R.y,P.y),p=Math.min(F.y,B.y),w.height=L.height=n,A=i.cartographicToCartesian(w,Cn),V=i.cartographicToCartesian(L,Tn),v=Math.min(f.o.getPointDistance(_,A),f.o.getPointDistance(_,V)),g=t,mn(y.origin,y.xAxis,y.yAxis,y.zAxis,m,d,p,h,v,g,s)}var N=e.south>0,H=e.north<0,G=N?e.south:H?e.north:0,k=l.h.center(e,fn).longitude,U=o.t.fromRadians(k,G,t,i,Dn);U.z=0;var W=Math.abs(U.x)<u.e.EPSILON10&&Math.abs(U.y)<u.e.EPSILON10?o.t.UNIT_X:o.t.normalize(U,An),q=o.t.UNIT_Z,X=o.t.cross(W,q,In);_=f.o.fromPointNormal(U,W,Fn);var Y=o.t.fromRadians(k+u.e.PI_OVER_TWO,G,t,i,Vn);m=-(d=o.t.dot(f.o.projectPointOntoPlane(_,Y,Mn),X)),h=o.t.fromRadians(0,e.north,H?n:t,i,Pn).z,p=o.t.fromRadians(0,e.south,N?n:t,i,Rn).z;var j=o.t.fromRadians(e.east,G,t,i,On);return mn(U,X,q,W,m,d,p,h,v=f.o.getPointDistance(_,j),g=0,s)},Ke.clone=function(e,n){if(a.e(e))return a.e(n)?(o.t.clone(e.center,n.center),m.p.clone(e.halfAxes,n.halfAxes),n.areaDirty=1,n):new Ke(e.center,e.halfAxes)},Ke.intersectPlane=function(e,n){if(!a.e(e))throw new r.t("box is required.");if(!a.e(n))throw new r.t("plane is required.");var t=e.center,i=n.normal,l=e.halfAxes,c=i.x,u=i.y,f=i.z,d=Math.abs(c*l[m.p.COLUMN0ROW0]+u*l[m.p.COLUMN0ROW1]+f*l[m.p.COLUMN0ROW2])+Math.abs(c*l[m.p.COLUMN1ROW0]+u*l[m.p.COLUMN1ROW1]+f*l[m.p.COLUMN1ROW2])+Math.abs(c*l[m.p.COLUMN2ROW0]+u*l[m.p.COLUMN2ROW1]+f*l[m.p.COLUMN2ROW2]),p=o.t.dot(i,t)+n.distance;return p<=-d?s.S.OUTSIDE:p>=d?s.S.INSIDE:s.S.INTERSECTING};var Bn=new o.t,Nn=new o.t,Hn=new o.t,Gn=new o.t,kn=new o.t;Ke.distanceSquaredTo=function(e,n){if(!a.e(e))throw new r.t("box is required.");if(!a.e(n))throw new r.t("cartesian is required.");var t=o.t.subtract(n,e.center,sn),i=e.halfAxes,l=m.p.getColumn(i,0,Bn),c=m.p.getColumn(i,1,Nn),s=m.p.getColumn(i,2,Hn),u=o.t.magnitude(l),f=o.t.magnitude(c),d=o.t.magnitude(s);o.t.normalize(l,l),o.t.normalize(c,c),o.t.normalize(s,s);var p=Gn;p.x=o.t.dot(t,l),p.y=o.t.dot(t,c),p.z=o.t.dot(t,s);var h,v=0;return p.x<-u?v+=(h=p.x+u)*h:p.x>u&&(v+=(h=p.x-u)*h),p.y<-f?v+=(h=p.y+f)*h:p.y>f&&(v+=(h=p.y-f)*h),p.z<-d?v+=(h=p.z+d)*h:p.z>d&&(v+=(h=p.z-d)*h),v};var Un=new o.t,Wn=new o.t;Ke.computePlaneDistances=function(e,t,i,l){if(!a.e(e))throw new r.t("box is required.");if(!a.e(t))throw new r.t("position is required.");if(!a.e(i))throw new r.t("direction is required.");a.e(l)||(l=new n.o);var c=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,u=e.center,f=e.halfAxes,d=m.p.getColumn(f,0,Bn),p=m.p.getColumn(f,1,Nn),h=m.p.getColumn(f,2,Hn),v=o.t.add(d,p,Un);o.t.add(v,h,v),o.t.add(v,u,v);var g=o.t.subtract(v,t,Wn),_=o.t.dot(i,g);return c=Math.min(_,c),s=Math.max(_,s),o.t.add(u,d,v),o.t.add(v,p,v),o.t.subtract(v,h,v),o.t.subtract(v,t,g),_=o.t.dot(i,g),c=Math.min(_,c),s=Math.max(_,s),o.t.add(u,d,v),o.t.subtract(v,p,v),o.t.add(v,h,v),o.t.subtract(v,t,g),_=o.t.dot(i,g),c=Math.min(_,c),s=Math.max(_,s),o.t.add(u,d,v),o.t.subtract(v,p,v),o.t.subtract(v,h,v),o.t.subtract(v,t,g),_=o.t.dot(i,g),c=Math.min(_,c),s=Math.max(_,s),o.t.subtract(u,d,v),o.t.add(v,p,v),o.t.add(v,h,v),o.t.subtract(v,t,g),_=o.t.dot(i,g),c=Math.min(_,c),s=Math.max(_,s),o.t.subtract(u,d,v),o.t.add(v,p,v),o.t.subtract(v,h,v),o.t.subtract(v,t,g),_=o.t.dot(i,g),c=Math.min(_,c),s=Math.max(_,s),o.t.subtract(u,d,v),o.t.subtract(v,p,v),o.t.add(v,h,v),o.t.subtract(v,t,g),_=o.t.dot(i,g),c=Math.min(_,c),s=Math.max(_,s),o.t.subtract(u,d,v),o.t.subtract(v,p,v),o.t.subtract(v,h,v),o.t.subtract(v,t,g),_=o.t.dot(i,g),c=Math.min(_,c),s=Math.max(_,s),l.start=c,l.stop=s,l};var qn=new n.i;Ke.isOccluded=function(e,t){if(!a.e(e))throw new r.t("box is required.");if(!a.e(t))throw new r.t("occluder is required.");var o=n.i.fromOrientedBoundingBox(e,qn);return!t.isBoundingSphereVisible(o)},Ke.prototype.intersectPlane=function(e){return Ke.intersectPlane(this,e)},Ke.prototype.distanceSquaredTo=function(e){return Ke.distanceSquaredTo(this,e)},Ke.prototype.computePlaneDistances=function(e,n,t){return Ke.computePlaneDistances(this,e,n,t)},Ke.prototype.isOccluded=function(e){return Ke.isOccluded(this,e)},Ke.equals=function(e,n){return e===n||a.e(e)&&a.e(n)&&o.t.equals(e.center,n.center)&&m.p.equals(e.halfAxes,n.halfAxes)},Ke.prototype.clone=function(e){return Ke.clone(this,e)},Ke.prototype.equals=function(e){return Ke.equals(this,e)};var Xn=new i.e;Ke.prototype._updateBBox=function(){if(1==this.areaDirty){var e=m.p.getColumn(this.halfAxes,0,Bn),n=o.t.clone(o.t.negate(e,an)),t=m.p.getColumn(this.halfAxes,1,Nn),i=o.t.clone(o.t.negate(t,an)),r=m.p.getColumn(this.halfAxes,2,Hn),a=o.t.clone(o.t.negate(r,an));this.bbox=[],o.t.add(this.center,t,an),o.t.add(an,a,ln),o.t.add(ln,n,cn),this.bbox[0]=new o.t(cn.x,cn.y,cn.z),o.t.add(ln,e,cn),this.bbox[1]=new o.t(cn.x,cn.y,cn.z),o.t.add(an,r,ln),o.t.add(ln,e,cn),this.bbox[2]=new o.t(cn.x,cn.y,cn.z),o.t.add(ln,n,cn),this.bbox[3]=new o.t(cn.x,cn.y,cn.z),o.t.add(this.center,i,an),o.t.add(an,a,ln),o.t.add(ln,n,cn),this.bbox[4]=new o.t(cn.x,cn.y,cn.z),o.t.add(ln,e,cn),this.bbox[5]=new o.t(cn.x,cn.y,cn.z),o.t.add(an,r,ln),o.t.add(ln,e,cn),this.bbox[6]=new o.t(cn.x,cn.y,cn.z),o.t.add(ln,n,cn),this.bbox[7]=new o.t(cn.x,cn.y,cn.z);var l=o.t.magnitude(e),c=o.t.magnitude(t),s=o.t.magnitude(r),u=new o.t(-l,-c,-s),f=new o.t(l,c,s);if(l*c*s==0)return void(this.areaDirty=-1);o.t.normalize(e,e),o.t.normalize(t,t),o.t.normalize(r,r),this.u=o.t.clone(e),this.v=o.t.clone(t),this.w=o.t.clone(r),this.posMin=u,this.posMaX=f,this.areaDirty=0}};var Yn=void 0;Ke.prototype._createDeriveZBackfaceCommand=function(e){if(a.e(this.command))return this.command;this._updateBBox();for(var n=new Float32Array(24),t=0;t<8;t++)n[3*t]=this.bbox[t].x-this.center.x,n[3*t+1]=this.bbox[t].y-this.center.y,n[3*t+2]=this.bbox[t].z-this.center.z;a.e(Yn)||((Yn=new Uint8Array(36))[0]=3,Yn[1]=2,Yn[2]=6,Yn[3]=3,Yn[4]=6,Yn[5]=7,Yn[6]=0,Yn[7]=4,Yn[8]=1,Yn[9]=1,Yn[10]=4,Yn[11]=5,Yn[12]=4,Yn[13]=6,Yn[14]=5,Yn[15]=4,Yn[16]=7,Yn[17]=6,Yn[18]=0,Yn[19]=3,Yn[20]=4,Yn[21]=3,Yn[22]=7,Yn[23]=4,Yn[24]=0,Yn[25]=1,Yn[26]=2,Yn[27]=0,Yn[28]=2,Yn[29]=3,Yn[30]=1,Yn[31]=5,Yn[32]=6,Yn[33]=1,Yn[34]=6,Yn[35]=2);var o=p.h.createIndexBuffer({context:e,typedArray:Yn,usage:p.A.STATIC_DRAW,indexDatatype:h.IndexDatatype.UNSIGNED_BYTE});o.vertexArrayDestroyable=!1,o.referenceCount=1;var i=new w({context:e,attributes:[{index:0,vertexBuffer:p.h.createVertexBuffer({context:e,typedArray:n,usage:p.A.STATIC_DRAW}),componentDatatype:v.ComponentDatatype.FLOAT,componentsPerAttribute:3,offsetInBytes:0,strideInBytes:3*v.ComponentDatatype.getSizeInBytes(v.ComponentDatatype.FLOAT)}],indexBuffer:o}),r=["attribute vec4 position;","void main()","{","   gl_Position = czm_modelViewProjection * vec4(position.xyz, 1.0);","}"].join("\n"),l=["void main()","{","   gl_FragColor = vec4(1.0,0.0,0.0,0.3);","}"].join("\n"),c=new J({sources:[r]}),s=new J({sources:[l]});this.command=new E,this.command.cull=!1,this.command.boundingVolume=this,this.command.orientedBoundingBox=this,this.command.shaderProgram=Oe.fromCache({context:e,vertexShaderSource:c,fragmentShaderSource:s,attributeLocations:{position:0}});var u=m.y.fromTranslation(this.center);return this.command.uniformMap={},this.command.modelMatrix=u,this.command.primitiveType=m._0x102869.TRIANGLES,this.command.vertexArray=i,this.command.count=Yn.length,this.command.pass=He.S3MTilesClampObjectStencil,this.command.renderState=x.u.fromCache({cull:{enabled:!0,face:ke.BACK},colorMask:{red:!1,green:!1,blue:!1,alpha:!1},stencilMask:je.SKIP_LOD_MASK,stencilTest:{enabled:!0,backFunction:We.NOT_EQUAL,backOperation:{fail:Xe.KEEP,zFail:Xe.REPLACE,zPass:Xe.REPLACE},frontFunction:We.NOT_EQUAL,frontOperation:{fail:Xe.KEEP,zFail:Xe.REPLACE,zPass:Xe.REPLACE},reference:je.SKIP_LOD_MASK,mask:je.SKIP_LOD_MASK}}),this.command};var jn=[];jn.push(new t.o),jn.push(new t.o),jn.push(new t.o),jn.push(new t.o),jn.push(new t.o),jn.push(new t.o);var Zn=new o.t$1,Kn=new o.t;Ke.prototype.calculateBoxArea=function(e,n,t,r,l,c,s,f){this._updateBBox();var p=e,h=o.t.subtract(p,this.center,kn);if(-1==this.areaDirty){var v=l/r*(L=-1!=c?c:.5*o.t.distance(this.posMaX,this.posMin))/t;return u.e.PI*v*v}var g=o.t.fromElements(o.t.dot(h,this.u),o.t.dot(h,this.v),o.t.dot(h,this.w),Un),_=(g.x<this.posMin.x?1:0)+((g.x>this.posMaX.x?1:0)<<1)+((g.z<this.posMin.z?1:0)<<2)+((g.z>this.posMaX.z?1:0)<<3)+((g.y>this.posMaX.y?1:0)<<4)+((g.y<this.posMin.y?1:0)<<5);if(_>42)return console.log("area calculation is wrong"),-100;var x=Ze[_];if(0==x.num){v=l/r*(L=-1!=c?c:.5*o.t.distance(this.posMaX,this.posMin))/t;return u.e.PI*v*v}if(0==x.num)return console.log("area calculation is wrong"),-100;for(var C,y=[],T=s,z=0;z<x.num;z++){var b=jn[z],w=this.bbox[x.data[z]];C=!1;var S,L,E=u.e.PI;if(3===n)(S=m.y.multiplyByVector(T,i.e.fromElements(w.x,w.y,w.z,1),Xn)).z<0&&(C=!0,-1==L&&(E=u.e.PI_OVER_FOUR,t=o.t.magnitude(h)));else{var D=f,A=D.ellipsoid.cartesianToCartographic(w,Zn);a.e(A)?(D.project(A,Kn),(S=m.y.multiplyByVector(T,i.e.fromElements(Kn.z,Kn.x,Kn.y,1),Xn)).z<0&&(C=!0)):C=!0}if(1==C)return E*(v=l/r*(L=-1!=c?c:.5*o.t.distance(this.posMaX,this.posMin))/t)*v;b.x=S.x/S.w,b.y=l-S.y/S.w,y.push(b)}return Math.abs(d.A.computeArea2D(y))},e.x=Ke}));
