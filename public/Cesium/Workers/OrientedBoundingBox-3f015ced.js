define(["exports","./buildModuleUrl-c881a5f0","./Cartesian2-4a5e3b0e","./Cartographic-dafe811b","./Cartesian4-58d59766","./Check-07c613bc","./when-207a1520","./Rectangle-49e286b5","./EllipsoidTangentPlane-fb04e18c","./Intersect-4d67bbf5","./Math-bae672f2","./PrimitiveType-44685a19","./Plane-e266b3a4","./PolygonPipeline-63f52c70","./Buffer-bf3c9fbe","./IndexDatatype-447558fc","./ComponentDatatype-662c7548","./GeometryAttribute-9a541822","./RuntimeError-b98f87df","./RenderState-f1428610","./WebGLConstants-8d1e45f7","./FeatureDetection-fc084259","./Color-03dac52c"],(function(e,n,t,o,r,i,a,l,c,s,u,f,m,d,v,p,h,x,g,_,C,y,T){"use strict";function z(e,n,t,o){var r=a.e(n.vertexBuffer),l=a.e(n.value),c=n.value?n.value.length:n.componentsPerAttribute;if(!r&&!l)throw new i.t("attribute must have a vertexBuffer or a value.");if(r&&l)throw new i.t("attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.");if(1!==c&&2!==c&&3!==c&&4!==c)throw l?new i.t("attribute.value.length must be in the range [1, 4]."):new i.t("attribute.componentsPerAttribute must be in the range [1, 4].");if(a.e(n.componentDatatype)&&!h.ComponentDatatype.validate(n.componentDatatype))throw new i.t("attribute must have a valid componentDatatype or not specify it.");if(a.e(n.strideInBytes)&&n.strideInBytes>255)throw new i.t("attribute must have a strideInBytes less than or equal to 255 or not specify it.");if(a.e(n.instanceDivisor)&&n.instanceDivisor>0&&!o.instancedArrays)throw new i.t("instanced arrays is not supported");if(a.e(n.instanceDivisor)&&n.instanceDivisor<0)throw new i.t("attribute must have an instanceDivisor greater than or equal to zero");if(a.e(n.instanceDivisor)&&l)throw new i.t("attribute cannot have have an instanceDivisor if it is not backed by a buffer");if(a.e(n.instanceDivisor)&&n.instanceDivisor>0&&0===n.index)throw new i.t("attribute zero cannot have an instanceDivisor greater than 0");var s={index:a.u(n.index,t),enabled:a.u(n.enabled,!0),vertexBuffer:n.vertexBuffer,value:l?n.value.slice(0):void 0,componentsPerAttribute:c,componentDatatype:a.u(n.componentDatatype,h.ComponentDatatype.FLOAT),normalize:a.u(n.normalize,!1),offsetInBytes:a.u(n.offsetInBytes,0),strideInBytes:a.u(n.strideInBytes,0),instanceDivisor:a.u(n.instanceDivisor,0)};if(r)s.vertexAttrib=function(e){var n=this.index;e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer._getBuffer()),e.vertexAttribPointer(n,this.componentsPerAttribute,this.componentDatatype,this.normalize,this.strideInBytes,this.offsetInBytes),e.enableVertexAttribArray(n),this.instanceDivisor>0&&(o.glVertexAttribDivisor(n,this.instanceDivisor),o._vertexAttribDivisors[n]=this.instanceDivisor,o._previousDrawInstanced=!0)},s.disableVertexAttribArray=function(e){e.disableVertexAttribArray(this.index),this.instanceDivisor>0&&o.glVertexAttribDivisor(t,0)};else{switch(s.componentsPerAttribute){case 1:s.vertexAttrib=function(e){e.vertexAttrib1fv(this.index,this.value)};break;case 2:s.vertexAttrib=function(e){e.vertexAttrib2fv(this.index,this.value)};break;case 3:s.vertexAttrib=function(e){e.vertexAttrib3fv(this.index,this.value)};break;case 4:s.vertexAttrib=function(e){e.vertexAttrib4fv(this.index,this.value)}}s.disableVertexAttribArray=function(e){}}e.push(s)}function b(e,n,t){for(var o=0;o<n.length;++o){var r=n[o];r.enabled&&r.vertexAttrib(e)}a.e(t)&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t._getBuffer())}function L(e){e=a.u(e,a.u.EMPTY_OBJECT),i.o.defined("options.context",e.context),i.o.defined("options.attributes",e.attributes);var n,t=e.context,o=t._gl,r=e.attributes,l=e.indexBuffer,c=[],s=1,u=!1,f=!1,m=r.length;for(n=0;n<m;++n)z(c,r[n],n,t);for(m=c.length,n=0;n<m;++n){var d=c[n];if(a.e(d.vertexBuffer)&&0===d.instanceDivisor){var v=d.strideInBytes||d.componentsPerAttribute*h.ComponentDatatype.getSizeInBytes(d.componentDatatype);s=d.vertexBuffer.sizeInBytes/v;break}}for(n=0;n<m;++n)c[n].instanceDivisor>0&&(u=!0),a.e(c[n].value)&&(f=!0);var p,x={};for(n=0;n<m;++n){var g=c[n].index;if(x[g])throw new i.t("Index "+g+" is used by more than one attribute.");x[g]=!0}t.vertexArrayObject&&(p=t.glCreateVertexArray(),t.glBindVertexArray(p),b(o,c,l),t.glBindVertexArray(null)),this._numberOfVertices=s,this._hasInstancedAttributes=u,this._hasConstantAttributes=f,this._context=t,this._gl=o,this._vao=p,this._attributes=c,this._indexBuffer=l}function S(e){return e.values.length/e.componentsPerAttribute}function w(e){return h.ComponentDatatype.getSizeInBytes(e.componentDatatype)*e.componentsPerAttribute}function D(e){e=a.u(e,a.u.EMPTY_OBJECT),this._boundingVolume=e.boundingVolume,this._orientedBoundingBox=e.orientedBoundingBox,this._cull=a.u(e.cull,!0),this._occlude=a.u(e.occlude,!0),this._modelMatrix=e.modelMatrix,this._primitiveType=a.u(e.primitiveType,f._0x102869.TRIANGLES),this._vertexArray=e.vertexArray,this._count=e.count,this._offset=a.u(e.offset,0),this._instanceCount=a.u(e.instanceCount,0),this._shaderProgram=e.shaderProgram,this._uniformMap=e.uniformMap,this._renderState=e.renderState,this._framebuffer=e.framebuffer,this._pass=e.pass,this._executeInClosestFrustum=a.u(e.executeInClosestFrustum,!1),this._owner=e.owner,this._debugShowBoundingVolume=a.u(e.debugShowBoundingVolume,!1),this._debugOverlappingFrustums=0,this._castShadows=a.u(e.castShadows,!1),this._receiveShadows=a.u(e.receiveShadows,!1),this._selectCastShadows=!1,this._pickId=e.pickId,this._pickOnly=a.u(e.pickOnly,!1),this.dirty=!0,this.lastDirtyTime=0,this.derivedCommands={},this._uniformBuffers=[]}function E(e,n){var t=/#define OUTPUT_DECLARATION/,o=e.split("\n");if(/#version 300 es/g.test(e))return e;var r,l,c=-1;for(r=0;r<o.length;++r)if(l=o[r],t.test(l)){c=r;break}if(-1===c)throw new i.t("Could not find a #define OUTPUT_DECLARATION!");var s=[];for(r=0;r<10;r++){var u="gl_FragData\\["+r+"\\]",f="czm_out"+r;new RegExp(u,"g").test(e)&&(V(f,s),A(u,f,o),o.splice(c,0,"layout(location = "+r+") out vec4 "+f+";"),c+=1)}var m="czm_fragColor";(function(e,n){for(var t=new RegExp("(^|[^\\w])("+e+")($|[^\\w])","g"),o=n.length,r=0;r<o;++r){var i=n[r];if(t.test(i))return!0}return!1})("gl_FragColor",o)&&(V(m,s),A("gl_FragColor",m,o),o.splice(c,0,"layout(location = 0) out vec4 czm_fragColor;"),c+=1);var d=function(e,n){for(var t={},o=e.length,r=[],i=0;i<n.length;++i){var l=n[i],c=/(#ifdef|#if)/g.test(l),s=/#else/g.test(l),u=/#endif/g.test(l);if(c)r.push(l);else if(s){var f=r[r.length-1].replace("ifdef","ifndef");/if/g.test(f)&&(f=f.replace(/(#if\s+)(\S*)([^]*)/,"$1!($2)$3")),r.pop(),r.push(f)}else if(u)r.pop();else if(!/layout/g.test(l))for(var m=0;m<o;++m){var d=e[m];-1!==l.indexOf(d)&&(a.e(t[d])?t[d]=t[d].filter((function(e){return r.indexOf(e)>=0})):t[d]=r.slice())}}return t}(s,o),v={};for(r=0;r<o.length;r++)for(var p in l=o[r],d)if(d.hasOwnProperty(p)){new RegExp("(layout)[^]+(out)[^]+("+p+")[^]+","g").test(l)&&(v[l]=p)}for(var h in v)if(v.hasOwnProperty(h)){var x,g=v[h],_=o.indexOf(h),C=d[g],y=C.length;for(x=0;x<y;x++)o.splice(_,0,C[x]);for(_+=y+1,x=y-1;x>=0;x--)o.splice(_,0,"#endif //"+C[x])}var T="#version 300 es",z=!1;for(r=0;r<o.length;r++)/#version/.test(o[r])&&(o[r]=T,z=!0);return z||o.splice(0,0,T),M("EXT_draw_buffers",o),M("EXT_frag_depth",o),A("texture2D","texture",o),A("texture3D","texture",o),A("textureCube","texture",o),A("gl_FragDepthEXT","gl_FragDepth",o),n?A("varying","in",o):(A("attribute","in",o),A("varying","out",o)),function(e){for(var n="",t=e.length,o=0;o<t;++o)n+=e[o]+"\n";return n}(o)}function A(e,n,t){for(var o=new RegExp("(^|[^\\w])("+e+")($|[^\\w])","g"),r=t.length,i=0;i<r;++i){var a=t[i];t[i]=a.replace(o,"$1"+n+"$3")}}function V(e,n){-1===n.indexOf(e)&&n.push(e)}function M(e,n){!function(e,n,t){for(var o=t.length,r=0;r<o;++r){var i=t[r];t[r]=i.replace(e,n)}}(new RegExp("#extension\\s+GL_"+e+"\\s+:\\s+[a-zA-Z0-9]+\\s*$","g"),"",n)}L.fromGeometry=function(e){e=a.u(e,a.u.EMPTY_OBJECT),i.o.defined("options.context",e.context);var n,t,o,r=e.context,l=a.u(e.geometry,a.u.EMPTY_OBJECT),c=a.u(e.bufferUsage,v.A.DYNAMIC_DRAW),s=a.u(e.attributeLocations,a.u.EMPTY_OBJECT),f=a.u(e.interleave,!1),m=e.vertexArrayAttributes,d=a.e(m)?m:[],_=l.attributes;if(f){var C=function(e){var n,t,o,r=[];for(t in e)e.hasOwnProperty(t)&&a.e(e[t])&&a.e(e[t].values)&&(r.push(t),e[t].componentDatatype===h.ComponentDatatype.DOUBLE&&(e[t].componentDatatype=h.ComponentDatatype.FLOAT,e[t].values=h.ComponentDatatype.createTypedArray(h.ComponentDatatype.FLOAT,e[t].values)));var i,l=r.length;if(l>0)for(i=S(e[r[0]]),n=1;n<l;++n){var c=S(e[r[n]]);if(c!==i)throw new g.t("Each attribute list must have the same number of vertices.  Attribute "+r[n]+" has a different number of vertices ("+c.toString()+") than attribute "+r[0]+" ("+i.toString()+").")}r.sort((function(n,t){return h.ComponentDatatype.getSizeInBytes(e[t].componentDatatype)-h.ComponentDatatype.getSizeInBytes(e[n].componentDatatype)}));var s=0,u={};for(n=0;n<l;++n)t=r[n],o=e[t],u[t]=s,s+=w(o);if(s>0){var f=h.ComponentDatatype.getSizeInBytes(e[r[0]].componentDatatype),m=s%f;0!==m&&(s+=f-m);var d=new ArrayBuffer(i*s),v={};for(n=0;n<l;++n){t=r[n];var p=h.ComponentDatatype.getSizeInBytes(e[t].componentDatatype);v[t]={pointer:h.ComponentDatatype.createTypedArray(e[t].componentDatatype,d),index:u[t]/p,strideInComponentType:s/p}}for(n=0;n<i;++n)for(var x=0;x<l;++x){t=r[x];for(var _=(o=e[t]).values,C=v[t],y=C.pointer,T=o.componentsPerAttribute,z=0;z<T;++z)y[C.index+z]=_[n*T+z];C.index+=C.strideInComponentType}return{buffer:d,offsetsInBytes:u,vertexSizeInBytes:s}}}(_);if(a.e(C)){o=v.h.createVertexBuffer({context:r,typedArray:C.buffer,usage:c});var y=C.offsetsInBytes,T=C.vertexSizeInBytes;for(n in _)_.hasOwnProperty(n)&&a.e(_[n])&&(t=_[n],a.e(t.values)?d.push({index:s[n],vertexBuffer:o,componentDatatype:t.componentDatatype,componentsPerAttribute:t.componentsPerAttribute,normalize:t.normalize,offsetInBytes:y[n],strideInBytes:T}):d.push({index:s[n],value:t.value,componentDatatype:t.componentDatatype,normalize:t.normalize}))}}else for(n in _)if(_.hasOwnProperty(n)&&a.e(_[n])){var z=(t=_[n]).componentDatatype;z===h.ComponentDatatype.DOUBLE&&(z=h.ComponentDatatype.FLOAT),o=void 0,a.e(t.values)&&(o=v.h.createVertexBuffer({context:r,typedArray:h.ComponentDatatype.createTypedArray(z,t.values),usage:c})),d.push({index:s[n],vertexBuffer:o,value:t.value,componentDatatype:z,componentsPerAttribute:t.componentsPerAttribute,normalize:t.normalize})}var b,D=l.indices;return a.e(D)&&(b=x.I.computeNumberOfVertices(l)>=u.e.SIXTY_FOUR_KILOBYTES&&r.elementIndexUint?v.h.createIndexBuffer({context:r,typedArray:new Uint32Array(D),usage:c,indexDatatype:p.IndexDatatype.UNSIGNED_INT}):v.h.createIndexBuffer({context:r,typedArray:new Uint16Array(D),usage:c,indexDatatype:p.IndexDatatype.UNSIGNED_SHORT})),new L({context:r,attributes:d,indexBuffer:b})},Object.defineProperties(L.prototype,{numberOfAttributes:{get:function(){return this._attributes.length}},numberOfVertices:{get:function(){return this._numberOfVertices}},indexBuffer:{get:function(){return this._indexBuffer}}}),L.prototype.getAttribute=function(e){return i.o.defined("index",e),this._attributes[e]},L.prototype._bind=function(){a.e(this._vao)?(this._context.glBindVertexArray(this._vao),this._context.instancedArrays&&function(e){var n=e._context,t=e._hasInstancedAttributes;if(t||n._previousDrawInstanced){n._previousDrawInstanced=t;var o,r=n._vertexAttribDivisors,i=e._attributes,a=_.e.maximumVertexAttributes;if(t){var l=i.length;for(o=0;o<l;++o){var c=i[o];if(c.enabled){var s=c.instanceDivisor,u=c.index;s!==r[u]&&(n.glVertexAttribDivisor(u,s),r[u]=s)}}}else for(o=0;o<a;++o)r[o]>0&&(n.glVertexAttribDivisor(o,0),r[o]=0)}}(this),this._hasConstantAttributes&&function(e,n){for(var t=e._attributes,o=t.length,r=0;r<o;++r){var i=t[r];i.enabled&&a.e(i.value)&&i.vertexAttrib(n)}}(this,this._gl)):b(this._gl,this._attributes,this._indexBuffer)},L.prototype._unBind=function(){if(a.e(this._vao))this._context.glBindVertexArray(null);else{for(var e=this._attributes,n=this._gl,t=0;t<e.length;++t){var o=e[t];o.enabled&&o.disableVertexAttribArray(n)}this._indexBuffer&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)}},L.prototype.isDestroyed=function(){return!1},L.prototype.destroy=function(){for(var e=this._attributes,n=0;n<e.length;++n){var t=e[n].vertexBuffer;a.e(t)&&!t.isDestroyed()&&t.vertexArrayDestroyable&&t.destroy()}var o=this._indexBuffer;return a.e(o)&&!o.isDestroyed()&&o.vertexArrayDestroyable&&o.destroy(),a.e(this._vao)&&this._context.glDeleteVertexArray(this._vao),v.i(this)},Object.defineProperties(D.prototype,{boundingVolume:{get:function(){return this._boundingVolume},set:function(e){this._boundingVolume!==e&&(this._boundingVolume=e,this.dirty=!0)}},orientedBoundingBox:{get:function(){return this._orientedBoundingBox},set:function(e){this._orientedBoundingBox!==e&&(this._orientedBoundingBox=e,this.dirty=!0)}},cull:{get:function(){return this._cull},set:function(e){this._cull!==e&&(this._cull=e,this.dirty=!0)}},occlude:{get:function(){return this._occlude},set:function(e){this._occlude!==e&&(this._occlude=e,this.dirty=!0)}},modelMatrix:{get:function(){return this._modelMatrix},set:function(e){this._modelMatrix!==e&&(this._modelMatrix=e,this.dirty=!0)}},primitiveType:{get:function(){return this._primitiveType},set:function(e){this._primitiveType!==e&&(this._primitiveType=e,this.dirty=!0)}},vertexArray:{get:function(){return this._vertexArray},set:function(e){this._vertexArray!==e&&(this._vertexArray=e,this.dirty=!0)}},count:{get:function(){return this._count},set:function(e){this._count!==e&&(this._count=e,this.dirty=!0)}},offset:{get:function(){return this._offset},set:function(e){this._offset!==e&&(this._offset=e,this.dirty=!0)}},instanceCount:{get:function(){return this._instanceCount},set:function(e){this._instanceCount!==e&&(this._instanceCount=e,this.dirty=!0)}},shaderProgram:{get:function(){return this._shaderProgram},set:function(e){this._shaderProgram!==e&&(this._shaderProgram=e,this.dirty=!0)}},castShadows:{get:function(){return this._castShadows},set:function(e){this._castShadows!==e&&(this._castShadows=e,this.dirty=!0)}},selectCastShadows:{get:function(){return this._selectCastShadows},set:function(e){this._selectCastShadows!==e&&(this._selectCastShadows=e,this.dirty=!0)}},receiveShadows:{get:function(){return this._receiveShadows},set:function(e){this._receiveShadows!==e&&(this._receiveShadows=e,this.dirty=!0)}},uniformMap:{get:function(){return this._uniformMap},set:function(e){this._uniformMap!==e&&(this._uniformMap=e,this.dirty=!0)}},renderState:{get:function(){return this._renderState},set:function(e){this._renderState!==e&&(this._renderState=e,this.dirty=!0)}},framebuffer:{get:function(){return this._framebuffer},set:function(e){this._framebuffer!==e&&(this._framebuffer=e,this.dirty=!0)}},pass:{get:function(){return this._pass},set:function(e){this._pass!==e&&(this._pass=e,this.dirty=!0)}},executeInClosestFrustum:{get:function(){return this._executeInClosestFrustum},set:function(e){this._executeInClosestFrustum!==e&&(this._executeInClosestFrustum=e,this.dirty=!0)}},owner:{get:function(){return this._owner},set:function(e){this._owner!==e&&(this._owner=e,this.dirty=!0)}},debugShowBoundingVolume:{get:function(){return this._debugShowBoundingVolume},set:function(e){this._debugShowBoundingVolume!==e&&(this._debugShowBoundingVolume=e,this.dirty=!0)}},debugOverlappingFrustums:{get:function(){return this._debugOverlappingFrustums},set:function(e){this._debugOverlappingFrustums!==e&&(this._debugOverlappingFrustums=e,this.dirty=!0)}},pickId:{get:function(){return this._pickId},set:function(e){this._pickId!==e&&(this._pickId=e,this.dirty=!0)}},pickOnly:{get:function(){return this._pickOnly},set:function(e){this._pickOnly!==e&&(this._pickOnly=e,this.dirty=!0)}}}),D.prototype.addUniformBuffer=function(e){e.increaseRef(),this._uniformBuffers.push(e)},D.prototype.removeAllUniformBuffer=function(){if(a.e(this._uniformBuffers)){for(var e=0;e<this._uniformBuffers.length;e++)this._uniformBuffers[e].decreaseRef();this._uniformBuffers=[]}},D.shallowClone=function(e,n){if(a.e(e))return a.e(n)||(n=new D),n._boundingVolume=e._boundingVolume,n._orientedBoundingBox=e._orientedBoundingBox,n._cull=e._cull,n._occlude=e._occlude,n._modelMatrix=e._modelMatrix,n._primitiveType=e._primitiveType,n._vertexArray=e._vertexArray,n._count=e._count,n._offset=e._offset,n._instanceCount=e._instanceCount,n._shaderProgram=e._shaderProgram,n._uniformMap=e._uniformMap,n._uniformBuffers=e._uniformBuffers,n._renderState=e._renderState,n._framebuffer=e._framebuffer,n._pass=e._pass,n._executeInClosestFrustum=e._executeInClosestFrustum,n._owner=e._owner,n._debugShowBoundingVolume=e._debugShowBoundingVolume,n._debugOverlappingFrustums=e._debugOverlappingFrustums,n._castShadows=e._castShadows,n._receiveShadows=e._receiveShadows,n._selectCastShadows=e._selectCastShadows,n._pickId=e._pickId,n._pickOnly=e._pickOnly,n._pointCloudEyeDomeLighting=e._pointCloudEyeDomeLighting,n.dirty=!0,n.lastDirtyTime=0,n},D.prototype.execute=function(e,n){e.draw(this,n)};var I=new o.t;function P(e){this._size=e.size,this._datatype=e.datatype,this.getValue=e.getValue}var O={};O[C.B.FLOAT]="float",O[C.B.FLOAT_VEC2]="vec2",O[C.B.FLOAT_VEC3]="vec3",O[C.B.FLOAT_VEC4]="vec4",O[C.B.INT]="int",O[C.B.INT_VEC2]="ivec2",O[C.B.INT_VEC3]="ivec3",O[C.B.INT_VEC4]="ivec4",O[C.B.BOOL]="bool",O[C.B.BOOL_VEC2]="bvec2",O[C.B.BOOL_VEC3]="bvec3",O[C.B.BOOL_VEC4]="bvec4",O[C.B.FLOAT_MAT2]="mat2",O[C.B.FLOAT_MAT3]="mat3",O[C.B.FLOAT_MAT4]="mat4",O[C.B.SAMPLER_2D]="sampler2D",O[C.B.SAMPLER_CUBE]="samplerCube",P.prototype.getDeclaration=function(e){var n="uniform "+O[this._datatype]+" "+e,t=this._size;return n+=1===t?";":"["+t.toString()+"];"};var R={czm_viewport:new P({size:1,datatype:C.B.FLOAT_VEC4,getValue:function(e){return e.viewportCartesian4}}),czm_viewportOrthographic:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.viewportOrthographic}}),czm_viewportTransformation:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.viewportTransformation}}),czm_globeDepthTexture:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.globeDepthTexture}}),czm_model:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.model}}),czm_inverseModel:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseModel}}),czm_view:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.view}}),czm_view3D:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.view3D}}),czm_viewRotation:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.viewRotation}}),czm_viewRotation3D:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.viewRotation3D}}),czm_inverseView:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseView}}),czm_inverseView3D:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseView3D}}),czm_inverseViewRotation:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.inverseViewRotation}}),czm_inverseViewRotation3D:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.inverseViewRotation3D}}),czm_projection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.projection}}),czm_inverseProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseProjection}}),czm_infiniteProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.infiniteProjection}}),czm_modelView:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelView}}),czm_modelView3D:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelView3D}}),czm_modelViewRelativeToEye:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelViewRelativeToEye}}),czm_inverseModelView:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseModelView}}),czm_inverseModelView3D:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseModelView3D}}),czm_viewProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.viewProjection}}),czm_inverseViewProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseViewProjection}}),czm_modelViewProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelViewProjection}}),czm_inverseModelViewProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.inverseModelViewProjection}}),czm_modelViewProjectionRelativeToEye:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelViewProjectionRelativeToEye}}),czm_modelViewInfiniteProjection:new P({size:1,datatype:C.B.FLOAT_MAT4,getValue:function(e){return e.modelViewInfiniteProjection}}),czm_orthographicIn3D:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.orthographicIn3D?1:0}}),czm_normal:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.normal}}),czm_normal3D:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.normal3D}}),czm_inverseNormal:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.inverseNormal}}),czm_inverseNormal3D:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.inverseNormal3D}}),czm_eyeHeight2D:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.eyeHeight2D}}),czm_entireFrustum:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.entireFrustum}}),czm_currentFrustum:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.currentFrustum}}),czm_frustumPlanes:new P({size:1,datatype:C.B.FLOAT_VEC4,getValue:function(e){return e.frustumPlanes}}),czm_farDepthFromNearPlusOne:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.farDepthFromNearPlusOne}}),czm_log2FarDepthFromNearPlusOne:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.log2FarDepthFromNearPlusOne}}),czm_oneOverLog2FarDepthFromNearPlusOne:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.oneOverLog2FarDepthFromNearPlusOne}}),czm_sunPositionWC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sunPositionWC}}),czm_sunPositionColumbusView:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sunPositionColumbusView}}),czm_sunDirectionEC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sunDirectionEC}}),czm_sunDirectionWC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sunDirectionWC}}),czm_moonDirectionEC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.moonDirectionEC}}),czm_lightDirectionEC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.lightDirectionEC}}),czm_lightDirectionWC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.lightDirectionWC}}),czm_lightColor:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.lightColor}}),czm_lightColorHdr:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.lightColorHdr}}),czm_encodedCameraPositionMCHigh:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.encodedCameraPositionMCHigh}}),czm_encodedCameraPositionMCLow:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.encodedCameraPositionMCLow}}),czm_cameraPositionWC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e._cameraPosition}}),czm_viewerPositionWC:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return f.y.getTranslation(e.inverseView,I)}}),czm_frameNumber:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.frameState.frameNumber}}),czm_morphTime:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.frameState.morphTime}}),czm_sceneMode:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.frameState.mode}}),czm_pass:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.pass}}),czm_backgroundColor:new P({size:1,datatype:C.B.FLOAT_VEC4,getValue:function(e){return e.backgroundColor}}),czm_brdfLut:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.brdfLut}}),czm_environmentMap:new P({size:1,datatype:C.B.SAMPLER_CUBE,getValue:function(e){return e.environmentMap}}),czm_specularEnvironmentMaps:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.specularEnvironmentMaps}}),czm_specularEnvironmentMapSize:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.specularEnvironmentMapsDimensions}}),czm_specularEnvironmentMapsMaximumLOD:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.specularEnvironmentMapsMaximumLOD}}),czm_sphericalHarmonicCoefficients:new P({size:9,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sphericalHarmonicCoefficients}}),czm_SH:new P({size:7,datatype:C.B.FLOAT_VEC4,getValue:function(e){return e.sphericalHarmonics.shArr}}),czm_temeToPseudoFixed:new P({size:1,datatype:C.B.FLOAT_MAT3,getValue:function(e){return e.temeToPseudoFixedMatrix}}),czm_pixelRatio:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.pixelRatio}}),czm_resolutionScale:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.resolutionScale}}),czm_fogDensity:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.fogDensity}}),czm_imagerySplitPosition:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.imagerySplitPosition}}),czm_globeSplitPosition:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.globeSplitPosition}}),czm_geometricToleranceOverMeter:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.geometricToleranceOverMeter}}),czm_minimumDisableDepthTestDistance:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.minimumDisableDepthTestDistance}}),czm_invertClassificationColor:new P({size:1,datatype:C.B.FLOAT_VEC4,getValue:function(e){return e.invertClassificationColor}}),czm_gamma:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.gamma}}),czm_sunColor:new P({size:1,datatype:C.B.FLOAT_VEC3,getValue:function(e){return e.sunColor}}),czm_globeDepthTextureDim:new P({size:1,datatype:C.B.FLOAT_VEC2,getValue:function(e){return e.globeDepthTextureDim}}),czm_nonSelDepthTexture:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.nonSelDepthTexture}}),czm_maskTexture:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.maskTexture}}),czm_hdrEnvMap:new P({size:1,datatype:C.B.SAMPLER_2D,getValue:function(e){return e.hdrEnvMap}}),czm_toneMappingExposure:new P({size:1,datatype:C.B.FLOAT,getValue:function(e){return e.toneMappingExposure}})};function F(e){}function B(e){this.ifIndex=a.e(e.ifIndex)?e.ifIndex:void 0,this.elseIndex=a.e(e.elseIndex)?e.elseIndex:void 0,this.endIndex=a.e(e.endIndex)?e.endIndex:void 0,this.ifChildTokens=[],this.elseChildTokens=[],this.parentToken=a.e(e.parentToken)?e.parentToken:void 0,this.type=a.e(e.type)?e.type:void 0}function N(e,n){this.Key=e,this.String=n,this.StringLength=n.length}F.removeUnuseMacroCode=function(e,n,t){if(!function(e){return!(e.indexOf("defined",0)>=0||e.indexOf("#if ",0)>=0||e.indexOf("#elif ",0)>=0)}(t))return t;var o=function(e){for(var n=[],t=0,o=0,r=void 0;-1!==t;){var i=U(e,o);if(o=(t=i.findIndex)+i.type.StringLength,-1===t)break;switch(i.type.Key){case H.TK_IFDEF.Key:case H.TK_IFNEF.Key:var l=new B({type:i.type,ifIndex:t});a.e(r)?a.e(r.endIndex)?(a.e(r.parentToken)||n.push(l),r=l):(r.addChildToken(l),l.parentToken=r,r=l):(r=l,n.push(l));break;case H.TK_ELSE.Key:if(!a.e(r))continue;r.elseIndex=t;break;case H.TK_END.Key:if(!a.e(r))continue;r.endIndex=t,a.e(r.parentToken)&&(r=r.parentToken)}}return n}(t),r=[];return function(e,n,t,o,r){if(0!==t.length)for(var i=function(e,n,t){var o=n.defines,r={};if(a.e(o))for(var i=0;i<o.length;++i){r[o[i]]=1}if(a.e(e._sysShaderDefines))for(i=0;i<e._sysShaderDefines.length;++i){r[e._sysShaderDefines[i]]=1}for(var l=0,c=0;-1!==l&&-1!==(l=t.indexOf("#define ",c));){var s=l+8,u=t.indexOf("\n",l);r[t.substring(s,u).trim()]=1,c=u}return r}(e,n,o),l=0;l<t.length;l++){k(t[l],i,o,r)}}(e,n,o,t,r),function(e,n){for(var t=e,o=0;o<n.length;o++){var r=n[o];if(r.endIndex-r.startIndex>1){var i=e.substring(r.startIndex,r.endIndex);t=t.replace(i,"")}}return t.replace(/(#ifdef|#ifndef|#else|#endif).*/gm,"")}(t,r)},B.prototype.addChildToken=function(e){a.e(this.elseIndex)?this.elseChildTokens.push(e):this.ifChildTokens.push(e)},N.isEqual=function(e,n){return e.Key===n.Key};var H={TK_IFDEF:new N(0,"#ifdef"),TK_IFNEF:new N(1,"#ifndef"),TK_ELSE:new N(2,"#else"),TK_END:new N(3,"#endif")};function U(e,n){var t=-1,o=H.TK_IFDEF;for(var r in H){var i=H[r],a=e.indexOf(i.String,n);(-1===t||a>=0&&a<t)&&(t=a,o=i)}return{type:o,findIndex:t}}function k(e,n,t,o){var r=0,i=function(e,n,t){var o=e.indexOf("\n",t+n+1),r=t+n+1;return e.substring(r,o)}(t,e.type.StringLength,e.ifIndex),l=function(e,n,t){return!(!N.isEqual(t,H.TK_IFDEF)||!a.e(e[n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")]))||!(!N.isEqual(t,H.TK_IFNEF)||a.e(e[n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")]))}(n,i,e.type);if(l){a.e(e.elseIndex)&&(r=e.elseIndex+H.TK_ELSE.StringLength+1,o.push({startIndex:r,endIndex:e.endIndex}));for(var c=0;c<e.ifChildTokens.length;c++)k(e.ifChildTokens[c],n,t,o)}else{a.e(e.elseIndex)?o.push({startIndex:e.ifIndex+e.type.StringLength+G(t,e.ifIndex,e.type.String)+i.length,endIndex:e.elseIndex}):o.push({startIndex:e.ifIndex,endIndex:e.endIndex+H.TK_END.StringLength});for(c=0;c<e.elseChildTokens.length;c++)k(e.elseChildTokens[c],n,t,o)}}function G(e,n,t){for(var o=t.length,r=n+o;r<e.length;r++){if(" "!==e.charAt(r))break}return r-(n+o)}var W={czm_degreesPerRadian:"const float czm_degreesPerRadian = 57.29577951308232;\n",czm_depthRange:"const czm_depthRangeStruct czm_depthRange = czm_depthRangeStruct(0.0, 1.0);\n",czm_ellipsoidInverseRadii:"const vec3 czm_ellipsoidInverseRadii = vec3(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.314245);\n",czm_ellipsoidRadii:"const vec3 czm_ellipsoidRadii = vec3(6378137.0, 6378137.0, 6356752.314245);\n",czm_epsilon1:"const float czm_epsilon1 = 0.1;\n",czm_epsilon2:"const float czm_epsilon2 = 0.01;\n",czm_epsilon3:"const float czm_epsilon3 = 0.001;\n",czm_epsilon4:"const float czm_epsilon4 = 0.0001;\n",czm_epsilon5:"const float czm_epsilon5 = 0.00001;\n",czm_epsilon6:"const float czm_epsilon6 = 0.000001;\n",czm_epsilon7:"const float czm_epsilon7 = 0.0000001;\n",czm_infinity:"const float czm_infinity = 5906376272000.0;\n",czm_oneOverPi:"const float czm_oneOverPi = 0.3183098861837907;\n",czm_oneOverTwoPi:"const float czm_oneOverTwoPi = 0.15915494309189535;\n",czm_passCesium3DTile:"const float czm_passCesium3DTile = 4.0;\n",czm_passCesium3DTileClassification:"const float czm_passCesium3DTileClassification = 5.0;\n",czm_passCesium3DTileClassificationIgnoreShow:"const float czm_passCesium3DTileClassificationIgnoreShow = 6.0;\n",czm_passClassification:"const float czm_passClassification = 7.0;\n",czm_passCompute:"const float czm_passCompute = 1.0;\n",czm_passEnvironment:"const float czm_passEnvironment = 0.0;\n",czm_passGlobe:"const float czm_passGlobe = 2.0;\n",czm_passGround:"const float czm_passGround = 4.0;\n",czm_passOpaque:"const float czm_passOpaque = 12.0;\n",czm_passOverlay:"const float czm_passOverlay = 20.0;\n",czm_passTerrainClassification:"const float czm_passTerrainClassification = 3.0;\n",czm_passTranslucent:"const float czm_passTranslucent = 18.0;\n",czm_pi:"const float czm_pi = 3.141592653589793;\n",czm_piOverFour:"const float czm_piOverFour = 0.7853981633974483;\n",czm_piOverSix:"const float czm_piOverSix = 0.5235987755982988;\n",czm_piOverThree:"const float czm_piOverThree = 1.0471975511965976;\n",czm_piOverTwo:"const float czm_piOverTwo = 1.5707963267948966;\n",czm_radiansPerDegree:"const float czm_radiansPerDegree = 0.017453292519943295;\n",czm_sceneMode2D:"const float czm_sceneMode2D = 2.0;\n",czm_sceneMode3D:"const float czm_sceneMode3D = 3.0;\n",czm_sceneModeColumbusView:"const float czm_sceneModeColumbusView = 1.0;\n",czm_sceneModeMorphing:"const float czm_sceneModeMorphing = 0.0;\n",czm_solarRadius:"const float czm_solarRadius = 695500000.0;\n",czm_threePiOver2:"const float czm_threePiOver2 = 4.71238898038469;\n",czm_twoPi:"const float czm_twoPi = 6.283185307179586;\n",czm_webMercatorMaxLatitude:"const float czm_webMercatorMaxLatitude = 1.4844222297453324;\n",czm_depthRangeStruct:"struct czm_depthRangeStruct\n{\nfloat near;\nfloat far;\n};\n",czm_ellipsoid:"struct czm_ellipsoid\n{\nvec3 center;\nvec3 radii;\nvec3 inverseRadii;\nvec3 inverseRadiiSquared;\n};\n",czm_material:"struct czm_material\n{\nvec3 diffuse;\nfloat specular;\nfloat shininess;\nvec3 normal;\nvec3 emission;\nfloat alpha;\n};\n",czm_materialInput:"struct czm_materialInput\n{\nfloat s;\nvec2 st;\nvec3 str;\nvec3 normalEC;\nmat3 tangentToEyeMatrix;\nvec3 positionToEyeEC;\nfloat height;\nfloat slope;\n};\n",czm_ray:"struct czm_ray\n{\nvec3 origin;\nvec3 direction;\n};\n",czm_raySegment:"struct czm_raySegment\n{\nfloat start;\nfloat stop;\n};\nconst czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);\nconst czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);\n",czm_s3mMaterialInput:"struct czm_s3mMaterialInput\n{\nvec4 ambientColor;\nvec4 diffuseColor;\nvec4 ambientLightColor;\nvec4 sunLightColor;\nmat4 texMatrix;\nfloat texture0Width;\nfloat texture1Width;\nvec3 sunDirectionEC;\nfloat sunLightON;\nvec3 normalWorld;\nvec3 normalGround;\nvec3 positionWorld;\nvec3 sunDirectionWC;\nvec4 surfaceAlbedo;\n};\n",czm_shadowParameters:"struct czm_shadowParameters\n{\n#ifdef USE_CUBE_MAP_SHADOW\nvec3 texCoords;\n#else\nvec2 texCoords;\n#endif\nfloat depthBias;\nfloat depth;\nfloat nDotL;\nvec2 texelStepSize;\nfloat normalShadingSmooth;\nfloat darkness;\n};\n",czm_acesTonemapping:"vec3 czm_acesTonemapping(vec3 color) {\nfloat g = 0.985;\nfloat a = 0.065;\nfloat b = 0.0001;\nfloat c = 0.433;\nfloat d = 0.238;\ncolor = (color * (color + a) - b) / (color * (g * color + c) + d);\ncolor = clamp(color, 0.0, 1.0);\nreturn color;\n}\n",czm_adjustColor:"uniform float uBrightness;\nuniform float uContrast;\nuniform float uHue;\nuniform float uSaturation;\nuniform float uOneOverGamma;\nvec3 czm_adjustColor(vec3 inputColor)\n{\nvec3 outputColor = inputColor;\noutputColor.rgb = mix(vec3(0.0), outputColor.rgb, uBrightness);\noutputColor.rgb = mix(vec3(0.5), outputColor.rgb, uContrast);\noutputColor.rgb = czm_hue(outputColor.rgb, uHue);\noutputColor.rgb = clamp(outputColor.rgb, 0.0, 1.0);\noutputColor.rgb = czm_saturation(outputColor.rgb, uSaturation);\noutputColor.rgb = pow(outputColor.rgb, vec3(uOneOverGamma));\nreturn outputColor;\n}\n",czm_alphaWeight:"float czm_alphaWeight(float a)\n{\nfloat z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\nreturn pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 0.003 / (1e-5 + pow(abs(z) / 200.0, 4.0))));\n}\n",czm_antialias:"vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)\n{\nfloat val1 = clamp(dist / fuzzFactor, 0.0, 1.0);\nfloat val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);\nval1 = val1 * (1.0 - val2);\nval1 = val1 * val1 * (3.0 - (2.0 * val1));\nval1 = pow(val1, 0.5);\nvec4 midColor = (color1 + color2) * 0.5;\nreturn mix(midColor, currentColor, val1);\n}\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)\n{\nreturn czm_antialias(color1, color2, currentColor, dist, 0.1);\n}\n",czm_approximateSphericalCoordinates:"vec2 czm_approximateSphericalCoordinates(vec3 normal) {\nfloat latitudeApproximation = czm_fastApproximateAtan(sqrt(normal.x * normal.x + normal.y * normal.y), normal.z);\nfloat longitudeApproximation = czm_fastApproximateAtan(normal.x, normal.y);\nreturn vec2(latitudeApproximation, longitudeApproximation);\n}\n",czm_branchFreeTernary:"float czm_branchFreeTernary(bool comparison, float a, float b) {\nfloat useA = float(comparison);\nreturn a * useA + b * (1.0 - useA);\n}\nvec2 czm_branchFreeTernary(bool comparison, vec2 a, vec2 b) {\nfloat useA = float(comparison);\nreturn a * useA + b * (1.0 - useA);\n}\nvec3 czm_branchFreeTernary(bool comparison, vec3 a, vec3 b) {\nfloat useA = float(comparison);\nreturn a * useA + b * (1.0 - useA);\n}\nvec4 czm_branchFreeTernary(bool comparison, vec4 a, vec4 b) {\nfloat useA = float(comparison);\nreturn a * useA + b * (1.0 - useA);\n}\n",czm_cascadeColor:"vec4 czm_cascadeColor(vec4 weights)\n{\nreturn vec4(1.0, 0.0, 0.0, 1.0) * weights.x +\nvec4(0.0, 1.0, 0.0, 1.0) * weights.y +\nvec4(0.0, 0.0, 1.0, 1.0) * weights.z +\nvec4(1.0, 0.0, 1.0, 1.0) * weights.w;\n}\n",czm_cascadeDistance:"uniform vec4 shadowMap_cascadeDistances;\nfloat czm_cascadeDistance(vec4 weights)\n{\nreturn dot(shadowMap_cascadeDistances, weights);\n}\n",czm_cascadeMatrix:"uniform mat4 shadowMap_cascadeMatrices[4];\nmat4 czm_cascadeMatrix(vec4 weights)\n{\nreturn shadowMap_cascadeMatrices[0] * weights.x +\nshadowMap_cascadeMatrices[1] * weights.y +\nshadowMap_cascadeMatrices[2] * weights.z +\nshadowMap_cascadeMatrices[3] * weights.w;\n}\n",czm_cascadeWeights:"uniform vec4 shadowMap_cascadeSplits[2];\nvec4 czm_cascadeWeights(float depthEye)\n{\nvec4 near = step(shadowMap_cascadeSplits[0], vec4(depthEye));\nvec4 far = step(depthEye, shadowMap_cascadeSplits[1]);\nreturn near * far;\n}\n",czm_clip:"#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\nuniform float clip_mode;\nuniform vec4 clip_planes[6];\nuniform vec4 clip_line_color;\nconst float clip_lineWidth = 3.0;\nfloat GetClipDistance(vec3 pos, vec3 planeNormal, float disToOrigin)\n{\nreturn dot(planeNormal, pos) + disToOrigin;\n}\nfloat ClipBehindAllPlane(float fBorderWidth, vec4 clip_vertex)\n{\nfloat distance = 0.0;\nfloat result = -1.0;\n#ifdef CLIPPLANE\ndistance = GetClipDistance(clip_vertex.xyz, clip_planes[0].xyz, clip_planes[0].w);\nif (distance < 0.0)\n{\nreturn 1.0;\n}\nelse if (distance < fBorderWidth)\n{\nresult = 0.0;\n}\n#else\nfor(int i = 0; i < 6; i++)\n{\ndistance = GetClipDistance(clip_vertex.xyz, clip_planes[i].xyz, clip_planes[i].w);\nif(distance < 0.0)\n{\nreturn 1.0;\n}\nelse if(distance < fBorderWidth)\n{\nresult = 0.0;\n}\n}\n#endif\nreturn result;\n}\nfloat ClipBehindAnyPlane(float fBorderWidth, vec4 clip_vertex)\n{\nfloat result = 1.0;\nfor(int i = 0; i < 6; i++)\n{\nfloat distance = GetClipDistance(clip_vertex.xyz, clip_planes[i].xyz, clip_planes[i].w);\nif((distance + fBorderWidth) < 0.0)\n{\nreturn -1.0;\n}\nelse if(distance < 0.0)\n{\nresult = 0.0;\n}\n}\nreturn result;\n}\nfloat ClipAnythingButLine(float fBorderWidth, vec4 clip_vertex)\n{\nfloat result = -1.0;\nfor(int i = 0; i < 6; i++)\n{\nfloat distance = GetClipDistance(clip_vertex.xyz, clip_planes[i].xyz, clip_planes[i].w);\nif(distance < 0.0)\n{\nreturn -1.0;\n}\nelse if(distance < fBorderWidth)\n{\nresult = 0.0;\n}\n}\nreturn result;\n}\nvec4 czm_clip(vec4 clip_vertex, float fIsFiltByID)\n{\nif(fIsFiltByID < 0.1)\n{\nreturn vec4(1.0);\n}\nif(clip_mode < 0.5)\n{\nreturn vec4(1.0);\n}\n#ifdef GL_OES_standard_derivatives\nfloat dxc = abs(dFdx(clip_vertex.x));\nfloat dyc = abs(dFdy(clip_vertex.y));\nfloat fBorderWidth = max(dxc, dyc) * clip_lineWidth;\n#else\nfloat fBorderWidth = clip_lineWidth;\n#endif\nfloat clipResult = 1.0;\nif(clip_line_color.a < 0.01)\n{\nfBorderWidth = 0.0;\n}\nif(clip_mode < 1.5)\n{\nclipResult = ClipBehindAnyPlane(fBorderWidth, clip_vertex);\n}\nelse if(clip_mode < 2.5)\n{\nclipResult = ClipBehindAllPlane(fBorderWidth, clip_vertex);\n}\nelse if(clip_mode < 3.5)\n{\nclipResult = ClipAnythingButLine(fBorderWidth, clip_vertex);\n}\nif(clipResult < -0.5)\n{\ndiscard;\n}\nelse if(clipResult < 0.5)\n{\nreturn clip_line_color;\n}\nelse\n{\nreturn vec4(1.0);\n}\n}\n",czm_columbusViewMorph:"vec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)\n{\nvec3 p = mix(position2D.xyz, position3D.xyz, time);\nreturn vec4(p, 1.0);\n}\n",czm_computeLightColorInFP:"vec4 czm_computeLightColorInFP(czm_s3mMaterialInput material, vec3 positionMC, float hasNormal, vec3 normal)\n{\nvec3 normalEC;\n#ifdef HAS_NORMAL\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\nnormalEC = normalize(normal) * faceDirection;\n#else\nnormalEC = normalize(czm_normal*czm_computeNormal(positionMC));\n#endif\nvec3 positionEC = vec3(czm_modelView * vec4(positionMC,1.0)).xyz;\nreturn czm_directionLight(material, normalEC, -positionEC, positionMC);\n}\n",czm_computeLightColorInstanceInFP:"vec4 czm_computeLightColorInstanceInFP(czm_s3mMaterialInput material, vec3 positionRotateMC, vec3 positionMC, float hasNormal, vec3 normal)\n{\nvec3 normalEC;\n#ifdef HAS_NORMAL\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\nnormalEC = normalize(normal) * faceDirection;\n#else\nnormalEC = normalize(czm_normal*czm_computeNormal(positionRotateMC));\n#endif\nvec3 positionEC = vec3(czm_modelView * vec4(positionMC,1.0)).xyz;\nreturn czm_directionLight(material, normalEC, -positionEC, positionMC);\n}\n",czm_computeNormal:"#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\nvec3 czm_computeNormal(in vec3 oriVertex)\n{\nvec3 normal = cross(vec3(dFdx(oriVertex.x), dFdx(oriVertex.y), dFdx(oriVertex.z)), vec3(dFdy(oriVertex.x), dFdy(oriVertex.y), dFdy(oriVertex.z)));\nnormal = normalize(normal);\nreturn normal;\n}\n",czm_computePosition:"vec4 czm_computePosition();\n",czm_cosineAndSine:"vec2 cordic(float angle)\n{\nvec2 vector = vec2(6.0725293500888267e-1, 0.0);\nfloat sense = (angle < 0.0) ? -1.0 : 1.0;\nmat2 rotation = mat2(1.0, sense, -sense, 1.0);\nvector = rotation * vector;\nangle -= sense * 7.8539816339744828e-1;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfloat factor = sense * 5.0e-1;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 4.6364760900080609e-1;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 2.5e-1;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 2.4497866312686414e-1;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 1.25e-1;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 1.2435499454676144e-1;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 6.25e-2;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 6.2418809995957350e-2;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 3.125e-2;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 3.1239833430268277e-2;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 1.5625e-2;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 1.5623728620476831e-2;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 7.8125e-3;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 7.8123410601011111e-3;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 3.90625e-3;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 3.9062301319669718e-3;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 1.953125e-3;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 1.9531225164788188e-3;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 9.765625e-4;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 9.7656218955931946e-4;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 4.8828125e-4;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 4.8828121119489829e-4;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 2.44140625e-4;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 2.4414062014936177e-4;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 1.220703125e-4;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 1.2207031189367021e-4;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 6.103515625e-5;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 6.1035156174208773e-5;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 3.0517578125e-5;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 3.0517578115526096e-5;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 1.52587890625e-5;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 1.5258789061315762e-5;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 7.62939453125e-6;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 7.6293945311019700e-6;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 3.814697265625e-6;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 3.8146972656064961e-6;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 1.9073486328125e-6;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 1.9073486328101870e-6;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 9.5367431640625e-7;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 9.5367431640596084e-7;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 4.76837158203125e-7;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 4.7683715820308884e-7;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 2.384185791015625e-7;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nangle -= sense * 2.3841857910155797e-7;\nsense = (angle < 0.0) ? -1.0 : 1.0;\nfactor = sense * 1.1920928955078125e-7;\nrotation[0][1] = factor;\nrotation[1][0] = -factor;\nvector = rotation * vector;\nreturn vector;\n}\nvec2 czm_cosineAndSine(float angle)\n{\nif (angle < -czm_piOverTwo || angle > czm_piOverTwo)\n{\nif (angle < 0.0)\n{\nreturn -cordic(angle + czm_pi);\n}\nelse\n{\nreturn -cordic(angle - czm_pi);\n}\n}\nelse\n{\nreturn cordic(angle);\n}\n}\n",czm_decompressTextureCoordinates:"vec2 czm_decompressTextureCoordinates(float encoded)\n{\nfloat temp = encoded / 4096.0;\nfloat xZeroTo4095 = floor(temp);\nfloat stx = xZeroTo4095 / 4095.0;\nfloat sty = (encoded - xZeroTo4095 * 4096.0) / 4095.0;\nreturn vec2(stx, sty);\n}\n",czm_depthClampFarPlane:"#ifndef LOG_DEPTH\nvarying float v_WindowZ;\n#endif\nvec4 czm_depthClampFarPlane(vec4 coords)\n{\n#ifndef LOG_DEPTH\nv_WindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;\ncoords.z = min(coords.z, coords.w);\n#endif\nreturn coords;\n}\n",czm_directionLight:"const vec3 SideLightColor = vec3(0.0);\nuniform vec4 uSpecularColor;\nuniform float uShininess;\nconst vec3 specular = vec3(0.066666);\nconst float shininess2 = 30.0;\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\nif ( decayExponent > 0.0 ) {\nreturn pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n}\nreturn 1.0;\n}\n#if POINT_LIGHTS > 0\nuniform vec3 uPointLightPositionEC[POINT_LIGHTS];\nuniform vec3 uPointLightColor[POINT_LIGHTS];\nuniform vec2 uPointLightDistanceAndDecay[POINT_LIGHTS];\n#endif\n#if SPOT_LIGHTS > 0\nuniform vec3 uSpotLightPosition[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightColor[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightPositionEC[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightDirection[ SPOT_LIGHTS ];\nuniform float uSpotLightExponent[ SPOT_LIGHTS ];\nuniform vec4 uSpotLightDistanceDecayCosPenumbra[ SPOT_LIGHTS ];\n#endif\n#if DIR_LIGHTS > 0\nuniform vec3 uDirectionalLightDirection[ DIR_LIGHTS ];\nuniform vec3 uDirectionalLightColor[ DIR_LIGHTS];\n#endif\n#if HEMISPHERE_LIGHTS > 0\nuniform vec3 uSkyColor[ HEMISPHERE_LIGHTS ];\nuniform vec3 uGroundColor[ HEMISPHERE_LIGHTS];\n#endif\nvec3 calcAmbientIrradiance(vec3 normal) {\nvec3 SH0 = czm_SH[0].xyz;\nvec4 SH_R1 = czm_SH[1];\nvec4 SH_G1 = czm_SH[2];\nvec4 SH_B1 = czm_SH[3];\nvec4 SH_R2 = czm_SH[4];\nvec4 SH_G2 = czm_SH[5];\nvec4 SH_B2 = czm_SH[6];\nvec3 ambientLight = 0.282095 * SH0;\nvec4 sh1 = vec4(\n0.488603 * normal.x,\n0.488603 * normal.z,\n0.488603 * normal.y,\n1.092548 * normal.x * normal.y\n);\nvec4 sh2 = vec4(\n1.092548 * normal.y * normal.z,\n0.315392 * (3.0 * normal.z * normal.z - 1.0),\n1.092548 * normal.x * normal.z,\n0.546274 * (normal.x * normal.x - normal.y * normal.y)\n);\nambientLight += vec3(\ndot(SH_R1, sh1),\ndot(SH_G1, sh1),\ndot(SH_B1, sh1)\n);\nambientLight += vec3(\ndot(SH_R2, sh2),\ndot(SH_G2, sh2),\ndot(SH_B2, sh2)\n);\nreturn ambientLight;\n}\nconst float ambientBoostFactor = 0.4;\nconst float lightingGlobalFactor = 0.0000342739;\nconst float fillLightIntensity = 0.25;\nconst vec3 GROUND_REFLECTANCE = vec3(0.2);\nvec3 evaluateAdditionalLighting(vec3 posWorld, vec3 mainLightDirection, vec3 mainLightIntensity) {\nfloat vndl = dot(normalize(posWorld), mainLightDirection);\nfloat additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl * 2.0, 0.0, 1.0));\nreturn additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;\n}\nvec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG) {\nreturn ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;\n}\nvec3 calcFinalIrradiance(float NdotL, vec3 normalWorld, vec3 normalGround, vec3 positionWC, vec3 lightDirWC, vec3 mainLightIntensity, vec3 ambientLightIrradiance, vec3 surfaceAlbedo, float shadow) {\nfloat NdotNG = clamp(dot(normalWorld, normalGround), -1.0, 1.0);\nvec3 ng = normalGround;\nvec3 ambientDir = vec3(5.0 * ng[1] - ng[0] * ng[2], -5.0 * ng[0] - ng[2] * ng[1], ng[1] * ng[1] + ng[0] * ng[0]);\nambientDir = ambientDir != vec3(0.0) ? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\nfloat NdotAmbDir = abs(dot(normalWorld, ambientDir));\nvec3 additionalLight = evaluateAdditionalLighting(positionWC, lightDirWC, mainLightIntensity);\nvec3 mainLightIrradiance = NdotL * mainLightIntensity * shadow;\nvec3 fillLightIrradiance = NdotAmbDir * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = ambientLightIrradiance + additionalLight;\nvec3 skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradiance + fillLightIrradiance;\nvec3 groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradiance + fillLightIrradiance;\nvec3 diffuseContribution = evaluateDiffuseIlluminationHemisphere(groundIrradianceToSurface, skyIrradianceToSurface, NdotNG);\nvec3 finalIrradiance = surfaceAlbedo.rgb * diffuseContribution * 0.31830988618;\nreturn finalIrradiance;\n}\nvec3 diffuseBRDF_Lambertian(vec3 diffuseColor) {\nreturn diffuseColor * 0.31830988618;\n}\nvec4 czm_directionLight(czm_s3mMaterialInput material, vec3 normalEC, vec3 positionToEyeEC, vec3 positionMC)\n{\nvec3 totalDiffuseLight = vec3(0.0);\nvec3 totalSpecularLight = vec3(0.0);\nfloat dotNL = saturate(dot(normalEC, material.sunDirectionEC));\nvec3 normalWorld = material.normalWorld;\nvec3 normalGround = material.normalGround;\nvec3 positionWorld = material.positionWorld;\nvec3 lightDirWC = material.sunDirectionWC;\nvec3 sunLightColor = material.sunLightColor.rgb;\nvec4 surfaceAlbedo = material.surfaceAlbedo;\nfloat shadow = 1.0;\nvec3 ambientLightIrradiance = calcAmbientIrradiance(normalWorld);\nvec3 finalIrradiance = calcFinalIrradiance(dotNL, normalWorld, normalGround, positionWorld, lightDirWC, sunLightColor, ambientLightIrradiance, surfaceAlbedo.rgb, shadow);\nvec3 positionToEyeECDir = normalize(positionToEyeEC);\n#if HEMISPHERE_LIGHTS > 0\nfor ( int i = 0; i < HEMISPHERE_LIGHTS; i ++ )\n{\nvec3 dirVectorEC = normalize(czm_normal * vec3(0.0, 0.0, 1.0));\nfloat dotProduct = dot( normalEC, dirVectorEC );\nvec3 skyColor = uSkyColor[i];\nvec3 groundColor = uGroundColor[i];\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 irradiance = mix( groundColor, skyColor, hemiDiffuseWeight );\nirradiance *= 3.141592653589793;\ntotalDiffuseLight += irradiance;\n}\n#endif\n#if DIR_LIGHTS > 0\nfor ( int i = 0; i < DIR_LIGHTS; i ++ )\n{\nvec3 dirVectorEC = normalize((czm_view * vec4(uDirectionalLightDirection[ i ], 0.0)).xyz);\nfloat dotProduct = dot( normalEC, dirVectorEC );\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\ntotalDiffuseLight += uDirectionalLightColor[ i ] * dirDiffuseWeight * diffuseBRDF_Lambertian(surfaceAlbedo.rgb);\n}\n#endif\n#if POINT_LIGHTS > 0\nfor ( int i = 0; i < POINT_LIGHTS; i ++ )\n{\nvec3 lVector = uPointLightPositionEC[i] + positionToEyeEC;\nfloat lengthToLight = length( lVector );\nfloat cutoffDis = uPointLightDistanceAndDecay[i].x;\nif(lengthToLight > cutoffDis)\n{\ncontinue;\n}\nfloat attenuation = calcLightAttenuation( lengthToLight, cutoffDis, uPointLightDistanceAndDecay[i].y);\nlVector = normalize( lVector );\nfloat dotProduct = dot( normalEC, lVector );\nfloat pointLightDiffuse = max( dotProduct, 0.0 );\ntotalDiffuseLight += uPointLightColor[i] * pointLightDiffuse * attenuation * diffuseBRDF_Lambertian(surfaceAlbedo.rgb);\n}\n#endif\n#if SPOT_LIGHTS > 0\nvec3 positionWC = (czm_model * vec4(positionMC, 1.0)).xyz;\nfor ( int i = 0; i < SPOT_LIGHTS; i ++ )\n{\nvec3 lVector = uSpotLightPositionEC[i] + positionToEyeEC;\nfloat attenuation = calcLightAttenuation( length( lVector ), uSpotLightDistanceDecayCosPenumbra[i].x, uSpotLightDistanceDecayCosPenumbra[i].y);\nlVector = normalize( lVector );\nfloat spotEffect = dot( uSpotLightDirection[ i ], normalize( uSpotLightPosition[ i ] - positionWC ) );\nif ( spotEffect > uSpotLightDistanceDecayCosPenumbra[i].z ) {\nspotEffect = max( pow( max( spotEffect, 0.0 ), uSpotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normalEC, lVector );\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\ntotalDiffuseLight += uSpotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect * diffuseBRDF_Lambertian(surfaceAlbedo.rgb);\nvec3 spotHalfVector = normalize( lVector + positionToEyeECDir );\nfloat spotDotNormalHalf = max( dot( normalEC, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = max( pow( spotDotNormalHalf, shininess2 ), 0.0 );\nfloat specularNormalization = ( shininess2 + 2.0 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\ntotalSpecularLight += schlick * uSpotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n}\n}\n#endif\nvec4 color = vec4(finalIrradiance + totalDiffuseLight + totalSpecularLight, surfaceAlbedo.a);\nreturn color;\n}\n",czm_eastNorthUpToEyeCoordinates:"mat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n{\nvec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));\nvec3 tangentEC = normalize(czm_normal3D * tangentMC);\nvec3 bitangentEC = normalize(cross(normalEC, tangentEC));\nreturn mat3(\ntangentEC.x,   tangentEC.y,   tangentEC.z,\nbitangentEC.x, bitangentEC.y, bitangentEC.z,\nnormalEC.x,    normalEC.y,    normalEC.z);\n}\n",czm_ellipsoidContainsPoint:"bool czm_ellipsoidContainsPoint(vec3 ellipsoid_inverseRadii, vec3 point)\n{\nvec3 scaled = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;\nreturn (dot(scaled, scaled) <= 1.0);\n}\n",czm_ellipsoidNew:"czm_ellipsoid czm_ellipsoidNew(vec3 center, vec3 radii)\n{\nvec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\nvec3 inverseRadiiSquared = inverseRadii * inverseRadii;\nczm_ellipsoid temp = czm_ellipsoid(center, radii, inverseRadii, inverseRadiiSquared);\nreturn temp;\n}\n",czm_ellipsoidWgs84TextureCoordinates:"vec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)\n{\nreturn vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);\n}\n",czm_equalsEpsilon:"bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {\nreturn all(lessThanEqual(abs(left - right), vec4(epsilon)));\n}\nbool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {\nreturn all(lessThanEqual(abs(left - right), vec3(epsilon)));\n}\nbool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {\nreturn all(lessThanEqual(abs(left - right), vec2(epsilon)));\n}\nbool czm_equalsEpsilon(float left, float right, float epsilon) {\nreturn (abs(left - right) <= epsilon);\n}\n",czm_executeExcavation:"#ifdef EXCAVATION\nuniform sampler2D uExcavationTexture;\nuniform float uExcavationMode;\nuniform vec4 uExcavationRect;\nvarying vec4 vExcavationVertexPos;\nvec2 CalculateExcavationPolyTexCoord(vec4 vertexPos, vec4 rectPos, out float ptInRect)\n{\nvec2 vecRatio = vec2(rectPos.z - rectPos.x, rectPos.w - rectPos.y);\nvec2 texCoord = vec2(vertexPos.x - rectPos.x, vertexPos.y - rectPos.y);\ntexCoord.x = texCoord.x / vecRatio.x;\ntexCoord.y = texCoord.y / vecRatio.y;\nptInRect = step(0.0, texCoord.x) * step(0.0, texCoord.y) * step(0.0, 1.0 - texCoord.x) * step(0.0, 1.0 - texCoord.y);\ntexCoord = clamp(texCoord, vec2(0.0), vec2(1.0));\nreturn texCoord;\n}\nbool czm_executeExcavation()\n{\nfloat hasExcavation = 1.0;\nvec2 vecExcavationTexCoord = CalculateExcavationPolyTexCoord(vExcavationVertexPos, uExcavationRect, hasExcavation);\nbool excavationInside = (uExcavationMode < 0.5);\nif(hasExcavation < 0.1)\n{\nreturn !excavationInside;\n}\nif(excavationInside)\n{\nreturn texture2D(uExcavationTexture, vecExcavationTexCoord.xy).r > 0.5;\n}\nelse\n{\nreturn texture2D(uExcavationTexture, vecExcavationTexCoord.xy).r < 0.5;\n}\n}\n#endif\n",czm_eyeOffset:"vec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n{\nvec4 p = positionEC;\nvec4 zEyeOffset = normalize(p) * eyeOffset.z;\np.xy += eyeOffset.xy + zEyeOffset.xy;\np.z += zEyeOffset.z;\nreturn p;\n}\n",czm_eyeToWindowCoordinates:"vec4 czm_eyeToWindowCoordinates(vec4 positionEC)\n{\nvec4 q = czm_projection * positionEC;\nq.xyz /= q.w;\nq.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz;\nreturn q;\n}\n",czm_fastApproximateAtan:"float czm_fastApproximateAtan(float x) {\nreturn x * (-0.1784 * x - 0.0663 * x * x + 1.0301);\n}\nfloat czm_fastApproximateAtan(float x, float y) {\nfloat t = abs(x);\nfloat opposite = abs(y);\nfloat adjacent = max(t, opposite);\nopposite = min(t, opposite);\nt = czm_fastApproximateAtan(opposite / adjacent);\nt = czm_branchFreeTernary(abs(y) > abs(x), czm_piOverTwo - t, t);\nt = czm_branchFreeTernary(x < 0.0, czm_pi - t, t);\nt = czm_branchFreeTernary(y < 0.0, -t, t);\nreturn t;\n}\n",czm_fog:"vec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor)\n{\nfloat scalar = distanceToCamera * czm_fogDensity;\nfloat fog = 1.0 - exp(-(scalar * scalar));\nreturn mix(color, fogColor, fog);\n}\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant)\n{\nfloat scalar = distanceToCamera * czm_fogDensity;\nfloat fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\nreturn mix(color, fogColor, fog);\n}\n",czm_gammaCorrect:"vec3 czm_gammaCorrect(vec3 color) {\n#ifdef HDR\ncolor = pow(color, vec3(czm_gamma));\n#endif\nreturn color;\n}\nvec4 czm_gammaCorrect(vec4 color) {\n#ifdef HDR\ncolor.rgb = pow(color.rgb, vec3(czm_gamma));\n#endif\nreturn color;\n}\n",czm_geodeticSurfaceNormal:"vec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n{\nreturn normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n}\n",czm_getDefaultMaterial:"czm_material czm_getDefaultMaterial(czm_materialInput materialInput)\n{\nczm_material material;\nmaterial.diffuse = vec3(0.0);\nmaterial.specular = 0.0;\nmaterial.shininess = 1.0;\nmaterial.normal = materialInput.normalEC;\nmaterial.emission = vec3(0.0);\nmaterial.alpha = 1.0;\nreturn material;\n}\n",czm_getEmissiveTextureColor:"uniform float uMaxCategoryOrHypCeil;\nuniform float uMinCategoryOrHypFloor;\nuniform sampler2D uEmissionTexAtlas;\nuniform vec4 uEmissionTexAtlasTilingAndOffset[EMISSION_TEXTURE_COUNT];\nuniform vec4 uEmissionTexAtlasRects[EMISSION_TEXTURE_COUNT];\nuniform float uLayerCornerLength;\nvarying vec2 vLayerTexCoord;\nvarying vec2 vModIndexAndTexIndex;\nvec3 czm_getEmissiveTextureColor(float w)\n{\nvec3 texColor = vec3(0.0);\nvec2 emissionTexCoord;\nint nEmissionTexTexIdx = int(floor(vModIndexAndTexIndex.y + 0.5));\nvec2 atlasTexCoord;\nfor(int i = 0; i < EMISSION_TEXTURE_COUNT; i++){\nif(nEmissionTexTexIdx == i){\nemissionTexCoord.x = mod(length(vLayerTexCoord) * uLayerCornerLength / uEmissionTexAtlasTilingAndOffset[i].x, 1.0);\nemissionTexCoord.y = mod((w - uMinCategoryOrHypFloor) / uEmissionTexAtlasTilingAndOffset[i].y, 1.0) ;\nemissionTexCoord.x += uEmissionTexAtlasTilingAndOffset[i].z;\nemissionTexCoord.y += vModIndexAndTexIndex.x + uEmissionTexAtlasTilingAndOffset[i].w;\nemissionTexCoord.xy = fract(emissionTexCoord.xy);\natlasTexCoord = mix(uEmissionTexAtlasRects[i].xy, uEmissionTexAtlasRects[i].zw, emissionTexCoord);\nbreak;\n}\n}\ntexColor = texture2D(uEmissionTexAtlas, atlasTexCoord).rgb;\nreturn texColor;\n}\nvec3 czm_getEmissiveTextureColor(float w, vec2 texCoord)\n{\nvec3 texColor = vec3(0.0);\nvec2 emissionTexCoord;\nint nEmissionTexTexIdx = int(floor(vModIndexAndTexIndex.y + 0.5));\nvec2 atlasTexCoord;\nfor(int i = 0; i < EMISSION_TEXTURE_COUNT; i++){\nif(nEmissionTexTexIdx == i){\nemissionTexCoord.x = mod(texCoord.x / uEmissionTexAtlasTilingAndOffset[i].x, 1.0);\nemissionTexCoord.y = mod(texCoord.y / uEmissionTexAtlasTilingAndOffset[i].y, 1.0);\nemissionTexCoord.x += uEmissionTexAtlasTilingAndOffset[i].z;\nemissionTexCoord.y += vModIndexAndTexIndex.x + uEmissionTexAtlasTilingAndOffset[i].w;\nemissionTexCoord.xy = fract(emissionTexCoord.xy);\natlasTexCoord = mix(uEmissionTexAtlasRects[i].xy, uEmissionTexAtlasRects[i].zw, emissionTexCoord);\nbreak;\n}\n}\ntexColor = texture2D(uEmissionTexAtlas, atlasTexCoord).rgb;\nreturn texColor;\n}\n",czm_getHorizontalColor:"uniform float uHorizontalLine;\nuniform vec4 uHorizontalColor;\nfloat computeContourline(float fValue)\n{\nfloat distanceToContour = uHorizontalLine;\nfloat dxc = abs(dFdx(fValue));\nfloat dyc = abs(dFdy(fValue));\nfloat dF = max(dxc, dyc);\nreturn (abs(distanceToContour-fValue) < dF) ? 1.0 : 0.0;\n}\nvec4 czm_getHorizontalColor(vec4 oriColor, float fValue)\n{\nfloat finalOpacity = computeContourline(fValue);\nreturn mix(oriColor,uHorizontalColor, finalOpacity);\n}\n",czm_getHypsometricColor:"uniform sampler2D uHypsometricTexture;\nuniform sampler2D uHypsometricRenderTexture;\nuniform float uHypsometricVisible;\nuniform float uHypOpacity;\nuniform float uHypContourInterval;\nuniform vec4 uHypLineColor;\nuniform float uHypContourFillMode;\nuniform float uHypFloor;\nuniform float uHypCeil;\nuniform float uHypMaxVisibleValue;\nuniform float uHypMinVisibleValue;\nuniform float uHypHasAnalysisRegion;\nvarying vec2 vecHypTexCoord;\nuniform float uMixColorType;\nuniform vec4 uNoValueColor;\n#ifdef Volume\nvarying vec3 vecRotioCoord;\nuniform float uDataFloor;\nuniform float uDataCeil;\nuniform float uVolumeType;\n#endif\n#ifdef Volume2\nuniform float uDataFloor;\nuniform float uDataCeil;\nuniform float uFilterMode;\n#endif\nfloat computeMixCon(float fValue)\n{\nfloat distanceToContour;\nif(abs(uHypMaxVisibleValue - uHypMinVisibleValue) > 0.1)\n{\nif(fValue < 0.5)\n{\ndistanceToContour = mod(fValue - 0.0002, uHypContourInterval);\n}\nelse\n{\nfloat t = floor(fValue / uHypContourInterval);\ndistanceToContour = abs(fValue - (t * uHypContourInterval) - 0.1);\n}\n}\nelse\n{\ndistanceToContour = abs(fValue - uHypMaxVisibleValue);\n}\nfloat dxc = abs(dFdx(fValue));\nfloat dyc = abs(dFdy(fValue));\nfloat dF = max(dxc, dyc);\nreturn (distanceToContour < dF) ? 1.0 : 0.0;\n}\nvec4 computeContourMapColor(float fValue)\n{\nfloat threshold = abs(uHypCeil - uHypFloor);\nfloat contourRate = (fValue - uHypFloor) / threshold;\nfloat finalCoord = clamp(contourRate, 0.0, 1.0);\nfloat count = floor(finalCoord * 16.0);\nfloat y = (count*2.0 + 1.0)/32.0;\nfloat x = fract(finalCoord*16.0);\nif(y > 1.0)\n{\nx = 1.0;\n}\nvec2 contourCoord = vec2(x, y);\nvec4 color = texture2D(uHypsometricTexture, contourCoord);\nreturn color;\n}\n#ifdef Volume2\nvec4 czm_getContourMapColor(vec4 oriColor, vec4 volColor)\n{\nif(uFilterMode > 0.5)\n{\nvec4 finalColor = volColor * oriColor;\nif(uMixColorType > 0.5)\n{\nfinalColor = volColor;\n}\nreturn finalColor;\n}\nvec4 contourMapColor = vec4(0.0);\nfloat finalOpacity = uHypOpacity;\nfloat noValue = volColor.a;\nfloat texTest = clamp(czm_unpackVolume(volColor.zyx),0.0,1.0);\nfloat fValue;\nif(noValue > 0.5)\n{\nfValue = uDataFloor + texTest * (uDataCeil - uDataFloor);\n}\nelse\n{\nfValue = uHypMaxVisibleValue + abs(uHypMaxVisibleValue * 0.1);\n}\nfloat extendHeight = czm_branchFreeTernary(uHypContourFillMode > 2.9, 0.0, czm_branchFreeTernary(uHypContourFillMode > 1.9, 5.0, 0.0));\nif(fValue > uHypMaxVisibleValue + extendHeight || fValue < uHypMinVisibleValue - extendHeight)\n{\nreturn uNoValueColor * oriColor;\n}\n#ifdef GL_OES_standard_derivatives\nif(uHypContourFillMode > 2.9)\n{\nfloat mix_con = computeMixCon(fValue);\ncontourMapColor = mix(computeContourMapColor(fValue), uHypLineColor, mix_con);\n}\nelse if(uHypContourFillMode > 1.9)\n{\nfinalOpacity = computeMixCon(fValue);\ncontourMapColor = uHypLineColor;\n}\nelse if(uHypContourFillMode > 0.9)\n#else\nif(uHypContourFillMode > 0.9)\n#endif\n{\ncontourMapColor = computeContourMapColor(fValue);\n}\nelse\n{\nfinalOpacity = 0.0;\n}\nvec4 mixColor = mix(vec4(1.0,1.0,1.0,1.0), contourMapColor, finalOpacity);\nvec4 finalColor = mixColor * oriColor;\n#ifdef PT_CLOUD\nfinalColor = mixColor;\n#endif\nif(uMixColorType > 0.5)\n{\nfinalColor = mixColor;\n}\nreturn finalColor;\n}\n#else\nvec4 czm_getContourMapColor(vec4 oriColor, float fValue)\n{\nvec4 contourMapColor = vec4(0.0);\nfloat finalOpacity = uHypOpacity;\n#ifdef Volume\nvec3 aRatioT = vecRotioCoord;\nif((aRatioT.x < 1.0 && aRatioT.x >0.0) && (aRatioT.y < 1.0 && aRatioT.y >0.0) && (aRatioT.z < 1.0 && aRatioT.z >0.0))\n{\nif(uVolumeType > 0.5)\n{\nvec4 volumeColor = czm_getVolumeValue(aRatioT);\nif(uMixColorType > 0.5)\n{\nvolumeColor = volumeColor * oriColor;\n}\nreturn volumeColor;\n}\nfloat noValue;\nfloat texTest = czm_getVolumeValue(aRatioT, noValue);\nif(noValue > 0.5)\n{\nfValue = uDataFloor + texTest * (uDataCeil - uDataFloor);\n}\nelse\n{\nfValue = uHypMaxVisibleValue + abs(uHypMaxVisibleValue * 0.1);\n}\n}\nelse\n{\nfValue = uHypMaxVisibleValue + abs(uHypMaxVisibleValue * 0.1);\n}\n#endif\nfloat extendHeight = czm_branchFreeTernary(uHypContourFillMode > 2.9, 0.0, czm_branchFreeTernary(uHypContourFillMode > 1.9, 5.0, 0.0));\nif(fValue > uHypMaxVisibleValue + extendHeight || fValue < uHypMinVisibleValue - extendHeight)\n{\nreturn uNoValueColor * oriColor;\n}\n#ifdef GL_OES_standard_derivatives\nif(uHypContourFillMode > 2.9)\n{\nfloat mix_con = computeMixCon(fValue);\ncontourMapColor = mix(computeContourMapColor(fValue), uHypLineColor, mix_con);\n}\nelse if(uHypContourFillMode > 1.9)\n{\nfinalOpacity = computeMixCon(fValue);\ncontourMapColor = uHypLineColor;\n}\nelse if(uHypContourFillMode > 0.9)\n#else\nif(uHypContourFillMode > 0.9)\n#endif\n{\ncontourMapColor = computeContourMapColor(fValue);\n}\nelse\n{\nfinalOpacity = 0.0;\n}\nvec4 mixColor = mix(vec4(1.0,1.0,1.0,1.0), contourMapColor, finalOpacity);\nvec4 finalColor = mix(oriColor, contourMapColor, finalOpacity);\n#ifdef PT_CLOUD\nfinalColor = mixColor;\n#endif\n#ifdef Volume\nif(uMixColorType > 0.5)\n{\nfinalColor = mixColor;\n}\n#endif\nreturn finalColor;\n}\n#endif\n#ifdef Volume2\nvec4 czm_getHypsometricColor(vec4 oriColor, vec4 volColor)\n{\nif(uHypHasAnalysisRegion > 0.1)\n{\nvec4 hypColor = texture2D(uHypsometricRenderTexture, vecHypTexCoord);\nif(hypColor.r < 0.1)\n{\nreturn oriColor;\n}\n}\nreturn czm_getContourMapColor(oriColor, volColor);\n}\n#else\nvec4 czm_getHypsometricColor(vec4 oriColor, float wValue)\n{\nfloat fValue = wValue;\nif(uHypHasAnalysisRegion > 0.1)\n{\nvec4 hypColor = texture2D(uHypsometricRenderTexture, vecHypTexCoord);\nif(hypColor.r < 0.1)\n{\nreturn oriColor;\n}\n}\nreturn czm_getContourMapColor(oriColor, fValue);\n}\nvec4 czm_getHypsometricColorByGeoBounds(vec4 oriColor, float wValue, vec4 hypRect, vec2 vTexCoord, vec4 geoBounds)\n{\nif(uHypHasAnalysisRegion > 0.1)\n{\nvec2 polyTexCoord = vTexCoord.xy;\npolyTexCoord.x = polyTexCoord.x * (geoBounds.z - geoBounds.x) + geoBounds.x;\npolyTexCoord.y = polyTexCoord.y * (geoBounds.w - geoBounds.y) + geoBounds.y;\nif(polyTexCoord.x < hypRect.x || polyTexCoord.x>hypRect.z || polyTexCoord.y< hypRect.y || polyTexCoord.y > hypRect.w)\n{\nreturn oriColor;\n}\nvec4 hypColor = texture2D(uHypsometricRenderTexture, polyTexCoord);\nif(hypColor.r < 0.1)\n{\nreturn oriColor;\n}\n}\nreturn czm_getContourMapColor(oriColor, wValue);\n}\n#endif\n",czm_getLambertDiffuse:"float czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\n{\nreturn max(dot(lightDirectionEC, normalEC), 0.0);\n}\n",czm_getSpecular:"float czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)\n{\nvec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);\nfloat specular = max(dot(toReflectedLight, toEyeEC), 0.0);\nreturn pow(specular, max(shininess, czm_epsilon2));\n}\n",czm_getTexColorForS3M:"void CalculateMipLevel(in vec2 inTexCoord, in float vecTile, in float fMaxMip, inout float mipLevel)\n{\nvec2 dx = dFdx(inTexCoord * vecTile);\nvec2 dy = dFdy(inTexCoord * vecTile);\nfloat dotX = dot(dx, dx);\nfloat dotY = dot(dy, dy);\nfloat dMax = max(dotX, dotY);\nfloat dMin = min(dotX, dotY);\nfloat offset = (dMax - dMin) / (dMax + dMin);\noffset = clamp(offset, 0.0, 1.0);\nfloat d = dMax * (1.0 - offset) + dMin * offset;\nmipLevel = 0.5 * log2(d);\nmipLevel = clamp(mipLevel, 0.0, fMaxMip - 1.62);\n}\nvoid CalculateMipLevel(in vec2 inTexCoord, in vec2 vecTile, in float fMaxMip, inout float mipLevel)\n{\nvec2 dx = dFdx(inTexCoord * vecTile.x);\nvec2 dy = dFdy(inTexCoord * vecTile.y);\nfloat dotX = dot(dx, dx);\nfloat dotY = dot(dy, dy);\nfloat dMax = max(dotX, dotY);\nfloat dMin = min(dotX, dotY);\nfloat offset = (dMax - dMin) / (dMax + dMin);\noffset = clamp(offset, 0.0, 1.0);\nfloat d = dMax * (1.0 - offset) + dMin * offset;\nmipLevel = 0.5 * log2(d);\nmipLevel = clamp(mipLevel, 0.0, fMaxMip - 1.62);\n}\nvoid CalculateTexCoord(in vec3 inTexCoord, in float scale, in float XTran, in float YTran, in float fTile, in float mipLevel, inout vec2 outTexCoord)\n{\nif(inTexCoord.z < -9000.0)\n{\noutTexCoord = inTexCoord.xy;\n}\nelse\n{\nvec2 fTexCoord = fract(inTexCoord.xy);\nfloat offset = 1.0 * pow(2.0, mipLevel) / fTile;\nfTexCoord = clamp(fTexCoord, offset, 1.0 - offset);\noutTexCoord.x = (fTexCoord.x + XTran) * scale;\noutTexCoord.y = (fTexCoord.y + YTran) * scale;\n}\n}\nvec4 czm_getTexColorForS3M(sampler2D curTexture, vec3 oriTexCoord, float texTileWidth, float fMaxMipLev, float fTexCoordScale, vec2 vecTexCoordTranslate,float isRGBA, vec4 texUVoffset, out vec2 outTexCoord)\n{\nvec4 color = vec4(1.0);\nif(oriTexCoord.z <= -99900.0){\nreturn color;\n}\nfloat mipLevel = 0.0;\n#ifdef GL_OES_standard_derivatives\nCalculateMipLevel(oriTexCoord.xy, texTileWidth, fMaxMipLev, mipLevel);\n#endif\nvec2 realTexCoord;\nCalculateTexCoord(oriTexCoord, fTexCoordScale, vecTexCoordTranslate.x, vecTexCoordTranslate.y, texTileWidth, mipLevel, realTexCoord);\nif(isRGBA > 0.5)\n{\nvec2 rgbTexCoord;\nrgbTexCoord.x = (realTexCoord.x + vecTexCoordTranslate.x * fTexCoordScale) * 0.5;\nrgbTexCoord.y = (realTexCoord.y + vecTexCoordTranslate.y * fTexCoordScale) * 0.5;\nrgbTexCoord.xy += texUVoffset.xy;\ncolor = texture2D(curTexture, rgbTexCoord.xy, -10.0);\nvec2 vecAlphaTexCoord;\nvecAlphaTexCoord.x = rgbTexCoord.x;\nvecAlphaTexCoord.y = rgbTexCoord.y + fTexCoordScale * 0.5;\nvecAlphaTexCoord.xy += texUVoffset.xy;\ncolor.a = texture2D(curTexture, vecAlphaTexCoord.xy, -10.0).r;\n}\nelse\n{\nrealTexCoord = realTexCoord * texUVoffset.zw + texUVoffset.xy;\nif(oriTexCoord.z < -9000.0)\n{\ncolor = texture2D(curTexture, realTexCoord.xy);\n}\nelse\n{\n#ifdef GL_EXT_shader_texture_lod\ncolor = texture2DLodEXT(curTexture, realTexCoord.xy, mipLevel);\n#else\n#ifdef WEBEL2\ncolor = textureLod(curTexture, realTexCoord.xy, mipLevel);\n#else\ncolor = texture2D(curTexture, realTexCoord.xy, mipLevel);\n#endif\n#endif\n}\n#ifdef RGBTOBGR\ncolor = color.bgra;\n#endif\n}\noutTexCoord = realTexCoord;\nreturn color;\n}\nvec4 czm_getTexColorForS3M(sampler2D texture, vec2 uv, vec2 texDim, vec2 texTran, vec2 texScale, float maxMipLevel, out vec2 outTexCoord)\n{\nif(maxMipLevel < 0.0)\n{\nreturn vec4(1.0);\n}\nvec4 colorCeil = vec4(1.0);\nfloat mipLevel = 0.0;\n#ifdef GL_OES_standard_derivatives\nCalculateMipLevel(uv, texDim, maxMipLevel, mipLevel);\n#endif\nfloat ceilMipLevel = ceil(mipLevel);\nvec2 translate = vec2(texTran.x, texTran.y);\nfloat temp;\nif(ceilMipLevel > 0.0)\n{\ntranslate.x = texTran.x + texScale.x;\ntemp = pow(2.0, ceilMipLevel - 1.0);\ntranslate.y = texTran.y + texScale.y * (temp - 1.0) / temp;\n}\nfloat scale = 1.0 / pow(2.0, ceilMipLevel);\nvec2 texcoord = fract(uv);\nfloat offsetX = pow(2.0, ceilMipLevel) / texDim.x;\nfloat offsetY = pow(2.0, ceilMipLevel) / texDim.y;\ntexcoord.x = clamp(texcoord.x, 0.0 + offsetX, 1.0 - offsetX);\ntexcoord.y = clamp(texcoord.y, 0.0 + offsetY, 1.0 - offsetY);\ntexcoord.x = texcoord.x * texScale.x * scale + translate.x;\ntexcoord.y = texcoord.y * texScale.y * scale + translate.y;\n#ifdef GL_EXT_shader_texture_lod\ncolorCeil = texture2DLodEXT(texture, texcoord.xy, 0.0);\n#else\n#ifdef WEBEL2\ncolorCeil = textureLod(texture, texcoord.xy, 0.0);\n#else\ncolorCeil = texture2D(texture, texcoord.xy, -10.0);\n#endif\n#endif\nvec4 colorFloor = vec4(1.0);\nfloat floorMipLevel = floor(mipLevel);\ntranslate = vec2(texTran.x, texTran.y);\nif(floorMipLevel > 0.0)\n{\ntranslate.x = texTran.x + texScale.x;\ntemp = pow(2.0, floorMipLevel - 1.0);\ntranslate.y = texTran.y + texScale.y * (temp - 1.0) / temp;\n}\nscale = 1.0 / pow(2.0, floorMipLevel);\ntexcoord = fract(uv);\noffsetX = pow(2.0, floorMipLevel) / texDim.x;\noffsetY = pow(2.0, floorMipLevel) / texDim.y;\ntexcoord.x = clamp(texcoord.x, 0.0 + offsetX, 1.0 - offsetX);\ntexcoord.y = clamp(texcoord.y, 0.0 + offsetY, 1.0 - offsetY);\ntexcoord.x = texcoord.x * texScale.x * scale + translate.x;\ntexcoord.y = texcoord.y * texScale.y * scale + translate.y;\n#ifdef GL_EXT_shader_texture_lod\ncolorFloor = texture2DLodEXT(texture, texcoord.xy, 0.0);\n#else\n#ifdef WEBEL2\ncolorFloor = textureLod(texture, texcoord.xy, 0.0);\n#else\ncolorFloor = texture2D(texture, texcoord.xy, -10.0);\n#endif\n#endif\nvec4 color = colorCeil * 0.5 + colorFloor * 0.5;\nreturn color;\n}\n",czm_getTextureMatrixFromZValue:"const int SHIFT_LEFT8 = 256;\nvoid czm_getTextureMatrixFromZValue(in int nZ, inout float XTran, inout float YTran, inout float scale, inout float isRGBA)\n{\nif(nZ < 0){\nreturn ;\n}\nint nDel8 = nZ / SHIFT_LEFT8;\nint nDel16 = nDel8 / SHIFT_LEFT8;\nYTran = float(nZ - nDel8 * SHIFT_LEFT8);\nXTran = float(nDel8 - nDel16 * SHIFT_LEFT8);\nint nLevel = nDel16;\nscale = 1.0 / pow(2.0, float(nLevel));\n}\n",czm_getVolumeValue:"uniform sampler2D uVolumeTexture;\n#ifdef TIME_ORDER\nuniform sampler2D uNextVolumeTexture;\nuniform float uTimeRatio;\n#endif\n#ifdef Volume\nuniform float width;\nuniform float height;\nuniform float depth;\nuniform float sideBlockCount;\nuniform float blockLength;\nuniform float texLength;\nuniform float uFilterMode;\n#endif\nfloat czm_unpackVolume(vec3 packedDepth)\n{\nreturn dot(packedDepth, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\n}\n#ifdef Volume\nvec2 computeVolumeTextureCoord(vec3 texCoord, float fLevel)\n{\nfloat yOffset = floor((fLevel+0.25/sideBlockCount) / sideBlockCount);\nfloat xOffset = fLevel - yOffset * sideBlockCount;\nfloat texCoordV = (texCoord.y * height + yOffset * blockLength) / texLength;\nfloat texCoordU = (texCoord.x * width + xOffset * blockLength) / texLength;\nreturn vec2(texCoordU, texCoordV);\n}\nfloat computeVolumeValue(sampler2D volumeTexture, vec2 topTexCoord, vec2 bottomTexCoord, float ratio, out float noValue)\n{\nvec4 volumeValue1 = texture2D(volumeTexture, topTexCoord);\nvec4 volumeValue2 = texture2D(volumeTexture, bottomTexCoord);\nfloat fValue1 = clamp(czm_unpackVolume(volumeValue1.xyz),0.0,1.0);\nfloat fValue2 = clamp(czm_unpackVolume(volumeValue2.xyz),0.0,1.0);\nif(uFilterMode >0.5)\n{\nif(ratio<0.5)\n{\nratio = 0.0;\n}\nelse\n{\nratio = 1.0;\n}\n}\nnoValue = mix(volumeValue1.a, volumeValue2.a, ratio);\nif(volumeValue1.a < 0.5)\n{\nfValue1 = fValue2;\n}\nif(volumeValue2.a < 0.5)\n{\nfValue2 = fValue1;\n}\nreturn mix(fValue1, fValue2, ratio);\n}\nfloat czm_getVolumeValue(vec3 texCoord, out float noValue)\n{\nfloat fLevel = (depth - 1.0) * texCoord.z;\nfloat bottomLevel= floor(fLevel);\nfloat topLevel = bottomLevel + 1.0;\nfloat ratio = topLevel - fLevel;\nvec2 topTexCoord = computeVolumeTextureCoord(texCoord, topLevel);\nvec2 bottomTexCoord = computeVolumeTextureCoord(texCoord, bottomLevel);\nfloat fResult = computeVolumeValue(uVolumeTexture, topTexCoord, bottomTexCoord, ratio, noValue);\n#ifdef TIME_ORDER\nfloat fNextResult = computeVolumeValue(uNextVolumeTexture, topTexCoord, bottomTexCoord, ratio, noValue);\nfResult = mix(fResult, fNextResult, uTimeRatio);\n#endif\nreturn fResult;\n}\nvec4 czm_getVolumeValue(vec3 texCoord)\n{\nfloat fLevel = (depth - 1.0) * texCoord.z;\nfloat bottomLevel= floor(fLevel);\nfloat topLevel = bottomLevel + 1.0;\nfloat ratio = topLevel - fLevel;\nfloat yOffset1 = floor((topLevel+0.25/sideBlockCount) / sideBlockCount);\nfloat xOffset1 = topLevel - yOffset1 * sideBlockCount;\nfloat texCoordV1 = (texCoord.y * height + yOffset1 * blockLength)/texLength;\nfloat texCoordU1 = (texCoord.x * width + xOffset1 * blockLength)/texLength;\nvec4 volumeColor1 = texture2D(uVolumeTexture, vec2(texCoordU1,texCoordV1));\nfloat yOffset2 = floor((bottomLevel+0.25/sideBlockCount) / sideBlockCount);\nfloat xOffset2 = bottomLevel - yOffset2 * sideBlockCount;\nfloat texCoordV2 = (texCoord.y * height + yOffset2 * blockLength)/texLength;\nfloat texCoordU2 = (texCoord.x * width + xOffset2 * blockLength)/texLength;\nvec4 volumeColor2 = texture2D(uVolumeTexture, vec2(texCoordU2, texCoordV2));\nif(uFilterMode >0.5)\n{\nif(ratio<0.5)\n{\nratio = 0.0;\n}\nelse\n{\nratio = 1.0;\n}\n}\nvec4 volumeColor = mix(volumeColor1, volumeColor2, ratio);\nreturn volumeColor;\n}\n#endif\n",czm_getVolumeValueMultiResolution:"uniform sampler2D uVolumeTexture1;\nuniform sampler2D uVolumeTexture2;\nuniform sampler2D uVolumeTexture3;\nuniform mat4 uMultiResolutionPara1;\nuniform mat4 uMultiResolutionPara2;\nuniform mat4 uMultiResolutionPara3;\n#ifdef TIME_ORDER\nuniform sampler2D uNextVolumeTexture1;\nuniform sampler2D uNextVolumeTexture2;\nuniform sampler2D uNextVolumeTexture3;\n#endif\n#ifdef Volume\nvec2 computeVolumeTextureCoord(vec2 texCoord, float fLevel, float texWidth, float texHeight, float texSideBlockCount, float texBlockLength, float texTotalLength)\n{\nfloat yOffset = floor((fLevel+0.25/texSideBlockCount) / texSideBlockCount);\nfloat xOffset = fLevel - yOffset * texSideBlockCount;\nfloat texCoordV = (texCoord.y * texHeight + yOffset * texBlockLength) / texTotalLength;\nfloat texCoordU = (texCoord.x * texWidth + xOffset * texBlockLength) / texTotalLength;\nreturn vec2(texCoordU, texCoordV);\n}\nfloat czm_getVolumeValueMultiResolution(vec3 texCoord, out float noValue)\n{\nfloat fLevel = (depth - 1.0) * texCoord.z;\nfloat bottomLevel= floor(fLevel);\nfloat topLevel = bottomLevel + 1.0;\nfloat ratio = topLevel - fLevel;\nvec2 topTexCoord = computeVolumeTextureCoord(texCoord, topLevel);\nvec2 bottomTexCoord = computeVolumeTextureCoord(texCoord, bottomLevel);\nfloat fResult = computeVolumeValue(uVolumeTexture, topTexCoord, bottomTexCoord, ratio, noValue);\n#ifdef TIME_ORDER\nfloat fNextResult = computeVolumeValue(uNextVolumeTexture, topTexCoord, bottomTexCoord, ratio, noValue);\nfResult = mix(fResult, fNextResult, uTimeRatio);\n#endif\nfloat width = uMultiResolutionPara1[2].x;\nfloat height = uMultiResolutionPara1[2].y;\nfloat sideBlockCount = uMultiResolutionPara1[2].z;\nfloat blockLength = uMultiResolutionPara1[2].w;\nfloat texLength = uMultiResolutionPara1[3].x;\nvec4 uMultiResolutionTranslation = uMultiResolutionPara1[0];\nvec2 texCoord1 = (texCoord.xy - uMultiResolutionTranslation.xy) * uMultiResolutionTranslation.zw;\nvec2 topTexCoord1 = computeVolumeTextureCoord(texCoord1, topLevel, width, height, sideBlockCount, blockLength, texLength);\nvec2 bottomTexCoord1 = computeVolumeTextureCoord(texCoord1, bottomLevel, width, height, sideBlockCount, blockLength, texLength);\nfloat alpha1 = 5.0 * clamp( max(abs(texCoord1.x - 0.5), abs(texCoord1.y - 0.5)) - 0.3,0.0,0.2);\nfloat fResult1 = computeVolumeValue(uVolumeTexture1, topTexCoord1, bottomTexCoord1, ratio, noValue);\n#ifdef TIME_ORDER\nfloat fNextResult1 = computeVolumeValue(uNextVolumeTexture1, topTexCoord1, bottomTexCoord1, ratio, noValue);\nfResult1 = mix(fResult1, fNextResult1, uTimeRatio);\n#endif\nwidth = uMultiResolutionPara2[2].x;\nheight = uMultiResolutionPara2[2].y;\nsideBlockCount = uMultiResolutionPara2[2].z;\nblockLength = uMultiResolutionPara2[2].w;\ntexLength = uMultiResolutionPara2[3].x;\nuMultiResolutionTranslation = uMultiResolutionPara2[0];\nvec2 texCoord2 = (texCoord.xy - uMultiResolutionTranslation.xy) * uMultiResolutionTranslation.zw;\nvec2 topTexCoord2 = computeVolumeTextureCoord(texCoord2, topLevel, width, height, sideBlockCount, blockLength, texLength);\nvec2 bottomTexCoord2 = computeVolumeTextureCoord(texCoord2, bottomLevel, width, height, sideBlockCount, blockLength, texLength);\nfloat alpha2 = 5.0 * clamp( max(abs(texCoord2.x - 0.5), abs(texCoord2.y - 0.5)) - 0.3,0.0,0.2);\nfloat fResult2 = computeVolumeValue(uVolumeTexture2, topTexCoord2, bottomTexCoord2, ratio, noValue);\n#ifdef TIME_ORDER\nfloat fNextResult2 = computeVolumeValue(uNextVolumeTexture2, topTexCoord2, bottomTexCoord2, ratio, noValue);\nfResult2 = mix(fResult2, fNextResult2, uTimeRatio);\n#endif\nwidth = uMultiResolutionPara3[2].x;\nheight = uMultiResolutionPara3[2].y;\nsideBlockCount = uMultiResolutionPara3[2].z;\nblockLength = uMultiResolutionPara3[2].w;\ntexLength = uMultiResolutionPara3[3].x;\nuMultiResolutionTranslation = uMultiResolutionPara3[0];\nvec2 texCoord3 = (texCoord.xy - uMultiResolutionTranslation.xy) * uMultiResolutionTranslation.zw;\nvec2 topTexCoord3 = computeVolumeTextureCoord(texCoord3, topLevel, width, height, sideBlockCount, blockLength, texLength);\nvec2 bottomTexCoord3 = computeVolumeTextureCoord(texCoord3, bottomLevel, width, height, sideBlockCount, blockLength, texLength);\nfloat alpha3 = 5.0 * clamp( max(abs(texCoord3.x - 0.5), abs(texCoord3.y - 0.5)) - 0.3,0.0,0.2);\nfloat fResult3 = computeVolumeValue(uVolumeTexture3, topTexCoord3, bottomTexCoord3, ratio, noValue);\n#ifdef TIME_ORDER\nfloat fNextResult3 = computeVolumeValue(uNextVolumeTexture3, topTexCoord3, bottomTexCoord3, ratio, noValue);\nfResult3 = mix(fResult3, fNextResult3, uTimeRatio);\n#endif\nreturn mix(fResult3, mix(fResult2, mix(fResult1, fResult, alpha1), alpha2), alpha3);\n}\n#endif\n",czm_getWaterNoise:"vec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)\n{\nfloat cosAngle = cos(angleInRadians);\nfloat sinAngle = sin(angleInRadians);\nvec2 s0 = vec2(1.0/17.0, 0.0);\nvec2 s1 = vec2(-1.0/29.0, 0.0);\nvec2 s2 = vec2(1.0/101.0, 1.0/59.0);\nvec2 s3 = vec2(-1.0/109.0, -1.0/57.0);\ns0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));\ns1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));\ns2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));\ns3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));\nvec2 uv0 = (uv/103.0) + (time * s0);\nvec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);\nvec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);\nvec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);\nuv0 = fract(uv0);\nuv1 = fract(uv1);\nuv2 = fract(uv2);\nuv3 = fract(uv3);\nvec4 noise = (texture2D(normalMap, uv0)) +\n(texture2D(normalMap, uv1)) +\n(texture2D(normalMap, uv2)) +\n(texture2D(normalMap, uv3));\nreturn ((noise / 4.0) - 0.5) * 2.0;\n}\n",czm_getWgs84EllipsoidEC:"czm_ellipsoid czm_getWgs84EllipsoidEC()\n{\nvec3 radii = vec3(6378137.0, 6378137.0, 6378137.0);\nvec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\nvec3 inverseRadiiSquared = inverseRadii * inverseRadii;\nczm_ellipsoid temp = czm_ellipsoid(czm_view[3].xyz, radii, inverseRadii, inverseRadiiSquared);\nreturn temp;\n}\n",czm_HSBToRGB:"const vec4 K_HSB2RGB = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 czm_HSBToRGB(vec3 hsb)\n{\nvec3 p = abs(fract(hsb.xxx + K_HSB2RGB.xyz) * 6.0 - K_HSB2RGB.www);\nreturn hsb.z * mix(K_HSB2RGB.xxx, clamp(p - K_HSB2RGB.xxx, 0.0, 1.0), hsb.y);\n}\n",czm_HSLToRGB:"vec3 hueToRGB(float hue)\n{\nfloat r = abs(hue * 6.0 - 3.0) - 1.0;\nfloat g = 2.0 - abs(hue * 6.0 - 2.0);\nfloat b = 2.0 - abs(hue * 6.0 - 4.0);\nreturn clamp(vec3(r, g, b), 0.0, 1.0);\n}\nvec3 czm_HSLToRGB(vec3 hsl)\n{\nvec3 rgb = hueToRGB(hsl.x);\nfloat c = (1.0 - abs(2.0 * hsl.z - 1.0)) * hsl.y;\nreturn (rgb - 0.5) * c + hsl.z;\n}\n",czm_hue:"vec3 czm_hue(vec3 rgb, float adjustment)\n{\nconst mat3 toYIQ = mat3(0.299,     0.587,     0.114,\n0.595716, -0.274453, -0.321263,\n0.211456, -0.522591,  0.311135);\nconst mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\n1.0, -0.2721, -0.6474,\n1.0, -1.107,   1.7046);\nvec3 yiq = toYIQ * rgb;\nfloat hue = atan(yiq.z, yiq.y) + adjustment;\nfloat chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\nvec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\nreturn toRGB * color;\n}\n",czm_inverseGamma:"vec3 czm_inverseGamma(vec3 color) {\nreturn pow(color, vec3(1.0 / czm_gamma));\n}\n",czm_inverseMatrix:"mat3 czm_inverseMatrix(mat3 m)\n{\nfloat Determinant =\nm[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])\n- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])\n+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);\nmat3 Inverse;\nInverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);\nInverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);\nInverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);\nInverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);\nInverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);\nInverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);\nInverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);\nInverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);\nInverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);\nInverse /= Determinant;\nreturn Inverse;\n}\nmat4 czm_inverseMatrix(mat4 m)\n{\nfloat Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\nfloat Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];\nfloat Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];\nfloat Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\nfloat Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];\nfloat Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];\nfloat Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\nfloat Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];\nfloat Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];\nfloat Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\nfloat Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];\nfloat Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];\nfloat Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\nfloat Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];\nfloat Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];\nfloat Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\nfloat Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];\nfloat Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];\nconst vec4 SignA = vec4( 1.0, -1.0,  1.0, -1.0);\nconst vec4 SignB = vec4(-1.0,  1.0, -1.0,  1.0);\nvec4 Fac0 = vec4(Coef00, Coef00, Coef02, Coef03);\nvec4 Fac1 = vec4(Coef04, Coef04, Coef06, Coef07);\nvec4 Fac2 = vec4(Coef08, Coef08, Coef10, Coef11);\nvec4 Fac3 = vec4(Coef12, Coef12, Coef14, Coef15);\nvec4 Fac4 = vec4(Coef16, Coef16, Coef18, Coef19);\nvec4 Fac5 = vec4(Coef20, Coef20, Coef22, Coef23);\nvec4 Vec0 = vec4(m[1][0], m[0][0], m[0][0], m[0][0]);\nvec4 Vec1 = vec4(m[1][1], m[0][1], m[0][1], m[0][1]);\nvec4 Vec2 = vec4(m[1][2], m[0][2], m[0][2], m[0][2]);\nvec4 Vec3 = vec4(m[1][3], m[0][3], m[0][3], m[0][3]);\nvec4 Inv0 = SignA * (Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);\nvec4 Inv1 = SignB * (Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);\nvec4 Inv2 = SignA * (Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);\nvec4 Inv3 = SignB * (Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);\nmat4 Inverse = mat4(Inv0, Inv1, Inv2, Inv3);\nvec4 Row0 = vec4(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);\nfloat Determinant = dot(m[0], Row0);\nInverse /= Determinant;\nreturn Inverse;\n}\n",czm_isEmpty:"bool czm_isEmpty(czm_raySegment interval)\n{\nreturn (interval.stop < 0.0);\n}\n",czm_isFull:"bool czm_isFull(czm_raySegment interval)\n{\nreturn (interval.start == 0.0 && interval.stop == czm_infinity);\n}\n",czm_latitudeToWebMercatorFraction:"float czm_latitudeToWebMercatorFraction(float latitude, float southMercatorY, float oneOverMercatorHeight)\n{\nfloat sinLatitude = sin(latitude);\nfloat mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\nreturn (mercatorY - southMercatorY) * oneOverMercatorHeight;\n}\n",czm_lineDistance:"float czm_lineDistance(vec2 point1, vec2 point2, vec2 point) {\nreturn abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / distance(point2, point1);\n}\n",czm_luminance:"float czm_luminance(vec3 rgb)\n{\nconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\nreturn dot(rgb, W);\n}\n",czm_metersPerPixel:"float czm_metersPerPixel(vec4 positionEC, float pixelRatio)\n{\nfloat width = czm_viewport.z;\nfloat height = czm_viewport.w;\nfloat pixelWidth;\nfloat pixelHeight;\nfloat top = czm_frustumPlanes.x;\nfloat bottom = czm_frustumPlanes.y;\nfloat left = czm_frustumPlanes.z;\nfloat right = czm_frustumPlanes.w;\nif (czm_sceneMode == czm_sceneMode2D || czm_orthographicIn3D == 1.0)\n{\nfloat frustumWidth = right - left;\nfloat frustumHeight = top - bottom;\npixelWidth = frustumWidth / width;\npixelHeight = frustumHeight / height;\n}\nelse\n{\nfloat distanceToPixel = -positionEC.z;\nfloat inverseNear = 1.0 / czm_currentFrustum.x;\nfloat tanTheta = top * inverseNear;\npixelHeight = 2.0 * distanceToPixel * tanTheta / height;\ntanTheta = right * inverseNear;\npixelWidth = 2.0 * distanceToPixel * tanTheta / width;\n}\nreturn max(pixelWidth, pixelHeight) * pixelRatio;\n}\nfloat czm_metersPerPixel(vec4 positionEC)\n{\nreturn czm_metersPerPixel(positionEC, czm_pixelRatio);\n}\n",czm_modelToWindowCoordinates:"vec4 czm_modelToWindowCoordinates(vec4 position)\n{\nvec4 q = czm_modelViewProjection * position;\nq.xyz /= q.w;\nq.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz;\nreturn q;\n}\n",czm_multiplyWithColorBalance:"vec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)\n{\nconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\nvec3 target = left * right;\nfloat leftLuminance = dot(left, W);\nfloat rightLuminance = dot(right, W);\nfloat targetLuminance = dot(target, W);\nreturn ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;\n}\n",czm_nearFarScalar:"float czm_nearFarScalar(vec4 nearFarScalar, float cameraDistSq)\n{\nfloat valueAtMin = nearFarScalar.y;\nfloat valueAtMax = nearFarScalar.w;\nfloat nearDistanceSq = nearFarScalar.x * nearFarScalar.x;\nfloat farDistanceSq = nearFarScalar.z * nearFarScalar.z;\nfloat t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq);\nt = pow(clamp(t, 0.0, 1.0), 0.2);\nreturn mix(valueAtMin, valueAtMax, t);\n}\n",czm_octDecode:"vec3 czm_octDecode(vec2 encoded, float range)\n{\nif (encoded.x == 0.0 && encoded.y == 0.0) {\nreturn vec3(0.0, 0.0, 0.0);\n}\nencoded = encoded / range * 2.0 - 1.0;\nvec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\nif (v.z < 0.0)\n{\nv.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\n}\nreturn normalize(v);\n}\nvec3 czm_octDecode(vec2 encoded)\n{\nreturn czm_octDecode(encoded, 255.0);\n}\nvec3 czm_octDecode(float encoded)\n{\nfloat temp = encoded / 256.0;\nfloat x = floor(temp);\nfloat y = (temp - x) * 256.0;\nreturn czm_octDecode(vec2(x, y));\n}\nvoid czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)\n{\nfloat temp = encoded.x / 65536.0;\nfloat x = floor(temp);\nfloat encodedFloat1 = (temp - x) * 65536.0;\ntemp = encoded.y / 65536.0;\nfloat y = floor(temp);\nfloat encodedFloat2 = (temp - y) * 65536.0;\nvector1 = czm_octDecode(encodedFloat1);\nvector2 = czm_octDecode(encodedFloat2);\nvector3 = czm_octDecode(vec2(x, y));\n}\n",czm_packDepth:"vec4 czm_packDepth(float depth)\n{\nvec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nenc = fract(enc);\nenc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn enc;\n}\n",czm_packValue:"vec4 czm_packValue(float value)\n{\nfloat SHIFT_LEFT8 = 256.0;\nfloat SHIFT_RIGHT8 = 1.0 / 256.0;\nvec4 result;\nresult.a = 255.0;\nfloat fPos = abs(value + 9000.0) * SHIFT_RIGHT8;\nresult.b = (fPos - floor(fPos)) * SHIFT_LEFT8;\nfPos = floor(fPos) * SHIFT_RIGHT8;\nresult.g = (fPos - floor(fPos)) * SHIFT_LEFT8;\nresult.r = floor(fPos);\nresult /= 255.0;\nreturn result;\n}\n",czm_phong:"float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)\n{\nreturn czm_getLambertDiffuse(lightDirectionEC, material.normal);\n}\nfloat czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)\n{\nreturn czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);\n}\nvec4 czm_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\nfloat diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material);\nif (czm_sceneMode == czm_sceneMode3D) {\ndiffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);\n}\nfloat specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\nvec3 materialDiffuse = material.diffuse * 0.5;\nvec3 ambient = materialDiffuse;\nvec3 color = ambient + material.emission;\ncolor += materialDiffuse * diffuse * czm_lightColor;\ncolor += material.specular * specular * czm_lightColor;\nreturn vec4(color, material.alpha);\n}\nvec4 czm_private_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\nfloat diffuse = czm_private_getLambertDiffuseOfMaterial(lightDirectionEC, material);\nfloat specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\nvec3 ambient = vec3(0.0);\nvec3 color = ambient + material.emission;\ncolor += material.diffuse * diffuse * czm_lightColor;\ncolor += material.specular * specular * czm_lightColor;\nreturn vec4(color, material.alpha);\n}\n",czm_planeDistance:"float czm_planeDistance(vec4 plane, vec3 point) {\nreturn (dot(plane.xyz, point) + plane.w);\n}\nfloat czm_planeDistance(vec3 planeNormal, float planeDistance, vec3 point) {\nreturn (dot(planeNormal, point) + planeDistance);\n}\n",czm_pointAlongRay:"vec3 czm_pointAlongRay(czm_ray ray, float time)\n{\nreturn ray.origin + (time * ray.direction);\n}\n",czm_rayEllipsoidIntersectionInterval:"czm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, vec3 ellipsoid_center, vec3 ellipsoid_inverseRadii)\n{\nvec3 q = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;\nvec3 w = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;\nq = q - ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ellipsoid_center, 1.0)).xyz;\nfloat q2 = dot(q, q);\nfloat qw = dot(q, w);\nif (q2 > 1.0)\n{\nif (qw >= 0.0)\n{\nreturn czm_emptyRaySegment;\n}\nelse\n{\nfloat qw2 = qw * qw;\nfloat difference = q2 - 1.0;\nfloat w2 = dot(w, w);\nfloat product = w2 * difference;\nif (qw2 < product)\n{\nreturn czm_emptyRaySegment;\n}\nelse if (qw2 > product)\n{\nfloat discriminant = qw * qw - product;\nfloat temp = -qw + sqrt(discriminant);\nfloat root0 = temp / w2;\nfloat root1 = difference / temp;\nif (root0 < root1)\n{\nczm_raySegment i = czm_raySegment(root0, root1);\nreturn i;\n}\nelse\n{\nczm_raySegment i = czm_raySegment(root1, root0);\nreturn i;\n}\n}\nelse\n{\nfloat root = sqrt(difference / w2);\nczm_raySegment i = czm_raySegment(root, root);\nreturn i;\n}\n}\n}\nelse if (q2 < 1.0)\n{\nfloat difference = q2 - 1.0;\nfloat w2 = dot(w, w);\nfloat product = w2 * difference;\nfloat discriminant = qw * qw - product;\nfloat temp = -qw + sqrt(discriminant);\nczm_raySegment i = czm_raySegment(0.0, temp / w2);\nreturn i;\n}\nelse\n{\nif (qw < 0.0)\n{\nfloat w2 = dot(w, w);\nczm_raySegment i = czm_raySegment(0.0, -qw / w2);\nreturn i;\n}\nelse\n{\nreturn czm_emptyRaySegment;\n}\n}\n}\n",czm_readDepth:"float czm_readDepth(sampler2D depthTexture, vec2 texCoords)\n{\nreturn czm_reverseLogDepth(texture2D(depthTexture, texCoords).r);\n}\n",czm_readNonPerspective:"float czm_readNonPerspective(float value, float oneOverW) {\nreturn value * oneOverW;\n}\nvec2 czm_readNonPerspective(vec2 value, float oneOverW) {\nreturn value * oneOverW;\n}\nvec3 czm_readNonPerspective(vec3 value, float oneOverW) {\nreturn value * oneOverW;\n}\nvec4 czm_readNonPerspective(vec4 value, float oneOverW) {\nreturn value * oneOverW;\n}\n",czm_reverseLogDepth:"float czm_reverseLogDepth(float logZ)\n{\n#ifdef LOG_DEPTH\nfloat near = czm_currentFrustum.x;\nfloat far = czm_currentFrustum.y;\nfloat log2Depth = logZ * czm_log2FarDepthFromNearPlusOne;\nfloat depthFromNear = pow(2.0, log2Depth) - 1.0;\nreturn far * (1.0 - near / (depthFromNear + near)) / (far - near);\n#endif\nreturn logZ;\n}\n",czm_RGBToHSB:"const vec4 K_RGB2HSB = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec3 czm_RGBToHSB(vec3 rgb)\n{\nvec4 p = mix(vec4(rgb.bg, K_RGB2HSB.wz), vec4(rgb.gb, K_RGB2HSB.xy), step(rgb.b, rgb.g));\nvec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\nfloat d = q.x - min(q.w, q.y);\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + czm_epsilon7)), d / (q.x + czm_epsilon7), q.x);\n}\n",czm_RGBToHSL:"vec3 RGBtoHCV(vec3 rgb)\n{\nvec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0 / 3.0) : vec4(rgb.gb, 0.0, -1.0 / 3.0);\nvec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\nfloat c = q.x - min(q.w, q.y);\nfloat h = abs((q.w - q.y) / (6.0 * c + czm_epsilon7) + q.z);\nreturn vec3(h, c, q.x);\n}\nvec3 czm_RGBToHSL(vec3 rgb)\n{\nvec3 hcv = RGBtoHCV(rgb);\nfloat l = hcv.z - hcv.y * 0.5;\nfloat s = hcv.y / (1.0 - abs(l * 2.0 - 1.0) + czm_epsilon7);\nreturn vec3(hcv.x, s, l);\n}\n",czm_RGBToXYZ:"vec3 czm_RGBToXYZ(vec3 rgb)\n{\nconst mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,\n0.3576, 0.7152, 0.1192,\n0.1805, 0.0722, 0.9505);\nvec3 xyz = RGB2XYZ * rgb;\nvec3 Yxy;\nYxy.r = xyz.g;\nfloat temp = dot(vec3(1.0), xyz);\nYxy.gb = xyz.rg / temp;\nreturn Yxy;\n}\n",czm_RollerShutter:"void czm_RollerShutter(vec2 coord, vec4 region)\n{\nvec2 f = step(region.xw, coord);\nvec2 s = step(coord, region.zy);\nif (f.x * f.y * s.x * s.y < 1.0)\n{\ndiscard;\n};\n}\n",czm_s3mBatchOperation:"void czm_s3mBatchOperation(vec4 operationType, vec4 color, vec4 selectedColor, inout vec4 vertexColor, inout vec4 vertexPos, inout vec4 vIsFiltByID, vec3 translation)\n{\nfloat right_2 = operationType.x * 0.5;\nfloat right_4 = right_2 * 0.5;\nfloat right_8 = right_4 * 0.5;\nfloat right_16 = right_8 * 0.5;\nfloat isSetColor = fract(right_2);\nif(isSetColor > 0.1)\n{\nvertexColor *= color;\n}\nfloat isPicked = fract(floor(right_2)* 0.5);\nif(isPicked > 0.1)\n{\nvertexColor *= selectedColor;\n}\nfloat isHide = fract(floor(right_4)* 0.5);\nif(isHide > 0.1)\n{\nvertexColor.a = 0.0;\n}\nfloat isOffset = fract(floor(right_8)* 0.5);\nif(isOffset > 0.1)\n{\nvertexPos.xyz += translation;\n}\nfloat isClip = fract(floor(right_16) * 0.5);\nif(isClip > 0.1)\n{\nvIsFiltByID.x = 1.0;\n}\n}\nvoid czm_s3mBatchOperation(vec4 operationType, vec4 color, inout vec4 vertexColor, inout vec4 vertexPos, inout vec4 vIsFiltByID, vec3 translation, inout float fSelected)\n{\noperationType.x += 0.001;\nfloat right_2 = operationType.x * 0.5;\nfloat right_4 = right_2 * 0.5;\nfloat right_8 = right_4 * 0.5;\nfloat right_16 = right_8 * 0.5;\nfloat isSetColor = fract(right_2);\nif(isSetColor > 0.1)\n{\nvertexColor *= color;\n}\nfloat isPicked = fract(floor(right_2)* 0.5);\nif(isPicked > 0.1)\n{\nfSelected = 1.0;\n}\nfloat isHide = fract(floor(right_4)* 0.5);\nif(isHide > 0.1)\n{\nvertexColor.a = 0.0;\n}\nfloat isOffset = fract(floor(right_8)* 0.5);\nif(isOffset > 0.1)\n{\nvertexPos.xyz += translation;\n}\nfloat isClip = fract(floor(right_16) * 0.5);\nif(isClip > 0.1)\n{\nvIsFiltByID.x = 1.0;\n}\n}\nvoid czm_s3mBatchOperation(vec4 operationType, vec4 color, vec4 selectedColor, inout vec4 vertexColor, inout vec4 vertexPos, inout vec4 vIsFiltByID, vec3 translation, inout float fSelected)\n{\noperationType.x += 0.001;\nfloat right_2 = operationType.x * 0.5;\nfloat right_4 = right_2 * 0.5;\nfloat right_8 = right_4 * 0.5;\nfloat right_16 = right_8 * 0.5;\nfloat isSetColor = fract(right_2);\nif(isSetColor > 0.1)\n{\ncolor.a *= vertexColor.a;\nvertexColor = color;\n}\nfloat isPicked = fract(floor(right_2)* 0.5);\nif(isPicked > 0.1)\n{\nfSelected = 1.0;\n#ifdef REPLACE_SELECT_TYPE\nvertexColor = selectedColor;\n#else\nvertexColor *= selectedColor;\n#endif\n}\nfloat isHide = fract(floor(right_4)* 0.5);\nif(isHide > 0.1)\n{\nvertexColor.a = 0.0;\n}\nfloat isOffset = fract(floor(right_8)* 0.5);\nif(isOffset > 0.1)\n{\nvertexPos.xyz += translation;\n}\nfloat isClip = fract(floor(right_16) * 0.5);\nif(isClip > 0.1)\n{\nvIsFiltByID.x = 1.0;\n}\n}\nvoid czm_s3mBatchOperation(vec4 operationType, vec4 color, vec4 selectedColor, inout vec4 vertexColor)\n{\noperationType.x += 0.001;\nfloat right_2 = operationType.x * 0.5;\nfloat right_4 = right_2 * 0.5;\nfloat right_8 = right_4 * 0.5;\nfloat right_16 = right_8 * 0.5;\nfloat isSetColor = fract(right_2);\nif(isSetColor > 0.1)\n{\nvertexColor *= color;\n}\nfloat isPicked = fract(floor(right_2)* 0.5);\nif(isPicked > 0.1)\n{\nvertexColor *= selectedColor;\n}\nfloat isHide = fract(floor(right_4)* 0.5);\nif(isHide > 0.1)\n{\nvertexColor.a = 0.0;\n}\n}\nvoid czm_s3mBatchOperation(vec4 operationType, vec4 color, vec4 selectedColor, inout vec4 vertexColor, inout float fSelected)\n{\noperationType.x += 0.001;\nfloat right_2 = operationType.x * 0.5;\nfloat right_4 = right_2 * 0.5;\nfloat right_8 = right_4 * 0.5;\nfloat right_16 = right_8 * 0.5;\nfloat isSetColor = fract(right_2);\nif(isSetColor > 0.1)\n{\nfSelected = 1.0;\nvertexColor = color;\n}\nfloat isPicked = fract(floor(right_2)* 0.5);\nif(isPicked > 0.1)\n{\nfSelected = 1.0;\nvertexColor = selectedColor;\n}\nfloat isHide = fract(floor(right_4)* 0.5);\nif(isHide > 0.1)\n{\nvertexColor.a = 0.0;\n}\n}\nvoid czm_s3mBatchOperation(vec4 operationType, vec4 color, vec4 selectedColor, inout vec4 vertexColor, inout vec4 vertexPos, inout vec4 vIsFiltByID, vec3 translation, inout vec2 fSelected)\n{\noperationType.x += 0.001;\nfloat right_2 = operationType.x * 0.5;\nfloat right_4 = right_2 * 0.5;\nfloat right_8 = right_4 * 0.5;\nfloat right_16 = right_8 * 0.5;\nfloat isSetColor = fract(right_2);\nif(isSetColor > 0.1)\n{\nfSelected.y = 1.0;\ncolor.a *= vertexColor.a;\nvertexColor = color;\n}\nfloat isPicked = fract(floor(right_2)* 0.5);\nif(isPicked > 0.1)\n{\nfSelected.x = 1.0;\n#ifdef REPLACE_SELECT_TYPE\nvertexColor = selectedColor;\n#else\nvertexColor *= selectedColor;\n#endif\n}\nfloat isHide = fract(floor(right_4)* 0.5);\nif(isHide > 0.1)\n{\nvertexColor.a = 0.0;\n}\nfloat isOffset = fract(floor(right_8)* 0.5);\nif(isOffset > 0.1)\n{\nvertexPos.xyz += translation;\n}\nfloat isClip = fract(floor(right_16) * 0.5);\nif(isClip > 0.1)\n{\nvIsFiltByID.x = 1.0;\n}\n}\n",czm_S3MPBR:"uniform float u_metallicFactor;\nuniform float u_roughnessFactor;\nuniform vec4 u_emissiveFactor;\nuniform vec4 u_baseColorFactor;\nuniform float u_alphaCutoff;\nuniform sampler2D u_baseColorTexture;\nuniform sampler2D u_metallicRoughnessTexture;\nuniform sampler2D u_normalTexture;\nuniform sampler2D u_occlusionTexture;\nuniform sampler2D u_emissiveTexture;\nuniform vec4 u_baseColorUVOffsetAndTiling;\nuniform vec4 u_emissiveUVOffsetAndTiling;\nuniform float uSunLightON;\n#if DIR_LIGHTS > 0\nuniform vec3 uDirectionalLightDirectionEC[ DIR_LIGHTS ];\nuniform vec3 uDirectionalLightColor[ DIR_LIGHTS ];\n#endif\n#if POINT_LIGHTS > 0\nuniform vec3 uPointLightPositionEC[ POINT_LIGHTS ];\nuniform vec3 uPointLightColor[ POINT_LIGHTS ];\nuniform vec2 uPointLightDistanceAndDecay[ POINT_LIGHTS ];\n#endif\n#if SPOT_LIGHTS > 0\nuniform vec3 uSpotLightColor[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightPositionEC[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightDirectionEC[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightDistanceDecayCos[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightExponent[ SPOT_LIGHTS ];\n#endif\nconst float M_PI = 3.141592653589793;\nvec3 lambertianDiffuse(vec3 diffuseColor)\n{\nreturn diffuseColor / M_PI;\n}\nvec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH)\n{\nreturn f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\nvec3 fresnelSchlick(float metalness, float VdotH)\n{\nreturn metalness + (vec3(1.0) - metalness) * pow(1.0 - VdotH, 5.0);\n}\nvec3 F_Schlick(float ndv, vec3 spec)\n{\nreturn spec + (vec3(1.0) - spec) * pow(1.0 - ndv, 5.0);\n}\nfloat D_Phong(float g, float ndh)\n{\nfloat a = pow(8192.0, g);\nreturn (a + 2.0) / 8.0 * pow(ndh, a);\n}\nfloat smithVisibilityG1(float NdotV, float roughness)\n{\nfloat k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\nreturn NdotV / (NdotV * (1.0 - k) + k);\n}\nfloat smithVisibilityGGX(float roughness, float NdotL, float NdotV)\n{\nreturn smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);\n}\nfloat GGX(float roughness, float NdotH)\n{\nfloat roughnessSquared = roughness * roughness;\nfloat f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\nreturn roughnessSquared / (M_PI * f * f);\n}\nvoid getLightColor(vec3 lightDir, vec3 viewDir, vec3 normal, vec3 lightColor, vec3 fresnelTerm, float roughness, out vec3 diffuseTerm, out vec3 specularTerm)\n{\nvec3 h = normalize(viewDir + lightDir);\nfloat NdotL = clamp(dot(normal, lightDir), 0.001, 1.0);\nfloat NdotH = clamp(dot(normal, h), 0.0, 1.0);\nvec3 li = lightColor * NdotL;\ndiffuseTerm = li;\nspecularTerm = li * fresnelTerm * D_Phong(1.0 - roughness, NdotH);\n}\nvec3 SRGBtoLINEAR3(vec3 srgbIn)\n{\nreturn pow(srgbIn, vec3(2.2));\n}\nvec4 SRGBtoLINEAR4(vec4 srgbIn)\n{\nvec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\nreturn vec4(linearOut, srgbIn.a);\n}\nvec3 LINEARtoSRGB(vec3 linearIn)\n{\n#ifndef HDR\nreturn pow(linearIn, vec3(1.0/2.2));\n#else\nreturn linearIn;\n#endif\n}\nfloat calcLightAttenuation(float lightDistance, float cutoffDistance, float decayExponent)\n{\nreturn pow(clamp(1.0 - lightDistance / cutoffDistance, 0.0, 1.0), decayExponent);\n}\nvec4 czm_S3MPBR(vec3 normalEC, vec3 positionEC, vec2 texCoord, vec4 vertexColor)\n{\nvec3 ng = normalize(normalEC);\nvec3 positionWC = (czm_inverseView * vec4(positionEC, 1.0)).xyz;\n#ifdef HAS_NORMAL_TEXTURE\nvec3 pos_dx = dFdx(positionEC);\nvec3 pos_dy = dFdy(positionEC);\nvec3 tex_dx = dFdx(vec3(texCoord, 0.0));\nvec3 tex_dy = dFdy(vec3(texCoord, 0.0));\nvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\nt = normalize(t - ng * dot(ng, t));\nvec3 b = normalize(cross(ng, t));\nmat3 tbn = mat3(t, b, ng);\nvec3 n = texture2D(u_normalTexture, texCoord).rgb;\nn = normalize(tbn * (2.0 * n - 1.0));\n#else\nvec3 n = ng;\n#endif\nvec3 v = -normalize(positionEC);\n#ifdef DOUBLE_SIDED\nif (dot(n, v) < 0.0) {\nn = -n;\n}\n#endif\n#ifdef HAS_BASECOLOR_TEXTURE\nvec2 baseColorTexCoord = texCoord;\nbaseColorTexCoord = baseColorTexCoord * u_baseColorUVOffsetAndTiling.zw + u_baseColorUVOffsetAndTiling.xy;\nvec4 baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, baseColorTexCoord));\nbaseColorWithAlpha *= u_baseColorFactor;\n#else\nvec4 baseColorWithAlpha = u_baseColorFactor;\n#endif\nbaseColorWithAlpha *= vertexColor;\nvec3 baseColor = baseColorWithAlpha.rgb;\n#ifdef HAS_METALLICROUGHNESS_TEXTURE\nvec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, texCoord).rgb;\nfloat metalness = clamp(metallicRoughness.b, 0.0, 1.0);\nfloat roughness = clamp(metallicRoughness.g, 0.04, 1.0);\nmetalness *= u_metallicFactor;\nroughness *= u_roughnessFactor;\n#else\nfloat metalness = clamp(u_metallicFactor, 0.0, 1.0);\nfloat roughness = clamp(u_roughnessFactor, 0.04, 1.0);\n#endif\nvec3 f0 = vec3(0.04);\nvec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\nvec3 specularColor = mix(f0, baseColor, metalness);\nfloat NdotV = abs(dot(n, v)) + 0.001;\nvec3 diffuseTerm = vec3(0.0);\nvec3 specularTerm = vec3(0.0);\nvec3 fresnelTerm = F_Schlick(NdotV, specularColor);\nvec3 color = vec3(0.0);\nvec3 lightDiffuseTerm = vec3(0.0);\nvec3 lightSpecularTerm = vec3(0.0);\ngetLightColor(czm_sunDirectionEC, v, n, vec3(0.8), fresnelTerm, roughness, lightDiffuseTerm, lightSpecularTerm);\ndiffuseTerm +=lightDiffuseTerm * uSunLightON;\nspecularTerm += lightSpecularTerm * uSunLightON;\n#if DIR_LIGHTS > 0\nfor (int i = 0; i < DIR_LIGHTS; i++) {\ngetLightColor(uDirectionalLightDirectionEC[i], v, n, uDirectionalLightColor[i], fresnelTerm, roughness, lightDiffuseTerm, lightSpecularTerm);\ndiffuseTerm +=lightDiffuseTerm;\nspecularTerm += lightSpecularTerm;\n}\n#endif\n#if POINT_LIGHTS > 0\nfor (int i = 0; i < POINT_LIGHTS; i++) {\nvec3 lVector = uPointLightPositionEC[i] - v_positionEC;\nfloat lightDistance = length(lVector);\nfloat lightAttenuation = calcLightAttenuation(lightDistance, uPointLightDistanceAndDecay[i].x, uPointLightDistanceAndDecay[i].y);\nif(lightAttenuation < 0.001) {\ncontinue;\n}\nvec3 pointLightColor = uPointLightColor[i] * lightAttenuation;\nvec3 lightDiffuseTerm = vec3(0.0);\nvec3 lightSpecularTerm = vec3(0.0);\ngetLightColor(normalize(lVector), v, n, pointLightColor, fresnelTerm, roughness, lightDiffuseTerm, lightSpecularTerm);\ndiffuseTerm +=lightDiffuseTerm;\nspecularTerm += lightSpecularTerm;\n}\n#endif\n#if SPOT_LIGHTS > 0\nfor (int i = 0; i < SPOT_LIGHTS; i++) {\nvec3 lVector = uSpotLightPositionEC[i] - v_positionEC;\nfloat lightDistance = length(lVector);\nfloat lightAttenuation = calcLightAttenuation(lightDistance, uSpotLightDistanceDecayCos[i].x, uSpotLightDistanceDecayCos[i].y);\nif(lightAttenuation < 0.001) {\ncontinue;\n}\nfloat spotEffect = dot(uSpotLightDirectionEC[i], normalize(lVector));\nif(spotEffect > uSpotLightDistanceDecayCos[i].z) {\nvec3 spotLightColor = uSpotLightColor[i] * lightAttenuation * spotEffect;\nvec3 lightDiffuseTerm = vec3(0.0);\nvec3 lightSpecularTerm = vec3(0.0);\ngetLightColor(normalize(lVector), v, n, spotLightColor, fresnelTerm, roughness, lightDiffuseTerm, lightSpecularTerm);\ndiffuseTerm +=lightDiffuseTerm;\nspecularTerm += lightSpecularTerm;\n}\n}\n#endif\ncolor = baseColor;\ncolor *= max(diffuseTerm, vec3(0.0));\ncolor += max(specularTerm, vec3(0.0));\n#ifdef USE_IBL_LIGHTING\nvec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\nfloat vertexRadius = length(positionWC);\nfloat horizonDotNadir = 1.0 - min(1.0, 6378137.0 / vertexRadius);\nfloat reflectionDotNadir = dot(r, normalize(positionWC));\nr.x = -r.x;\nr = -normalize(czm_temeToPseudoFixed * r);\nr.x = -r.x;\nfloat inverseRoughness = 1.04 - roughness;\ninverseRoughness *= inverseRoughness;\nvec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\nfloat atmosphereHeight = 0.05;\nfloat blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\nfloat blendRegionOffset = roughness * -1.0;\nfloat farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\nfloat aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\nfloat farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\nfloat smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\nvec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\nvec3 nadirColor = belowHorizonColor * 0.5;\nvec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\nvec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\nvec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\nvec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\nfloat diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\nfloat diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\nvec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\nfloat notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\nvec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\nspecularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\nspecularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\nvec2 iblFactor = vec2(1.0);\nfloat luminanceAtZenith = 0.5;\n#ifdef USE_SUN_LUMINANCE\nfloat LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * czm_sunDirectionEC), normalize(positionWC * -1.0)), 0.001, 1.0);\nfloat S = acos(LdotZenith);\nfloat NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\nfloat sunNdotL = clamp(dot(n, czm_sunDirectionEC), 0.001, 1.0);\nfloat gamma = acos(sunNdotL);\nfloat numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(sunNdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\nfloat denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\nfloat luminance = luminanceAtZenith * (numerator / denominator);\n#endif\nvec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, 1.0 - roughness)).rg;\nvec3 IBLColor = (diffuseIrradiance * diffuseColor * iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * iblFactor.y);\n#ifdef USE_SUN_LUMINANCE\ncolor += IBLColor * luminance;\n#else\ncolor += IBLColor;\n#endif // end of USE_SUN_LUMINANCE\n#endif // end of USE_IBL_LIGHTING\n#ifdef HAS_OCCLUSION_TEXTURE\ncolor *= texture2D(u_occlusionTexture, texCoord).r;\n#endif\n#ifdef HAS_EMISSIVE_TEXTURE\nvec2 emissiveTexCoord = texCoord;\nemissiveTexCoord = emissiveTexCoord * u_emissiveUVOffsetAndTiling.zw + u_emissiveUVOffsetAndTiling.xy;\nvec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, emissiveTexCoord).rgb);\nemissive *= u_emissiveFactor.rgb;\ncolor += emissive;\n#else\ncolor += u_emissiveFactor.rgb;\n#endif\ncolor = LINEARtoSRGB(color);\nvec4 resultColor = vec4(color, 1.0);\n#ifdef MASK\nif (baseColorWithAlpha.a < u_alphaCutoff)\n{\ndiscard;\n}\nresultColor = vec4(color, 1.0);\n#endif\n#ifdef BLEND\nresultColor = vec4(color, baseColorWithAlpha.a);\n#endif\nreturn resultColor;\n}\n",czm_sampleAndBlend:"uniform float uParentMixDirection;\nuniform vec4 u_pickIDColor;\n#ifdef Apply_ImageryClip\nuniform sampler2D uModifyRasterTexture;\n#endif\nvec4 czm_sampleAndBlend(\nvec4 previousColor,\nsampler2D textureToSample,\nvec2 tileTextureCoordinates,\nvec4 textureCoordinateRectangle,\nvec4 textureCoordinateTranslationAndScale,\nvec4 transparentBackColor,\nbool imageryClipEnable,\nbool flipY,\nfloat textureAlpha,\nfloat textureBrightness,\nfloat textureContrast,\nfloat textureHue,\nfloat textureSaturation,\nfloat textureOneOverGamma,\nvec2 split,\nvec4 swipe,\nfloat textureMinAlpha)\n{\nvec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\ntextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\nalphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\ntextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\nvec2 translation = textureCoordinateTranslationAndScale.xy;\nvec2 scale = textureCoordinateTranslationAndScale.zw;\nvec2 textureCoordinates = tileTextureCoordinates * scale + translation;\nif(flipY)\n{\ntextureCoordinates.y = 1.0 - textureCoordinates.y;\n}\nvec4 value = texture2D(textureToSample, textureCoordinates);\nvec3 color = value.rgb;\nfloat alpha = value.a;\nif(transparentBackColor.a > 0.01)\n{\nfloat rDiff = abs(transparentBackColor.r - color.r);\nfloat gDiff = abs(transparentBackColor.g - color.g);\nfloat bDiff = abs(transparentBackColor.b - color.b);\nif(rDiff < transparentBackColor.a && gDiff < transparentBackColor.a && bDiff < transparentBackColor.a)\n{\nalpha = 0.0;\n}\n}\nif(imageryClipEnable)\n{\n#ifdef Apply_ImageryClip\nif(texture2D(uModifyRasterTexture, tileTextureCoordinates).w < 0.1)\n{\nalpha = 0.0;\n}\n#else\nalpha = 0.0;\n#endif\n}\n#if !defined(APPLY_GAMMA)\nvec4 tempColor = czm_gammaCorrect(vec4(color, alpha));\ncolor = tempColor.rgb;\nalpha = tempColor.a;\n#else\ncolor = pow(color, vec3(textureOneOverGamma));\n#endif\n#ifdef APPLY_SPLIT\nvec2 splitPosition = czm_imagerySplitPosition;\nif (split.x < 0.0 && gl_FragCoord.x > splitPosition.x) {\nalpha = 0.0;\n}\nelse if (split.x > 0.0 && gl_FragCoord.x < splitPosition.x) {\nalpha = 0.0;\n}\nif(split.y < 0.0 && gl_FragCoord.y > splitPosition.y) {\nalpha = 0.0;\n}\nelse if(split.y > 0.0 && gl_FragCoord.y < splitPosition.y) {\nalpha = 0.0;\n}\n#if TEXTURE_UNITS < 2\nif(alpha == 0.0)\n{\ndiscard;\n}\n#endif\n#endif\n#ifdef APPLY_SWIPE\nif (gl_FragCoord.x < swipe.x || gl_FragCoord.y > swipe.y) {\nalpha = 0.0;\n}\nelse if (gl_FragCoord.x > swipe.z || gl_FragCoord.y < swipe.w) {\nalpha = 0.0;\n}\n#if TEXTURE_UNITS < 2\nif(alpha == 0.0)\n{\ndiscard;\n}\n#endif\n#endif\n#ifdef APPLY_BRIGHTNESS\ncolor = mix(vec3(0.0), color, textureBrightness);\n#endif\n#ifdef APPLY_CONTRAST\ncolor = mix(vec3(0.5), color, textureContrast);\n#endif\n#ifdef APPLY_HUE\ncolor = czm_hue(color, textureHue);\n#endif\n#ifdef APPLY_SATURATION\ncolor = czm_saturation(color, textureSaturation);\n#endif\n#ifdef ALPHAFILTER\nif(alpha <= textureMinAlpha)\n{\nreturn previousColor.rgba;\n}\n#endif\nfloat sourceAlpha = alpha * textureAlpha;\nfloat outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\nvec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\nreturn vec4(outColor, outAlpha);\n}\nvec4 sampleAndBlendParent(\nvec4 previousColor,\nsampler2D textureToSample,\nvec2 tileTextureCoordinates,\nvec4 textureCoordinateRectangle,\nvec4 textureCoordinateTranslationAndScale,\nvec4 transparentBackColor,\nbool flipY,\nfloat textureAlpha,\nfloat textureBrightness,\nfloat textureContrast,\nfloat textureHue,\nfloat textureSaturation,\nfloat textureOneOverGamma,\nvec2 split,\nvec4 swipe,\nfloat textureMinAlpha)\n{\nvec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\ntextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\nalphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\ntextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\nvec2 translation = textureCoordinateTranslationAndScale.xy;\nvec2 scale = textureCoordinateTranslationAndScale.zw;\nvec2 textureCoordinates = tileTextureCoordinates * scale + translation;\nif(flipY)\n{\ntextureCoordinates.y = 1.0 - textureCoordinates.y;\n}\nvec4 value = texture2D(textureToSample, textureCoordinates);\nif(uParentMixDirection > 0.0 && value.a > 0.01)\n{\nvalue.a = 0.0;\nbool blend = false;\nfloat mixDirection = uParentMixDirection;\nif( mixDirection > 7.0 )\n{\nif(tileTextureCoordinates.y <0.3)\n{\nblend = true;\n}\nmixDirection-=8.0;\n}\nelse if( mixDirection > 3.0)\n{\nif(tileTextureCoordinates.y >0.7)\n{\nblend = true;\n}\nmixDirection-=4.0;\n}\nif(blend)\n{\nfloat mixY = abs(tileTextureCoordinates.y-0.5);\nfloat mixValue = 10.0*mixY;\nmixValue = clamp((mixValue - 4.0), 0.0, 1.0);\nvalue.a = mixValue;\n}\nblend = false;\nif( mixDirection > 1.5)\n{\nif(tileTextureCoordinates.x >0.7)\n{\nblend = true;\n}\nmixDirection-=2.0;\n}\nelse if( mixDirection > 0.5)\n{\nif(tileTextureCoordinates.x <0.3)\n{\nblend = true;\n}\n}\nif(blend)\n{\nfloat mixValue = 10.0*abs(tileTextureCoordinates.x-0.5);\nmixValue = clamp((mixValue - 4.0), 0.0, 1.0);\nvalue.a = max(mixValue, value.a);\n}\n}\nvec3 color = value.rgb;\nfloat alpha = value.a;\nif(transparentBackColor.a > 0.01)\n{\nfloat rDiff = abs(transparentBackColor.r - color.r);\nfloat gDiff = abs(transparentBackColor.g - color.g);\nfloat bDiff = abs(transparentBackColor.b - color.b);\nif(rDiff < transparentBackColor.a && gDiff < transparentBackColor.a && bDiff < transparentBackColor.a)\n{\nalpha = 0.0;\n}\n}\n#if !defined(APPLY_GAMMA)\nvec4 tempColor = czm_gammaCorrect(vec4(color, alpha));\ncolor = tempColor.rgb;\nalpha = tempColor.a;\n#else\ncolor = pow(color, vec3(textureOneOverGamma));\n#endif\n#ifdef APPLY_SPLIT\nvec2 splitPosition = czm_imagerySplitPosition;\nif (split.x < 0.0 && gl_FragCoord.x > splitPosition.x) {\nalpha = 0.0;\n}\nelse if (split.x > 0.0 && gl_FragCoord.x < splitPosition.x) {\nalpha = 0.0;\n}\nif(split.y < 0.0 && gl_FragCoord.y > splitPosition.y) {\nalpha = 0.0;\n}\nelse if(split.y > 0.0 && gl_FragCoord.y < splitPosition.y) {\nalpha = 0.0;\n}\n#if TEXTURE_UNITS < 2\nif(alpha == 0.0)\n{\ndiscard;\n}\n#endif\n#endif\n#ifdef APPLY_SWIPE\nif (gl_FragCoord.x < swipe.x || gl_FragCoord.y > swipe.y) {\nalpha = 0.0;\n}\nelse if (gl_FragCoord.x > swipe.z || gl_FragCoord.y < swipe.w) {\nalpha = 0.0;\n}\n#if TEXTURE_UNITS < 2\nif(alpha == 0.0)\n{\ndiscard;\n}\n#endif\n#endif\n#ifdef APPLY_BRIGHTNESS\ncolor = mix(vec3(0.0), color, textureBrightness);\n#endif\n#ifdef APPLY_CONTRAST\ncolor = mix(vec3(0.5), color, textureContrast);\n#endif\n#ifdef APPLY_HUE\ncolor = czm_hue(color, textureHue);\n#endif\n#ifdef APPLY_SATURATION\ncolor = czm_saturation(color, textureSaturation);\n#endif\n#ifdef ALPHAFILTER\nif(alpha <= textureMinAlpha)\n{\nreturn previousColor.rgba;\n}\n#endif\nfloat sourceAlpha = alpha * textureAlpha;\nfloat outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\nvec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\nreturn vec4(outColor, outAlpha);\n}\nvec4 mvtTextureSampleAndBlend(\nvec4 previousColor,\nsampler2D textureToSample,\nsampler2D idTextureToSample,\nvec2 tileTextureCoordinates,\nvec4 textureCoordinateRectangle,\nvec4 textureCoordinateTranslationAndScale,\nvec4 selectColor,\nfloat textureAlpha,\nfloat textureOneOverGamma,\nvec4 swipe)\n{\n#ifdef APPLY_SWIPE\nvec2 f = step(swipe.xw, vec2(gl_FragCoord.xy));\nvec2 s = step(vec2(gl_FragCoord.xy), swipe.zy);\nif (f.x * f.y * s.x * s.y < 1.0) {\nreturn previousColor;\n};\n#endif\nvec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\ntextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\nalphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\ntextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\nvec2 translation = textureCoordinateTranslationAndScale.xy;\nvec2 scale = textureCoordinateTranslationAndScale.zw;\nvec2 textureCoordinates = tileTextureCoordinates * scale + translation;\nvec4 value = texture2D(textureToSample, textureCoordinates);\nvec4 idColor = texture2D(idTextureToSample, textureCoordinates);\nif(idColor.r == u_pickIDColor.r && idColor.g == u_pickIDColor.g && idColor.b == u_pickIDColor.b){\nvalue.rgb = selectColor.rgb;\n}\nvec3 color = value.rgb;\nfloat alpha = value.a;\n#if !defined(APPLY_GAMMA)\nvec4 tempColor = czm_gammaCorrect(vec4(color, alpha));\ncolor = tempColor.rgb;\nalpha = tempColor.a;\n#else\ncolor = pow(color, vec3(textureOneOverGamma));\n#endif\nfloat sourceAlpha = alpha * textureAlpha;\nfloat outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\nvec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\nreturn vec4(outColor, outAlpha);\n}\nvec4 gridTextureSampleAndBlend(\nvec4 previousColor,\nsampler2D textureToSample,\nvec2 tileTextureCoordinates,\nvec4 textureCoordinateRectangle,\nvec4 textureCoordinateTranslationAndScale)\n{\nfloat textureAlpha = 1.0;\nvec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\ntextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\nalphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\ntextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\nvec2 translation = textureCoordinateTranslationAndScale.xy;\nvec2 scale = textureCoordinateTranslationAndScale.zw;\nvec2 textureCoordinates = tileTextureCoordinates * scale + translation;\nvec4 value = texture2D(textureToSample, textureCoordinates);\nvec3 color = value.rgb;\nfloat alpha = value.a;\nfloat sourceAlpha = alpha * textureAlpha;\nfloat outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\nvec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\nreturn vec4(outColor, outAlpha);\n}\n",czm_sampleOctahedralProjection:"vec3 czm_sampleOctahedralProjectionWithFiltering(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod)\n{\ndirection /= dot(vec3(1.0), abs(direction));\nvec2 rev = abs(direction.zx) - vec2(1.0);\nvec2 neg = vec2(direction.x < 0.0 ? rev.x : -rev.x,\ndirection.z < 0.0 ? rev.y : -rev.y);\nvec2 uv = direction.y < 0.0 ? neg : direction.xz;\nvec2 coord = 0.5 * uv + vec2(0.5);\nvec2 pixel = 1.0 / textureSize;\nif (lod > 0.0)\n{\nfloat scale = 1.0 / pow(2.0, lod);\nfloat offset = ((textureSize.y + 1.0) / textureSize.x);\ncoord.x *= offset;\ncoord *= scale;\ncoord.x += offset + pixel.x;\ncoord.y += (1.0 - (1.0 / pow(2.0, lod - 1.0))) + pixel.y * (lod - 1.0) * 2.0;\n}\nelse\n{\ncoord.x *= (textureSize.y / textureSize.x);\n}\n#ifndef OES_texture_float_linear\nvec3 color1 = texture2D(projectedMap, coord + vec2(0.0, pixel.y)).rgb;\nvec3 color2 = texture2D(projectedMap, coord + vec2(pixel.x, 0.0)).rgb;\nvec3 color3 = texture2D(projectedMap, coord + pixel).rgb;\nvec3 color4 = texture2D(projectedMap, coord).rgb;\nvec2 texturePosition = coord * textureSize;\nfloat fu = fract(texturePosition.x);\nfloat fv = fract(texturePosition.y);\nvec3 average1 = mix(color4, color2, fu);\nvec3 average2 = mix(color1, color3, fu);\nvec3 color = mix(average1, average2, fv);\n#else\nvec3 color = texture2D(projectedMap, coord).rgb;\n#endif\nreturn color;\n}\nvec3 czm_sampleOctahedralProjection(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod, float maxLod) {\nfloat currentLod = floor(lod + 0.5);\nfloat nextLod = min(currentLod + 1.0, maxLod);\nvec3 colorCurrentLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, currentLod);\nvec3 colorNextLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, nextLod);\nreturn mix(colorNextLod, colorCurrentLod, nextLod - lod);\n}\n",czm_saturation:"vec3 czm_saturation(vec3 rgb, float adjustment)\n{\nconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\nvec3 intensity = vec3(dot(rgb, W));\nreturn mix(intensity, rgb, adjustment);\n}\n",czm_shadowDepthCompare:"float czm_sampleShadowMap(samplerCube shadowMap, vec3 d)\n{\nreturn czm_unpackDepth(textureCube(shadowMap, d));\n}\nfloat czm_sampleShadowMap(sampler2D shadowMap, vec2 uv)\n{\n#ifdef USE_SHADOW_DEPTH_TEXTURE\nreturn texture2D(shadowMap, uv).r;\n#else\nreturn czm_unpackDepth(texture2D(shadowMap, uv));\n#endif\n}\nfloat czm_shadowDepthCompare(samplerCube shadowMap, vec3 uv, float depth)\n{\nreturn step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\nfloat czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth)\n{\nreturn step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\n",czm_shadowVisibility:"float czm_private_shadowVisibility(float visibility, float nDotL, float normalShadingSmooth, float darkness)\n{\n#ifdef USE_NORMAL_SHADING\n#ifdef USE_NORMAL_SHADING_SMOOTH\nfloat strength = clamp(nDotL / normalShadingSmooth, 0.0, 1.0);\n#else\nfloat strength = step(0.0, nDotL);\n#endif\nvisibility *= strength;\n#endif\nvisibility = max(visibility, darkness);\nreturn visibility;\n}\n#ifdef USE_CUBE_MAP_SHADOW\nfloat czm_shadowVisibility(samplerCube shadowMap, czm_shadowParameters shadowParameters)\n{\nfloat depthBias = shadowParameters.depthBias;\nfloat depth = shadowParameters.depth;\nfloat nDotL = shadowParameters.nDotL;\nfloat normalShadingSmooth = shadowParameters.normalShadingSmooth;\nfloat darkness = shadowParameters.darkness;\nvec3 uvw = shadowParameters.texCoords;\ndepth -= depthBias;\nfloat visibility = czm_shadowDepthCompare(shadowMap, uvw, depth);\nreturn czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#else\nfloat czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters)\n{\nfloat depthBias = shadowParameters.depthBias;\nfloat depth = shadowParameters.depth;\nfloat nDotL = shadowParameters.nDotL;\nfloat normalShadingSmooth = shadowParameters.normalShadingSmooth;\nfloat darkness = shadowParameters.darkness;\nvec2 uv = shadowParameters.texCoords;\ndepth -= depthBias;\n#ifdef USE_SOFT_SHADOWS\nvec2 texelStepSize = shadowParameters.texelStepSize;\nfloat radius = 1.0;\nfloat dx0 = -texelStepSize.x * radius;\nfloat dy0 = -texelStepSize.y * radius;\nfloat dx1 = texelStepSize.x * radius;\nfloat dy1 = texelStepSize.y * radius;\nfloat visibility = (\nczm_shadowDepthCompare(shadowMap, uv, depth) +\nczm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\nczm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\nczm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\nczm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\nczm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\nczm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\nczm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\nczm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n) * (1.0 / 9.0);\n#else\nfloat visibility = czm_shadowDepthCompare(shadowMap, uv, depth);\n#endif\nreturn czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#endif\n",czm_signNotZero:"float czm_signNotZero(float value)\n{\nreturn value >= 0.0 ? 1.0 : -1.0;\n}\nvec2 czm_signNotZero(vec2 value)\n{\nreturn vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\n}\nvec3 czm_signNotZero(vec3 value)\n{\nreturn vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z));\n}\nvec4 czm_signNotZero(vec4 value)\n{\nreturn vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w));\n}\n",czm_sketchMode:"uniform sampler2D uNormalDepthTexture;\nuniform int uFillStyle;\nfloat edgeDetection(float lineWidth)\n{\nvec2 center = gl_FragCoord.xy / czm_globeDepthTextureDim.xy;\nvec2 off = lineWidth / czm_globeDepthTextureDim.xy;\nvec4 tex_nw = vec4(center.x+off.x, center.y+off.y, 1.0, 1.0);\nvec4 val_nw = texture2D(uNormalDepthTexture, tex_nw.xy);\nval_nw.xyz = (val_nw.xyz * 2.0) - 1.0;\nvec4 tex_ne = vec4(center.x-off.x, center.y+off.y, 1.0, 1.0);\nvec4 val_ne =  texture2D(uNormalDepthTexture, tex_ne.xy);\nval_ne.xyz = (val_ne.xyz * 2.0) - 1.0;\nvec4 tex_sw = vec4(center.x+off.x, center.y-off.y, 1.0, 1.0);\nvec4 val_sw = texture2D(uNormalDepthTexture, tex_sw.xy);\nval_sw.xyz = (val_sw.xyz * 2.0 ) - 1.0;\nvec4 tex_se = vec4(center.x-off.x, center.y-off.y, 1.0, 1.0);\nvec4 val_se = texture2D(uNormalDepthTexture, tex_se.xy);\nval_se.xyz = (val_se.xyz * 2.0) - 1.0;\nfloat discontinuity = 0.0;\nfloat dot0 = dot(val_nw.xyz, val_se.xyz);\nfloat dot1 = dot(val_ne.xyz, val_sw.xyz);\ndiscontinuity = 0.5*(dot0+dot1);\nreturn discontinuity;\n}\nvec4 czm_sketchMode(vec4 inputColor, vec4 lineColor, float lineWidth)\n{\nvec4 outputColor = inputColor;\nfloat discontinuity = edgeDetection(lineWidth);\ndiscontinuity = clamp(discontinuity, 0.0, 1.0);\nif(uFillStyle == 1)\n{\noutputColor = lineColor;\noutputColor.a = (1.0 - sign(discontinuity - 0.5)) * 0.5;\noutputColor.a *= lineColor.a;\n}\nelse\n{\nvec3 mixLineColor = mix(inputColor.rgb, vec3(lineColor.rgb), lineColor.a);\noutputColor.rgb = mix(mixLineColor, inputColor.rgb, discontinuity);\n}\nreturn outputColor;\n}\n",czm_sphericalHarmonics:"vec3 czm_sphericalHarmonics(vec3 normal, vec3 coefficients[9])\n{\nconst float c1 = 0.429043;\nconst float c2 = 0.511664;\nconst float c3 = 0.743125;\nconst float c4 = 0.886227;\nconst float c5 = 0.247708;\nvec3 L00 = coefficients[0];\nvec3 L1_1 = coefficients[1];\nvec3 L10 = coefficients[2];\nvec3 L11 = coefficients[3];\nvec3 L2_2 = coefficients[4];\nvec3 L2_1 = coefficients[5];\nvec3 L20 = coefficients[6];\nvec3 L21 = coefficients[7];\nvec3 L22 = coefficients[8];\nfloat x = normal.x;\nfloat y = normal.y;\nfloat z = normal.z;\nreturn c1 * L22 * (x * x - y * y) + c3 * L20 * z * z + c4 * L00 - c5 * L20 +\n2.0 * c1 * (L2_2 * x * y + L21 * x * z + L2_1 * y * z) +\n2.0 * c2 * (L11 * x + L1_1 * y + L10 * z);\n}\n",czm_tangentToEyeSpaceMatrix:"mat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 bitangentEC)\n{\nvec3 normal = normalize(normalEC);\nvec3 tangent = normalize(tangentEC);\nvec3 bitangent = normalize(bitangentEC);\nreturn mat3(tangent.x  , tangent.y  , tangent.z,\nbitangent.x, bitangent.y, bitangent.z,\nnormal.x   , normal.y   , normal.z);\n}\n",czm_transformPlane:"vec4 czm_transformPlane(vec4 clippingPlane, mat4 transform) {\nvec3 transformedDirection = normalize((transform * vec4(clippingPlane.xyz, 0.0)).xyz);\nvec3 transformedPosition = (transform * vec4(clippingPlane.xyz * -clippingPlane.w, 1.0)).xyz;\nvec4 transformedPlane;\ntransformedPlane.xyz = transformedDirection;\ntransformedPlane.w = -dot(transformedDirection, transformedPosition);\nreturn transformedPlane;\n}\n",czm_translateRelativeToEye:"vec4 czm_translateRelativeToEye(vec3 high, vec3 low)\n{\nvec3 highDifference = high - czm_encodedCameraPositionMCHigh;\nif(length(highDifference) == 0.0) {\nhighDifference = vec3(0);\n}\nvec3 lowDifference = low - czm_encodedCameraPositionMCLow;\nreturn vec4(highDifference + lowDifference, 1.0);\n}\n",czm_translucentPhong:"vec4 czm_translucentPhong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\nfloat diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal);\nif (czm_sceneMode == czm_sceneMode3D) {\ndiffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal);\n}\ndiffuse = clamp(diffuse, 0.0, 1.0);\nfloat specular = czm_getSpecular(lightDirectionEC, toEye, material.normal, material.shininess);\nvec3 materialDiffuse = material.diffuse * 0.5;\nvec3 ambient = materialDiffuse;\nvec3 color = ambient + material.emission;\ncolor += materialDiffuse * diffuse * czm_lightColor;\ncolor += material.specular * specular * czm_lightColor;\nreturn vec4(color, material.alpha);\n}\n",czm_transpose:"mat2 czm_transpose(mat2 matrix)\n{\nreturn mat2(\nmatrix[0][0], matrix[1][0],\nmatrix[0][1], matrix[1][1]);\n}\nmat3 czm_transpose(mat3 matrix)\n{\nreturn mat3(\nmatrix[0][0], matrix[1][0], matrix[2][0],\nmatrix[0][1], matrix[1][1], matrix[2][1],\nmatrix[0][2], matrix[1][2], matrix[2][2]);\n}\nmat4 czm_transpose(mat4 matrix)\n{\nreturn mat4(\nmatrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\nmatrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\nmatrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\nmatrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n}\n",czm_unpackDepth:"float czm_unpackDepth(vec4 packedDepth)\n{\nreturn dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\n",czm_unpackFloat:"#define SHIFT_RIGHT_8 0.00390625 //1.0 / 256.0\n#define SHIFT_RIGHT_16 0.00001525878 //1.0 / 65536.0\n#define SHIFT_RIGHT_24 5.960464477539063e-8//1.0 / 16777216.0\n#define BIAS 38.0\nfloat czm_unpackFloat(vec4 packedFloat)\n{\npackedFloat *= 255.0;\nfloat temp = packedFloat.w / 2.0;\nfloat exponent = floor(temp);\nfloat sign = (temp - exponent) * 2.0;\nexponent = exponent - float(BIAS);\nsign = sign * 2.0 - 1.0;\nsign = -sign;\nfloat unpacked = sign * packedFloat.x * float(SHIFT_RIGHT_8);\nunpacked += sign * packedFloat.y * float(SHIFT_RIGHT_16);\nunpacked += sign * packedFloat.z * float(SHIFT_RIGHT_24);\nreturn unpacked * pow(10.0, exponent);\n}\n",czm_unpackValue:"float czm_unpackValue(vec4 packedValue)\n{\nfloat SHIFT_LEFT16 = 65536.0;\nfloat SHIFT_LEFT8 = 256.0;\nvec4 value = packedValue * 255.0;\nreturn value.r * SHIFT_LEFT16 + value.g * SHIFT_LEFT8 + value.b - 9000.0;\n}\n",czm_vertexLogDepth:"#ifdef LOG_DEPTH\nvarying float v_depthFromNearPlusOne;\n#ifdef SHADOW_MAP\nvarying vec3 v_logPositionEC;\n#endif\n#endif\nvec4 czm_updatePositionDepth(vec4 coords) {\n#if defined(LOG_DEPTH)\n#ifdef SHADOW_MAP\nvec3 logPositionEC = (czm_inverseProjection * coords).xyz;\nv_logPositionEC = logPositionEC;\n#endif\ncoords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;\n#endif\nreturn coords;\n}\nvoid czm_vertexLogDepth()\n{\n#ifdef LOG_DEPTH\nv_depthFromNearPlusOne = 1.0 - czm_currentFrustum.x + gl_Position.w;\ngl_Position = czm_updatePositionDepth(gl_Position);\n#endif\n}\nvoid czm_vertexLogDepth(vec4 clipCoords)\n{\n#ifdef LOG_DEPTH\nv_depthFromNearPlusOne = 1.0 - czm_currentFrustum.x + clipCoords.w;\nczm_updatePositionDepth(clipCoords);\n#endif\n}\n",czm_windowToEyeCoordinates:"vec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\n{\nfloat x = 2.0 * (fragmentCoordinate.x - czm_viewport.x) / czm_viewport.z - 1.0;\nfloat y = 2.0 * (fragmentCoordinate.y - czm_viewport.y) / czm_viewport.w - 1.0;\nfloat z = (fragmentCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\nvec4 q = vec4(x, y, z, 1.0);\nq /= fragmentCoordinate.w;\nif (!(czm_inverseProjection == mat4(0.0)))\n{\nq = czm_inverseProjection * q;\n}\nelse\n{\nfloat top = czm_frustumPlanes.x;\nfloat bottom = czm_frustumPlanes.y;\nfloat left = czm_frustumPlanes.z;\nfloat right = czm_frustumPlanes.w;\nfloat near = czm_currentFrustum.x;\nfloat far = czm_currentFrustum.y;\nq.x = (q.x * (right - left) + left + right) * 0.5;\nq.y = (q.y * (top - bottom) + bottom + top) * 0.5;\nq.z = (q.z * (near - far) - near - far) * 0.5;\nq.w = 1.0;\n}\nreturn q;\n}\nvec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)\n{\n#ifdef LOG_DEPTH\nfloat near = czm_currentFrustum.x;\nfloat far = czm_currentFrustum.y;\nfloat log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;\nfloat depthFromNear = pow(2.0, log2Depth) - 1.0;\nfloat depthFromCamera = depthFromNear + near;\nvec4 windowCoord = vec4(fragmentCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);\nvec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);\neyeCoordinate.w = 1.0 / depthFromCamera;\nreturn eyeCoordinate;\n#else\nvec4 windowCoord = vec4(fragmentCoordinateXY, depthOrLogDepth, 1.0);\nvec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);\n#endif\nreturn eyeCoordinate;\n}\n",czm_writeDepthClampedToFarPlane:"#ifndef LOG_DEPTH\nvarying float v_WindowZ;\n#endif\nvoid czm_writeDepthClampedToFarPlane()\n{\n#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)\ngl_FragDepthEXT = min(v_WindowZ * gl_FragCoord.w, 1.0);\n#endif\n}\n",czm_writeLogDepth:"#ifdef LOG_DEPTH\nvarying float v_depthFromNearPlusOne;\n#ifdef POLYGON_OFFSET\nuniform vec2 u_polygonOffset;\n#endif\n#endif\nvoid czm_writeLogDepth(float depth)\n{\n#if (defined(GL_EXT_frag_depth) || defined(WEBGL2)) && defined(LOG_DEPTH)\nif (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) {\ndiscard;\n}\n#ifdef POLYGON_OFFSET\nfloat factor = u_polygonOffset[0];\nfloat units = u_polygonOffset[1];\n#ifdef GL_OES_standard_derivatives\nfloat x = dFdx(depth);\nfloat y = dFdy(depth);\nfloat m = sqrt(x * x + y * y);\ndepth += m * factor;\n#endif\n#endif\ngl_FragDepthEXT = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;\n#ifdef POLYGON_OFFSET\ngl_FragDepthEXT += czm_epsilon7 * units;\n#endif\n#endif\n}\nvoid czm_writeLogDepth() {\n#ifdef LOG_DEPTH\nczm_writeLogDepth(v_depthFromNearPlusOne);\n#endif\n}\n",czm_writeNonPerspective:"float czm_writeNonPerspective(float value, float w) {\nreturn value * w;\n}\nvec2 czm_writeNonPerspective(vec2 value, float w) {\nreturn value * w;\n}\nvec3 czm_writeNonPerspective(vec3 value, float w) {\nreturn value * w;\n}\nvec4 czm_writeNonPerspective(vec4 value, float w) {\nreturn value * w;\n}\n",czm_XYZToRGB:"vec3 czm_XYZToRGB(vec3 Yxy)\n{\nconst mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,\n-1.5371,  1.8760, -0.2040,\n-0.4985,  0.0416,  1.0572);\nvec3 xyz;\nxyz.r = Yxy.r * Yxy.g / Yxy.b;\nxyz.g = Yxy.r;\nxyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;\nreturn XYZ2RGB * xyz;\n}\n"};const q={rainDecl:"\n#ifdef HAS_RAIN\nuniform float uAnimationSpeed;\nuniform sampler2D uRippleTexture;\nuniform float uRippleScale;\nuniform float uWindIntensity;\nuniform float uRain;\nuniform float uCameraDepth;\n    \nvoid getTimeInfo(float animationSpeed, out vec2 timeVec)\n{\n\tfloat time = czm_frameNumber * animationSpeed;\n\ttime = floor(30.0 * time);\n\tfloat time_diff = floor(time*0.25);\n\ttime = mod(time, 4.0);\n\ttime_diff = mod(time_diff, 4.0);\n\ttimeVec = vec2(time, time_diff);\n}\n\nvoid getPosInfo(vec4 posMC, out vec2 posMC_frac1, out vec2 posMC_frac2)\n{\n\tfloat ripple_scale = 1.0 / uRippleScale;\n\tvec2 posXY = posMC.xy * ripple_scale;\n\tposMC_frac1 = fract(posXY);\n\tvec2 posStep = vec2(0.5);\n\tposMC_frac2 = fract(posXY + posStep);\n}\n\nfloat getAlpha(vec2 posMC_frac1)\n{\n\tvec2 dist = (posMC_frac1 - vec2(0.5)) * 2.0;\n\tdist = vec2(abs(dist.x), abs(dist.y));\n\tvec2 result = pow(dist, vec2(5.0));\n\treturn result.x + result.y;\n}\n\nvec4 getRippleValue(sampler2D uRippleTexture, vec2 timeVec, vec2 posMC_frac1, vec2 posMC_frac2, float alpha)\n{\n\tvec2 rippleUV_1 = (timeVec + posMC_frac1)*0.25;\n\tvec2 rippleUV_2 = (timeVec + posMC_frac2)*0.25;\n\tvec4 rippleValue_1 = texture2D(uRippleTexture, rippleUV_1.xy);\n\tvec4 rippleValue_2 = texture2D(uRippleTexture, rippleUV_2.xy);\n\treturn mix(rippleValue_1, rippleValue_2, alpha);\n}\n\nvec3 getRippleNormal(vec4 rippleValue, float wind_intensity, float rain, float depthFade)\n{\n\tvec2 rippleValueXY = rippleValue.xy;\n\tvec2 rippleValueZW = rippleValue.zw;\n\tconst vec2 _value = vec2(0.5);\n\tvec2 part_1 = (rippleValueZW - _value) * wind_intensity * 0.13;\n\tvec2 part_2 = (rippleValueXY - _value) * 0.6;\n\tvec2 mergedValue = mix(part_1, part_2, rain) * depthFade;\n\treturn vec3(mergedValue, 1.0);\n}\n\nfloat getNormalAlpha(vec3 normalWS,float wetness)\n{\n\tfloat valueZ = normalWS.z - 0.5;\n\tfloat wet_correction = wetness * clamp(valueZ * 2.5, 0.0, 1.0);\n\treturn pow(wet_correction, 15.0);\n}\n\nvec3 rippleNormalCorrection(vec3 rippleNormal,float normalAlpha)\n{\n\tconst vec3 blueNormal = vec3(0.0, 0.0, 1.0);\n\treturn mix(blueNormal, rippleNormal, normalAlpha);\n}\n\nvec3 rippleGenerator(sampler2D uRippleTexture, float animationSpeed,vec3 normalWS,float wetness)\n{\n\tvec2 timeVec = vec2(1.0);\n\tgetTimeInfo(animationSpeed, timeVec);\n\tvec2 posMC_frac1 = vec2(1.0);\n\tvec2 posMC_frac2 = vec2(1.0);\n\tgetPosInfo(vPositionMC, posMC_frac1, posMC_frac2);\n\tfloat alpha = getAlpha(posMC_frac1);\n\tvec4 rippleValue = getRippleValue(uRippleTexture, timeVec, posMC_frac1, posMC_frac2, alpha);\n\tvec3 rippleNormal = getRippleNormal(rippleValue, uWindIntensity, uRain, uCameraDepth);\n\tfloat normalAlpha = getNormalAlpha(normalWS, wetness);\n\treturn normalize(rippleNormalCorrection(rippleNormal, normalAlpha));\n}\n#endif\n",snowDecl:"\n#ifdef HAS_SNOW\nuniform float uSnowCoverageFactor;\nuniform sampler2D uSnowMaskTexture;\nuniform sampler2D uSnowNormalTexture;\n\nvec3 getSnowMaskValue(sampler2D uSnowMaskTexture, vec2 snowUV)\n{\n\treturn texture2D(uSnowMaskTexture, snowUV).rgb;\n}\n\nfloat getSnowCoverage(float snow_coverage, float max_snow_coverage, vec3 normalWS, float z_mask)\n{\n\tfloat normal_z = normalWS.z;\n\tnormal_z += 1.1 + z_mask;\n\tnormal_z = clamp(normal_z * 0.5, 0.0, 1.0);\n\tfloat final_snow_coverage = clamp(snow_coverage, 0.0, max_snow_coverage);\n\tfinal_snow_coverage = clamp(final_snow_coverage*normal_z, 0.0, 1.0);\n\treturn final_snow_coverage;\n}\n\nfloat getSnowCoverageWithMaskTexture(float finalSnowCoverage, float heightValue, float snow_scatter_value, float snow_scatter_alpha, float tighten_value)\n{\n\tfloat scatter_value = mix(heightValue, snow_scatter_value, snow_scatter_alpha);\n\treturn clamp((tighten_value + 1.0) * finalSnowCoverage - tighten_value * scatter_value, 0.0, 1.0);\n}\n\nfloat getSnowAlpha(vec3 normalWS, float snow_coverage, float z_mask)\n{\n\treturn clamp((normalWS.z + z_mask) * 5.0, 0.0, 1.0) * snow_coverage;\n}\n\nvec3 getFinalBaseColor(vec3 baseColor, vec3 snow_baseColor, float snowAlpha)\n{\n\treturn mix(baseColor, snow_baseColor, snowAlpha);\n}\n\nfloat getFinalRoughness(float roughness, float snow_roughness, float snowAlpha)\n{\n\treturn mix(roughness, snow_roughness, snowAlpha);\n}\n\nvec3 getFinalNormal(vec3 normalWS, vec3 snowNormal, float blendNormalValue, float snow_coverage)\n{\n\tvec3 snowNormal_part2 = vec3(snowNormal.xy - vec2(0.5), 1.0);\n\tfloat normal_alpha = (1.0 - blendNormalValue)* snow_coverage;\n\treturn mix(normalWS, snowNormal_part2, normal_alpha);\n}\n\nvoid snowGenerator(sampler2D uSnowMaskTexture, sampler2D uSnowNormalTexture, vec2 snowUV, float snow_coverage, inout vec3 normalWS, inout vec3 baseColor, inout float roughness)\n{\n\tvec3 snowMaskValue = texture2D(uSnowMaskTexture, snowUV).rgb;\n\tconst float max_snow_coverage = 1.0;\n\tconst float z_mask = 0.0;\n\tfloat snowCoverage = getSnowCoverage(snow_coverage, max_snow_coverage, normalWS, z_mask);\n\tconst float heightValue = 0.5;\n\tfloat snow_scatter_value = snowMaskValue.g;\n\tconst float snow_scatter_alpha = 0.5;\n\tconst float tighten_value = 4.0;\n    snowCoverage = getSnowCoverageWithMaskTexture(snowCoverage, heightValue, snow_scatter_value, snow_scatter_alpha, tighten_value);\n\tfloat snow_alpha = getSnowAlpha(normalWS, snowCoverage, z_mask);\n\tbaseColor = getFinalBaseColor(baseColor, vec3(snowMaskValue.r), snow_alpha);\n\troughness = getFinalRoughness(roughness, snowMaskValue.b, snow_alpha);\n\tvec3 snowNormalValue = texture2D(uSnowNormalTexture, snowUV).rgb;\n\tconst float blendNormalValue = 0.3;\n\tnormalWS = getFinalNormal(normalWS, snowNormalValue, blendNormalValue, snowCoverage);\n}\n\n#endif\n",hemisphereLightDecl:"\n#ifdef HAS_HEMISPHERE_LIGHTS\n\nuniform vec3 uSkyColor[ HEMISPHERE_LIGHTS ];\nuniform vec3 uGroundColor[ HEMISPHERE_LIGHTS ];\nuniform vec3 uHemisphereLightDirectionEC[ HEMISPHERE_LIGHTS ];\n    \nstruct HemisphereLight {\n    vec3 direction;\n    vec3 skyColor;\n    vec3 groundColor;\n};\n\nvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n    float dotNL = dot( geometry.normal, hemiLight.direction );\n    float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n    vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n    return irradiance;\n}\n\n#endif\n",pointLightDecl:"\n#ifdef HAS_POINT_LIGHTS\n\nuniform vec3 uPointLightPositionEC[ POINT_LIGHTS ];\nuniform vec3 uPointLightColor[ POINT_LIGHTS ];\nuniform vec2 uPointLightDistanceAndDecay[ POINT_LIGHTS ];\n\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float distance;\n    float decay;\n};\n\nvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n    vec3 lVector = pointLight.position - geometry.position;\n    directLight.direction = normalize( lVector );\n    float lightDistance = length( lVector );\n    directLight.color = pointLight.color;\n    directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n    directLight.visible = ( directLight.color != vec3( 0.0 ) );\n}\n\n#endif\n",spotLightDecl:"\n#ifdef HAS_SPOT_LIGHTS\n\nuniform vec3 uSpotLightColor[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightPositionEC[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightDirectionEC[ SPOT_LIGHTS ];\nuniform vec4 uSpotLightDistanceDecayCosPenumbra[ SPOT_LIGHTS ];\nuniform vec3 uSpotLightExponent[ SPOT_LIGHTS ];\n    \nstruct SpotLight {\n    vec3 position;\n    vec3 direction;\n    vec3 color;\n    float distance;\n    float decay;\n    float coneCos;\n    float penumbraCos;\n};\n\nvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n    vec3 lVector = spotLight.position - geometry.position;\n    directLight.direction = normalize( lVector );\n    float lightDistance = length( lVector );\n    float angleCos = dot( directLight.direction, spotLight.direction );\n    if ( angleCos > spotLight.coneCos ) {\n        float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n        directLight.color = spotLight.color;\n        directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n        directLight.visible = true;\n    } else {\n        directLight.color = vec3( 0.0 );\n        directLight.visible = false;\n    }\n}\n\n#endif\n",directionLightDecl:"\n#ifdef HAS_DIR_LIGHTS\n\nuniform vec3 uDirectionalLightDirectionEC[ DIR_LIGHTS ];\nuniform vec3 uDirectionalLightColor[ DIR_LIGHTS ];\n    \n#endif\n",lightSourceImpl:"\n\n#ifdef HAS_DIR_LIGHTS\nfor (int i = 0; i < DIR_LIGHTS; i++) {\n    directLight.color = uDirectionalLightColor[i];\n    directLight.direction = uDirectionalLightDirectionEC[i];\n    directLight.visible = true;\n    directPhysical( directLight, geometry, material, reflectedLight );\n}\n#endif\n\n#ifdef HAS_POINT_LIGHTS\nPointLight pointLight;\nfor (int i = 0; i < POINT_LIGHTS; i++) {\n    pointLight.position = uPointLightPositionEC[i];\n    pointLight.color = uPointLightColor[i];\n    pointLight.distance = uPointLightDistanceAndDecay[i].x;\n    pointLight.decay = uPointLightDistanceAndDecay[i].y;\n    getPointDirectLightIrradiance( pointLight, geometry, directLight );\n    if(!directLight.visible) continue;\n    directPhysical( directLight, geometry, material, reflectedLight );\n}\n#endif\n\n#ifdef HAS_SPOT_LIGHTS\nSpotLight spotLight;\nfor (int i = 0; i < SPOT_LIGHTS; i++) {\n    spotLight.position = uSpotLightPositionEC[i];\n    spotLight.color = uSpotLightColor[i];\n    spotLight.direction = uSpotLightDirectionEC[i];\n    spotLight.coneCos = uSpotLightDistanceDecayCosPenumbra[i].z;\n    spotLight.penumbraCos = uSpotLightDistanceDecayCosPenumbra[i].w;\n    getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n    if(!directLight.visible) continue;\n    directPhysical( directLight, geometry, material, reflectedLight );\n}\n#endif\n",brdf:"\n#ifdef BRDF\n#define RECIPROCAL_PI 0.31830988618\n#define M_PI 3.141592653589793\n#define EPSILON 1e-6\n#define CUBEUV_MAX_MIP 8.0\n#define CUBEUV_TEXEL_WIDTH 0.0013020833333333333\n#define CUBEUV_TEXEL_HEIGHT 0.0009765625\n#define saturate(a) clamp( a, 0.0, 1.0 )\nfloat pow2( const in float x ) { return x * x; }\n\nuniform vec4 uBaseColorFactor;\nuniform vec4 uEmissiveFactor;\nuniform float uMetallicFactor;\nuniform float uRoughnessFactor;\nuniform float uAlphaCutoff;\nuniform float uEnvMapIntensity;\nuniform float uCameraReflect;\nstruct IncidentLight {\n    vec3 direction;\n    vec3 color;\n    bool visible;\n};\n\nstruct GeometricContext {\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n};\n\nstruct PhysicalMaterial {\n    vec3\tdiffuseColor;\n    float\troughness;\n    vec3\tspecularColor;\n    float specularF90;\n};\n\nstruct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n};\n\n#ifdef HAS_BASE_TEXTURE\n    uniform sampler2D uBaseTexture;\n#endif\n\n#ifdef HAS_NORMAL_TEXTURE\n    uniform sampler2D uNormalTexture;\n    uniform float uNormalTextureScale;\n#ifdef HAS_ANISOTROPY\n    uniform vec4 uAnisotropy;\n#endif\n#endif\n\n#ifdef HAS_EMISSIVE_TEXTURE\n    uniform sampler2D uEmissionTexture;\n    uniform vec4 uEmissiveUVOffsetAndTiling;\n#endif\n\n#ifdef HAS_MetallicRoughness_TEXTURE\n    uniform sampler2D uMetallicRoughnessTexture;\n#endif\n\n#ifdef HAS_OCCLUSION_TEXTURE\n    uniform sampler2D uOcclusionTexture;\n#endif\n\n#ifdef REFRACTION\n    uniform float uIndexOfRefraction;\n#endif\n\n#ifdef HAS_TRANSMISSION\n    uniform float uTransmissionFactor;\n#endif\n\n#ifdef HAS_WETNESS\n    uniform float uWetnessFactor;\n#endif\n\n#ifdef HAS_VOLUME\n    uniform vec4 uTintColor;\n    uniform vec4 uDiffusionDistance;\n    uniform float uThickness;\n#endif\n\n#ifdef HAS_CLEARCOAT\n    uniform float uClearcoatFactor;\n    uniform float uClearcoatRoughnessFactor;\n#endif\n\n//参考UE4.24实现计算精确光源的衰减\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n    // float d = lightDistance;\n    // float r = cutoffDistance;\n    // float d2 = d * d;\n    // float attenuation = 1.0 / (d2 + 1.0); \n    // float m = saturate(1.0 - pow(d / r, 4.0));\n    // float m2 = m * m;\n    // return attenuation * m2;\n    if ( decayExponent > 0.0 ) {\n        return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\n#include <hemisphereLightDecl>\n#include <directionLightDecl>\n#include <pointLightDecl>\n#include <spotLightDecl>\n#include <snowDecl>\n#include <rainDecl>\n\n#ifdef HAS_ANISOTROPY\nvec3 getAnisotropicBentNormals(const vec3 T, const vec3 B, const vec3 N, const vec3 V, float anisotropy) {\n    vec3 anisotropicFrameDirection = anisotropy >= 0.0 ? B : T;\n    vec3 anisotropicFrameTangent = cross(normalize(anisotropicFrameDirection), V);\n    vec3 anisotropicFrameNormal = cross(anisotropicFrameTangent, anisotropicFrameDirection);\n    vec3 anisotropicNormal = normalize(mix(N, anisotropicFrameNormal, abs(anisotropy)));\n    return anisotropicNormal;\n}\n#endif\n\n#ifdef HAS_VOLUME\nvec3 computeColorAtDistanceInMedia(vec3 color, float distance) {\n    return -log(color) / distance;\n}\nvec3 cocaLambert(vec3 alpha, float distance) {\n    return exp(-alpha * distance);\n}\n#endif\n\n\nvec3 sRGBToLinear(vec3 srgbIn) \n{\n    return pow(srgbIn, vec3(2.2));\n}\n\nvec4 sRGBToLinear(vec4 srgbIn)\n{\n    srgbIn = srgbIn ;\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n    return vec4(linearOut, srgbIn.a);\n}\n\nvec3 LinearTosRGB(vec3 linearIn) \n{\n#ifndef HDR \n    return pow(linearIn, vec3(1.0/2.2));\n#else \n    return linearIn;\n#endif \n}\n\nvec3 lambertianDiffuse(vec3 diffuseColor) \n{\n    return diffuseColor * RECIPROCAL_PI;\n}\n\nvec3 applyTonemapping(vec3 linearIn) \n{\n    vec3 color = linearIn * czm_toneMappingExposure;\n    return czm_acesTonemapping(color);\n}\n\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n    float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n    return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\n\nfloat GeometrySchlickGGX(float roughness, float NoV)\n{\n    float k = pow(roughness + 1.0, 2.0) / 8.0;\n    return NoV / (NoV * (1.0 - k) + k);\n}\n\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n    float a2 = pow2( alpha );\n    float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n    return RECIPROCAL_PI * a2 / pow2( denom );\n}\n\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n    float alpha = roughness * roughness;\n    vec3 halfDir = normalize( lightDir + viewDir );\n    float dotNL = clamp( dot( normal, lightDir ), 0.001, 1.0 );\n    float dotNV = abs( dot( normal, viewDir ) ) + 0.001;\n    float dotNH = saturate( dot( normal, halfDir ) );\n    float dotLH = saturate( dot( lightDir, halfDir ) );\n    float dotVH = saturate( dot( viewDir, halfDir ) );\n    vec3 F = F_Schlick( f0, f90, dotVH );\n    float G = GeometrySchlickGGX(alpha, dotNV) * GeometrySchlickGGX(alpha, dotNL);\n    float D = D_GGX( alpha, dotNH );\n    return F * ( G * D ) / (4.0 * dotNL * dotNV);\n}\n\nvoid directPhysical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n    vec3 irradiance = dotNL * directLight.color;\n    reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n    reflectedLight.directDiffuse += irradiance * lambertianDiffuse( material.diffuseColor );\n}\n\n#ifdef HAS_NORMAL_TEXTURE\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv, vec3 mapN) {\n    float fNormalLength = length(mapN);\n    if(fNormalLength < 0.5) {\n        return surf_norm;\n    }\n    mapN = mapN * 2.0 - 1.0;\n    vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n    vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n    vec2 st0 = dFdx( uv.st );\n    vec2 st1 = dFdy( uv.st );\n    float scale = sign( st1.t * st0.s - st0.t * st1.s );\n    vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n    vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n    vec3 N = normalize( surf_norm );\n    mat3 tsn = mat3( S, T, N );\n    mapN.xy *= uNormalTextureScale;\n    mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n    return normalize( tsn * mapN );\n}\n#endif\n\n#include <cubeUV_reflection>\n\nvec3 inverseTransformDirection( in vec3 dir ) {\n    mat3 fixedToENU = mat3(czm_modelView[0][0], czm_modelView[1][0], czm_modelView[2][0], czm_modelView[0][1], czm_modelView[1][1], czm_modelView[2][1], czm_modelView[0][2], czm_modelView[1][2], czm_modelView[2][2]);\n    const mat3 yUpToZUp = mat3(1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0);\n    return normalize( yUpToZUp * fixedToENU * dir );\n}\n\nvoid indirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n    reflectedLight.indirectDiffuse += irradiance * lambertianDiffuse( material.diffuseColor );\n}\n\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n    float dotNV = saturate( dot( normal, viewDir ) );\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n    vec4 r = roughness * c0 + c1;\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n    vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n    return fab;\n}\n\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n    vec2 fab = DFGApprox( normal, viewDir, roughness );\n    vec3 Fr = specularColor;\n    vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n    float Ess = fab.x + fab.y;\n    float Ems = 1.0 - Ess;\n    vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\n    vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n    singleScatter += FssEss;\n    multiScatter += Fms * Ems;\n}\n\nvoid indirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n    vec3 singleScattering = vec3( 0.0 );\n    vec3 multiScattering = vec3( 0.0 );\n    vec3 cosineWeightedIrradiance = irradiance;\n    computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n    vec3 totalScattering = singleScattering + multiScattering;\n    vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n    reflectedLight.indirectSpecular += radiance * singleScattering;\n    reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n    reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n\nvec3 getIBLIrradiance( const in vec3 normal ) {\n    vec3 worldNormal = inverseTransformDirection( normal );\n    vec4 envMapColor = textureCubeUV( czm_hdrEnvMap, worldNormal, 1.0 );\n    return envMapColor.rgb;\n}\n\nvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n    vec3 reflectVec = reflect( - viewDir, normal );\n    reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n    reflectVec = inverseTransformDirection( reflectVec );\n    vec4 envMapColor = textureCubeUV( czm_hdrEnvMap, reflectVec, roughness );\n    return envMapColor.rgb;\n}\n\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n    return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n\nuniform float uPbrParTextureWidth;\nvoid calculateMipLevel(in vec2 inTexCoord, in vec2 vecTile, in float fMaxMip, inout float mipLevel)\n{\n\tvec2 dx = dFdx(inTexCoord * vecTile.x);\n\tvec2 dy = dFdy(inTexCoord * vecTile.y);\n\tfloat dotX = dot(dx, dx);\n\tfloat dotY = dot(dy, dy);\n\tfloat dMax = max(dotX, dotY);\n\tfloat dMin = min(dotX, dotY);\n\tfloat offset = (dMax - dMin) / (dMax + dMin);\n\toffset = clamp(offset, 0.0, 1.0);\n\tfloat d = dMax * (1.0 - offset) + dMin * offset;\n\tmipLevel = 0.5 * log2(d);\n\tmipLevel = clamp(mipLevel, 0.0, fMaxMip - 1.62);\n}\n\nvec3 getTexcoordAndMipmapLevel(vec2 uv, vec4 texMatrix, float texCoordZ) {\n    vec2 translate = texMatrix.xy;\n    float textureWidth = texMatrix.z * uPbrParTextureWidth;\n    float scale = texMatrix.z;\n    float maxMipmapLevel = texMatrix.w;\n    float mipLevel = 0.0;\n        calculateMipLevel(uv, vec2(textureWidth), maxMipmapLevel, mipLevel);\n    vec2 texCoord;\n    if(texCoordZ < -9000.0)\n    {\n        texCoord = vec2(uv.x, uv.y);\n    }\n    else\n    {\n        texCoord = fract(uv);\n        float offset = pow(2.0, mipLevel) / textureWidth;\n        texCoord = clamp(texCoord, offset, 1.0 - offset);\n        texCoord.x = (texCoord.x + translate.x) * scale;\n        texCoord.y = (texCoord.y + translate.y) * scale;\n    }\n    \n    return vec3(texCoord.xy, mipLevel);\n}\n\nvec4 brdf(in vec4 baseColorWithAlpha, vec2 texCoord, vec2 oriTexCoord, vec3 posEC, vec3 posMC, vec3 vertexNormalEC, vec4 sunLightColor, float sunLightON) {\n    vec2 uv = oriTexCoord;\n    float mipmapLevel = 0.0;\n#ifdef USE_BatchPBR\n    vec3 uvAndMiplevel = getTexcoordAndMipmapLevel(oriTexCoord, vTexMatrix, vTexCoordZ.x);\n    uv = uvAndMiplevel.xy;\n    mipmapLevel = uvAndMiplevel.z;\n#endif\n#ifndef USE_BatchPBR\n    baseColorWithAlpha = baseColorWithAlpha * uBaseColorFactor;\n#endif\n#ifdef BaseColorReplace\n    baseColorWithAlpha = uBaseColorFactor;\n#endif\n    float faceDirection = (gl_FrontFacing ? 1.0 : - 1.0) * uCameraReflect;\n    vec3 ng = normalize(vertexNormalEC);\n    #ifndef HAS_NORMAL\n        ng = normalize(czm_normal * czm_computeNormal(posMC.xyz));\n    #else\n        ng = ng * faceDirection;\n    #endif\n    \n#ifdef HAS_BASE_TEXTURE\n    #ifdef USE_BatchPBR\n        baseColorWithAlpha *= sRGBToLinear(texture2DLodEXT(uBaseTexture, uv * uTexUVOffset.zw + uTexUVOffset.xy, mipmapLevel));\n    #else\n        baseColorWithAlpha = sRGBToLinear(texture2D(uBaseTexture, oriTexCoord * uTexUVOffset.zw + uTexUVOffset.xy)) * uBaseColorFactor * vColor;\n    #endif\n#endif\n#ifdef HAS_NORMAL_TEXTURE\n    #ifdef USE_BatchPBR\n        vec3 mapN = texture2DLodEXT( uNormalTexture, uv, mipmapLevel).xyz;\n    #else\n        vec3 mapN = texture2D( uNormalTexture, uv).xyz;\n    #endif\n    vec3 n = perturbNormal2Arb(posEC, ng, oriTexCoord, mapN);\n#ifdef HAS_ANISOTROPY\n    float anisotropy = uAnisotropy.b;\n    vec3 anisotropyDirection = vec3(uAnisotropy.xy, 0.0);\n    vec3 anisotropicTangent = normalize(tbn * anisotropyDirection);\n    vec3 anisotropicBitangent = normalize(cross(tbn[2], anisotropicTangent));\n    n = getAnisotropicBentNormals(anisotropicTangent, anisotropicBitangent, n, v, anisotropy);\n#endif\n#else\n    vec3 n = ng;\n#endif\n#ifdef HAS_WETNESS\n    mat3 fixedToENU_wetness = mat3(czm_modelView[0][0], czm_modelView[1][0], czm_modelView[2][0], czm_modelView[0][1], czm_modelView[1][1], czm_modelView[2][1], czm_modelView[0][2], czm_modelView[1][2], czm_modelView[2][2]);\n    vec3 normalWS_wetness = normalize(fixedToENU_wetness * n);\n#endif\n#ifdef HAS_RAIN\n    n = rippleGenerator(uRippleTexture,uAnimationSpeed,normalWS_wetness,uWetnessFactor);\n#endif\n    vec3 baseColor = baseColorWithAlpha.rgb;\n    float roughness = uRoughnessFactor;\n    float metalness = uMetallicFactor;\n    vec4 emissiveFactor = uEmissiveFactor;\n    vec2 emissiveTexCoord = texCoord.xy;\n#ifdef PBR_THEME\n    int pbrIndex = int(vPBRIndex);\n    if(vPBRIndex < 0.0)\n    {\n        return baseColorWithAlpha;\n    }\n    mat4 pbrPar = mat4(0.0);\n    for(int i = 0;i < NUM_PBR_MATERIALS;i++)\n    {\n        if(i == pbrIndex)\n        {\n            pbrPar = uPBRMaterials[i];\n            break;\n        }\n    }\n    roughness = clamp(pbrPar[0][0], 0.04, 1.0);\n    metalness = clamp(pbrPar[0][1], 0.0, 1.0);\n    baseColor = (baseColorWithAlpha / uBaseColorFactor * vec4(pbrPar[0][2], pbrPar[0][3], pbrPar[1][0], pbrPar[1][1])).rgb;\n#endif\n#ifdef USE_BatchPBR\n    metalness = vMetallicRoughness.x;\n    roughness = vMetallicRoughness.y;\n    emissiveFactor = vEmissiveFactor;\n    emissiveTexCoord = texCoord.xy;\n#endif\n    metalness = clamp(metalness, 0.0, 1.0);\n    roughness = clamp(roughness, 0.0, 1.0);\n    \n#ifdef HAS_MetallicRoughness_TEXTURE\n    #ifdef USE_BatchPBR\n        vec3 metallicRoughness = texture2DLodEXT(uMetallicRoughnessTexture, uv, mipmapLevel).rgb;\n    #else\n        vec3 metallicRoughness = texture2D(uMetallicRoughnessTexture, oriTexCoord).rgb;\n    #endif\n    metalness = clamp(metalness * metallicRoughness.r, 0.0, 1.0);\n    roughness = clamp(roughness * metallicRoughness.g, 0.04, 1.0);\n#ifdef HAS_WETNESS\n    float fWetness = clamp(uWetnessFactor,0.0,1.0);\n    float fWetness_correction = pow(4.0*fWetness,2.0);\n    fWetness_correction = clamp(fWetness_correction,clamp(fWetness,0.0,0.9),1.0);\n    float fWerness_normalized = fWetness_correction * clamp(normalWS_wetness.z + 0.85,0.0,1.0);\n    baseColor = mix(baseColor,baseColor*0.7,fWerness_normalized);\n    roughness = mix(roughness,0.05,fWerness_normalized);\n#endif\n#ifdef HAS_SNOW\n    mat3 fixedToENU_snow = mat3(czm_modelView[0][0], czm_modelView[1][0], czm_modelView[2][0], czm_modelView[0][1], czm_modelView[1][1], czm_modelView[2][1], czm_modelView[0][2], czm_modelView[1][2], czm_modelView[2][2]);\n    vec3 normalWS_snow = normalize(fixedToENU_snow * n);\n    snowGenerator(uSnowMaskTexture,uSnowNormalTexture, oriTexCoord,uSnowCoverageFactor,normalWS_snow,baseColor,roughness);\n#endif\n#endif\n\n    vec3 lightColorHdr = vec3(2.0) * uSunLightON;   // 太阳光\n    vec3 l = normalize(czm_lightDirectionEC);\n    vec3 v = -normalize(posEC);\n    vec3 h = normalize(v + l);\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\n    vec3 specularColor = mix(f0, baseColor, metalness);\n    \n    float alpha = roughness * roughness;\n    float dotNL = clamp( dot( n, l ), 0.001, 1.0 );\n    float dotNV = abs( dot( n, v ) ) + 0.001;\n    float dotNH = saturate( dot( n, h ) );\n    float dotLH = saturate( dot( l, h ) );\n    float dotVH = saturate( dot( v, h ) );\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n    float f90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 F = F_Schlick( specularColor, f90, dotVH );\n    float G = GeometrySchlickGGX(alpha, dotNV) * GeometrySchlickGGX(alpha, dotNL);\n    float D = D_GGX( alpha, dotNH );\n    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n    vec3 specularContribution = F * G * D / (4.0 * dotNL * dotNV);\n    \n    vec3 geometryNormal = ng;\n    PhysicalMaterial material;\n    material.diffuseColor = diffuseColor;\n    vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\n    float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n    material.roughness = max( roughness, 0.0525 );\n    material.roughness += geometryRoughness;\n    material.roughness = min( material.roughness, 1.0 );\n    material.specularColor = specularColor;\n    material.specularF90 = 1.0;\n    \n    GeometricContext geometry;\n    geometry.position = posEC;\n    geometry.normal = n;\n    geometry.viewDir = v;\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    reflectedLight.directDiffuse += dotNL * lightColorHdr * diffuseContribution;\n    reflectedLight.directSpecular += dotNL * lightColorHdr * specularContribution;\n    \n    IncidentLight directLight; \n    #include <lightSourceImpl>\n    \n    vec3 irradiance = vec3(0.0);\n    vec3 radiance = vec3(0.0);\n  \n#ifdef HAS_HEMISPHERE_LIGHTS\n    HemisphereLight hemiLight;\n    hemiLight.skyColor = uSkyColor[0];\n    hemiLight.groundColor = uGroundColor[0];\n    hemiLight.direction = normalize(czm_normal * vec3(0.0, 0.0, 1.0));\n    irradiance += getHemisphereLightIrradiance( hemiLight, geometry );\n#endif\n\n#ifdef IBL\n\n#ifdef KtxEnvMap\n    mat3 fixedToENU = mat3(czm_modelView[0][0], czm_modelView[1][0], czm_modelView[2][0], czm_modelView[0][1], czm_modelView[1][1], czm_modelView[2][1], czm_modelView[0][2], czm_modelView[1][2], czm_modelView[2][2]);\n    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0);\n    vec3 cubeDir = normalize( yUpToZUp * fixedToENU * reflect(-v, n) );\n    vec3 worldNormal = normalize( yUpToZUp * fixedToENU * n );\n    irradiance += czm_sphericalHarmonics(worldNormal, czm_sphericalHarmonicCoefficients);\n    radiance += czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);\n#else\n    irradiance += getIBLIrradiance( geometry.normal );\n    radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n#endif\n    \n#else\n    vec3 positionWC = vec3(czm_inverseView * vec4(posEC, 1.0));\n    vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\n    float vertexRadius = length(positionWC);\n    float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);\n    float reflectionDotNadir = dot(r, normalize(positionWC));\n    r.x = -r.x;\n    r = -normalize(czm_temeToPseudoFixed * r);\n    r.x = -r.x;\n    float inverseRoughness = 1.04 - roughness;\n    inverseRoughness *= inverseRoughness;\n    vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\n    float atmosphereHeight = 0.05;\n    float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\n    float blendRegionOffset = roughness * -1.0;\n    float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\n    float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\n    float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\n    float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\n    vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\n    vec3 nadirColor = belowHorizonColor * 0.5;\n    vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\n    vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\n    vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\n    vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\n    float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\n    float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\n    vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\n    float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\n    vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\n    specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\n    specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\n    \n    float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * czm_sunDirectionEC), normalize(positionWC * -1.0)), 0.001, 1.0);\n    float S = acos(LdotZenith);\n    float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\n    float sunNdotL = clamp(dot(n, czm_sunDirectionEC), 0.001, 1.0);\n    float gamma = acos(sunNdotL);\n    float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(sunNdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\n    float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\n    float luminance = 0.2 * (numerator / denominator);\n    irradiance += diffuseIrradiance * luminance;\n    radiance += specularIrradiance * luminance;\n#endif\n    irradiance *= uEnvMapIntensity;\n    radiance *= uEnvMapIntensity;\n\n    indirectSpecular_Physical(radiance, irradiance, geometry, material, reflectedLight);\n\n#ifdef HAS_OCCLUSION_TEXTURE\n    #ifdef USE_BatchPBR\n        float ambientOcclusion = texture2DLodEXT(uOcclusionTexture, uv, mipmapLevel).r;\n    #else\n        float ambientOcclusion = texture2D(uOcclusionTexture, oriTexCoord.xy).r;\n    #endif\n    reflectedLight.indirectDiffuse *= ambientOcclusion;\n#ifdef IBL\n    reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n#endif\n#endif\n\nvec3 color = reflectedLight.directDiffuse + reflectedLight.directSpecular + reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;\n\n#ifdef HAS_EMISSIVE_TEXTURE\n    emissiveTexCoord = emissiveTexCoord * uEmissiveUVOffsetAndTiling.zw + uEmissiveUVOffsetAndTiling.xy;\n    vec3 emissive = texture2D(uEmissionTexture, emissiveTexCoord).rgb;\n    emissive *= emissiveFactor.rgb;\n    color += emissive;\n#else\n    color += emissiveFactor.rgb;\n#endif\n\n    color = applyTonemapping(color);\n    color = LinearTosRGB(color);\n    \n#ifdef MASK\n    if (baseColorWithAlpha.a < uAlphaCutoff)\n    {\n        discard;\n    }\n    return vec4(color.rgb, 1.0);\n#endif\n    return vec4(color.rgb, baseColorWithAlpha.a);\n}\n#endif\n",executeServerExcavationDecl:"\n#ifdef SERVEREXCAVATION\nuniform sampler2D uServerExcavationTexture;\nuniform float uServerExcavationMode;\nuniform vec4 uServerExcavationRect;\nvarying vec4 vServerExcavationVertexPos;\nvec2 CalculateServerExcavationPolyTexCoord(vec4 vertexPos, vec4 rectPos, out float ptInRect)\n{\n    vec2 vecRatio = vec2(rectPos.z - rectPos.x, rectPos.w - rectPos.y);\n    vec2 texCoord = vec2(vertexPos.x - rectPos.x, vertexPos.y - rectPos.y);\n    texCoord.x = texCoord.x / vecRatio.x;\n    texCoord.y = texCoord.y / vecRatio.y;\n    ptInRect = step(0.0, texCoord.x) * step(0.0, texCoord.y) * step(0.0, 1.0 - texCoord.x) * step(0.0, 1.0 - texCoord.y);\n    texCoord = clamp(texCoord, vec2(0.0), vec2(1.0));\n    return texCoord;\n}\nbool executeServerExcavation()\n{\n    float hasExcavation = 1.0;\n    vec2 vecExcavationTexCoord = CalculateServerExcavationPolyTexCoord(vServerExcavationVertexPos, uServerExcavationRect, hasExcavation);\n    bool excavationInside = (uServerExcavationMode < 0.5);\n    if(hasExcavation < 0.1)\n    {\n        return !excavationInside;\n    }\n    if(excavationInside)\n    {\n        return texture2D(uServerExcavationTexture, vecExcavationTexCoord.xy).r > 0.5;\n    }\n    else\n    {\n        return texture2D(uServerExcavationTexture, vecExcavationTexCoord.xy).r < 0.5;\n    }\n}\n#endif",cubeUV_reflection:"\n    #define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\t#ifdef WEBGL2\n\t\t#define texture2DGradEXT textureGrad \n\t#endif\n\n\t// These shader functions convert between the UV coordinates of a single face of\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t// sampling a textureCube (not generally normalized ).\n\n\tfloat getFace( vec3 direction ) {\n\n\t\tvec3 absDirection = abs( direction );\n\n\t\tfloat face = - 1.0;\n\n\t\tif ( absDirection.x > absDirection.z ) {\n\n\t\t\tif ( absDirection.x > absDirection.y )\n\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t} else {\n\n\t\t\tif ( absDirection.z > absDirection.y )\n\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t}\n\n\t\treturn face;\n\n\t}\n\n\t// RH coordinate system; PMREM face-indexing convention\n\tvec2 getUV( vec3 direction, float face ) {\n\n\t\tvec2 uv;\n\n\t\tif ( face == 0.0 ) {\n\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n\t\t} else if ( face == 1.0 ) {\n\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n\t\t} else if ( face == 2.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n\t\t} else if ( face == 3.0 ) {\n\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n\t\t} else if ( face == 4.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n\t\t} else {\n\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n\t\t}\n\n\t\treturn 0.5 * ( uv + 1.0 );\n\n\t}\n\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n\t\tfloat face = getFace( direction );\n\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\n\t\tfloat faceSize = exp2( mipInt );\n\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\n\t\tif ( face > 2.0 ) {\n\n\t\t\tuv.y += faceSize;\n\n\t\t\tface -= 3.0;\n\n\t\t}\n\n\t\tuv.x += face * faceSize;\n\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\n\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering\n\n\t}\n\n\t// These defines must match with PMREMGenerator\n\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\n\tfloat roughnessToMip( float roughness ) {\n\n\t\tfloat mip = 0.0;\n\n\t\tif ( roughness >= cubeUV_r1 ) {\n\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\n\t\t} else {\n\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n\t\t}\n\n\t\treturn mip;\n\n\t}\n\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\n\t\tfloat mipF = fract( mip );\n\n\t\tfloat mipInt = floor( mip );\n\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\n\t\tif ( mipF == 0.0 ) {\n\n\t\t\treturn vec4( color0, 1.0 );\n\n\t\t} else {\n\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\n\t\t}\n\n\t}\n"};function X(e){return(e=e.replace(/\/\/.*/g,"")).replace(/\/\*\*[\s\S]*?\*\//gm,(function(e){for(var n=e.match(/\n/gm).length,t="",o=0;o<n;++o)t+="\n";return t}))}function Y(e,n,t){for(var o,r=0;r<t.length;++r)t[r].name===e&&(o=t[r]);return a.e(o)||(o={name:e,glslSource:n=X(n),dependsOn:[],requiredBy:[],evaluated:!1},t.push(o)),o}function j(e,n){if(!e.evaluated){e.evaluated=!0;var t=e.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g);a.e(t)&&null!==t&&(t=t.filter((function(e,n){return t.indexOf(e)===n})),t.forEach((function(t){if(t!==e.name&&J._czmBuiltinsAndUniforms.hasOwnProperty(t)){var o=Y(t,J._czmBuiltinsAndUniforms[t],n);e.dependsOn.push(o),o.requiredBy.push(e),j(o,n)}})))}}function Z(e,n,t){var o=[],r=Y("main",n,o);j(r,o),function(e){for(var n=[],t=[];e.length>0;){var o=e.pop();t.push(o),0===o.requiredBy.length&&n.push(o)}for(;n.length>0;){var r=n.shift();e.push(r);for(var a=0;a<r.dependsOn.length;++a){var l=r.dependsOn[a],c=l.requiredBy.indexOf(r);l.requiredBy.splice(c,1),0===l.requiredBy.length&&n.push(l)}}for(var s=[],u=0;u<t.length;++u)0!==t[u].requiredBy.length&&s.push(t[u]);if(0!==s.length){for(var f="A circular dependency was found in the following built-in functions/structs/constants: \n",m=0;m<s.length;++m)f=f+s[m].name+"\n";throw new i.t(f)}}(o);for(var a="",l=o.length-1;l>=0;--l)K(t,e)&&(o[l].glslSource=F.removeUnuseMacroCode(t,e,o[l].glslSource)),a=a+o[l].glslSource+"\n";return a.replace(r.glslSource,"")}function K(e,n){return!(!a.e(e)||!a.e(n)||!e.shaderPreprocess)}function $(e){return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm,(function(e,n){var t=q[n];if(void 0===t)throw new Error("Can not resolve #include <"+n+">");return $(t)}))}function Q(e,n,t){var o,r,l,c="",s=e.sources;if(a.e(s))for(o=0,r=s.length;o<r;++o)c+="\n#line 0\n"+s[o];c=(c=X(c)).replace(/#version\s+(.*?)\n/gm,(function(e,n){if(a.e(l)&&l!==n)throw new i.t("inconsistent versions found: "+l+" and "+n);return l=n,"\n"}));var u=[];c=c.replace(/#extension.*\n/gm,(function(e){return u.push(e),"\n"})),c=c.replace(/precision\s(lowp|mediump|highp)\s(float|int);/,"");var f=e.pickColorQualifier;a.e(f)&&(c=J.createPickFragmentShaderSource(c,f));var m="";a.e(l)&&(m="#version "+l+"\n");var d=u.length;for(o=0;o<d;o++)m+=u[o];n&&(m+="#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n");var v=e.defines;if(a.e(v))for(o=0,r=v.length;o<r;++o){var p=v[o];0!==p.length&&(m+="#define "+p+"\n")}if(t.webgl2&&(m+="#define OUTPUT_DECLARATION\n\n",m+="#define WEBGL2\n\n",m+="#define texture2DLodEXT textureLod\n\n"),c=$(c),t.textureFloatLinear&&(m+="#define OES_texture_float_linear\n\n"),K(t,e)&&(c=F.removeUnuseMacroCode(t,e,c)),e.includeBuiltIns){var h=Z(e,c,t);for(u.length=0,h=h.replace(/#extension.*\n/gm,(function(e){return u.push(e),"\n"})),d=u.length,o=0;o<d;o++)m=u[o]+m;m+=h}return m+="\n#line 0\n",m+=c,t.webgl2&&(m=E(m,n)),m}function J(e){var n=(e=a.u(e,a.u.EMPTY_OBJECT)).pickColorQualifier;if(a.e(n)&&"uniform"!==n&&"varying"!==n)throw new i.t("options.pickColorQualifier must be 'uniform' or 'varying'.");this.defines=a.e(e.defines)?e.defines.slice(0):[],this.sources=a.e(e.sources)?e.sources.slice(0):[],this.pickColorQualifier=n,this.includeBuiltIns=a.u(e.includeBuiltIns,!0),this.name=a.e(e.name)?e.name:void 0}for(var ee in J.prototype.clone=function(){return new J({sources:this.sources,defines:this.defines,name:this.name,pickColorQualifier:this.pickColorQualifier,includeBuiltIns:this.includeBuiltIns})},J.replaceMain=function(e,n){return n="void "+n+"()",e.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g,n)},J.prototype.getCacheKey=function(e){const n=this.defines.slice().sort().join(","),t=this.pickColorQualifier||"";this.includeBuiltIns;return`${n}:${t}:${this.sources.join("\n")}`},J.prototype.createCombinedVertexShader=function(e){return Q(this,!1,e)},J.prototype.createCombinedFragmentShader=function(e){return Q(this,!0,e)},J._czmBuiltinsAndUniforms={},W)W.hasOwnProperty(ee)&&(J._czmBuiltinsAndUniforms[ee]=W[ee]);for(var ne in R)if(R.hasOwnProperty(ne)){var te=R[ne];"function"==typeof te.getDeclaration&&(J._czmBuiltinsAndUniforms[ne]=te.getDeclaration(ne))}J.createPickVertexShaderSource=function(e){return J.replaceMain(e,"czm_old_main")+"\nattribute vec4 pickColor; \nvarying vec4 czm_pickColor; \nvoid main() \n{ \n    czm_old_main(); \n    czm_pickColor = pickColor; \n}"},J.createPickFragmentShaderSource=function(e,n){return J.replaceMain(e,"czm_old_main")+"\n"+(n+" vec4 czm_pickColor; \nvoid main() \n{ \n    czm_old_main(); \n    if (gl_FragColor.a == 0.0) { \n       discard; \n    } \n    gl_FragColor = czm_pickColor; \n}")},J.findVarying=function(e,n){for(var t=e.sources,o=n.length,r=0;r<o;++r)for(var i=n[r],a=t.length,l=0;l<a;++l)if(-1!==t[l].indexOf(i))return i};var oe=["v_normalEC","v_normal","aNormal"];J.findNormalVarying=function(e){return J.findVarying(e,oe)};var re=["v_positionEC"];function ie(e,n,t,o){switch(n.type){case e.FLOAT:return new ae(e,n,t,o);case e.FLOAT_VEC2:return new le(e,n,t,o);case e.FLOAT_VEC3:return new ce(e,n,t,o);case e.FLOAT_VEC4:return new se(e,n,t,o);case e.SAMPLER_2D:case e.SAMPLER_CUBE:return new ue(e,n,t,o);case e.SAMPLER_2D_ARRAY:return new fe(e,n,t,o);case e.INT:case e.BOOL:return new me(e,n,t,o);case e.INT_VEC2:case e.BOOL_VEC2:return new de(e,n,t,o);case e.INT_VEC3:case e.BOOL_VEC3:return new ve(e,n,t,o);case e.INT_VEC4:case e.BOOL_VEC4:return new pe(e,n,t,o);case e.FLOAT_MAT2:return new xe(e,n,t,o);case e.FLOAT_MAT3:return new _e(e,n,t,o);case e.FLOAT_MAT4:return new ye(e,n,t,o);default:throw new g.t("Unrecognized uniform type: "+n.type+' for uniform "'+t+'".')}}function ae(e,n,t,o){this.name=t,this.value=void 0,this._value=0,this._gl=e,this._location=o}function le(e,n,o,r){this.name=o,this.value=void 0,this._value=new t.o,this._gl=e,this._location=r}function ce(e,n,t,o){this.name=t,this.value=void 0,this._value=void 0,this._gl=e,this._location=o}function se(e,n,t,o){this.name=t,this.value=void 0,this._value=void 0,this._gl=e,this._location=o}function ue(e,n,t,o){this.name=t,this.value=void 0,this._gl=e,this._location=o,this.textureUnitIndex=void 0}function fe(e,n,t,o){this.name=t,this.value=void 0,this._gl=e,this._location=o,this.textureUnitIndex=void 0,this.lastBindTextureID=void 0}function me(e,n,t,o){this.name=t,this.value=void 0,this._value=0,this._gl=e,this._location=o}function de(e,n,o,r){this.name=o,this.value=void 0,this._value=new t.o,this._gl=e,this._location=r}function ve(e,n,t,r){this.name=t,this.value=void 0,this._value=new o.t,this._gl=e,this._location=r}function pe(e,n,t,o){this.name=t,this.value=void 0,this._value=new r.e,this._gl=e,this._location=o}J.findPositionVarying=function(e){return J.findVarying(e,re)},ae.prototype.set=function(){this.value!==this._value&&(this._value=this.value,this._gl.uniform1f(this._location,this.value))},le.prototype.set=function(){var e=this.value;t.o.equals(e,this._value)||(t.o.clone(e,this._value),this._gl.uniform2f(this._location,e.x,e.y))},ce.prototype.set=function(){var e=this.value;if(a.e(e.red))T.e.equals(e,this._value)||(this._value=T.e.clone(e,this._value),this._gl.uniform3f(this._location,e.red,e.green,e.blue));else{if(!a.e(e.x))throw new i.t('Invalid vec3 value for uniform "'+this.name+'".');o.t.equals(e,this._value)||(this._value=o.t.clone(e,this._value),this._gl.uniform3f(this._location,e.x,e.y,e.z))}},se.prototype.set=function(){var e=this.value;if(a.e(e.red))T.e.equals(e,this._value)||(this._value=T.e.clone(e,this._value),this._gl.uniform4f(this._location,e.red,e.green,e.blue,e.alpha));else{if(!a.e(e.x))throw new i.t('Invalid vec4 value for uniform "'+this.name+'".');r.e.equals(e,this._value)||(this._value=r.e.clone(e,this._value),this._gl.uniform4f(this._location,e.x,e.y,e.z,e.w))}},ue.prototype.set=function(){var e=this._gl;e.activeTexture(e.TEXTURE0+this.textureUnitIndex);var n=this.value;e.bindTexture(n._target,n._texture)},ue.prototype._setSampler=function(e){return this.textureUnitIndex=e,this._gl.uniform1i(this._location,e),e+1},fe.prototype.set=function(){var e=this.value;if(!a.e(e.id)||this.lastBindTextureID!==e.id){var n=this._gl;n.activeTexture(n.TEXTURE0+this.textureUnitIndex),n.bindTexture(e._target,e._texture),this.lastBindTextureID=e.id}},fe.prototype._setSampler=function(e){return this.textureUnitIndex=e,this._gl.uniform1i(this._location,e),e+1},me.prototype.set=function(){this.value!==this._value&&(this._value=this.value,this._gl.uniform1i(this._location,this.value))},de.prototype.set=function(){var e=this.value;t.o.equals(e,this._value)||(t.o.clone(e,this._value),this._gl.uniform2i(this._location,e.x,e.y))},ve.prototype.set=function(){var e=this.value;o.t.equals(e,this._value)||(o.t.clone(e,this._value),this._gl.uniform3i(this._location,e.x,e.y,e.z))},pe.prototype.set=function(){var e=this.value;r.e.equals(e,this._value)||(r.e.clone(e,this._value),this._gl.uniform4i(this._location,e.x,e.y,e.z,e.w))};var he=new Float32Array(4);function xe(e,n,t,o){this.name=t,this.value=void 0,this._value=new x.f,this._gl=e,this._location=o}xe.prototype.set=function(){if(!x.f.equalsArray(this.value,this._value,0)){x.f.clone(this.value,this._value);var e=x.f.toArray(this.value,he);this._gl.uniformMatrix2fv(this._location,!1,e)}};var ge=new Float32Array(9);function _e(e,n,t,o){this.name=t,this.value=void 0,this._value=new f.p,this._gl=e,this._location=o}_e.prototype.set=function(){if(!f.p.equalsArray(this.value,this._value,0)){f.p.clone(this.value,this._value);var e=f.p.toArray(this.value,ge);this._gl.uniformMatrix3fv(this._location,!1,e)}};var Ce=new Float32Array(16);function ye(e,n,t,o){this.name=t,this.value=void 0,this._value=new f.y,this._gl=e,this._location=o}function Te(e,n,t,o){switch(n.type){case e.FLOAT:return new ze(e,n,t,o);case e.FLOAT_VEC2:return new be(e,n,t,o);case e.FLOAT_VEC3:return new Le(e,n,t,o);case e.FLOAT_VEC4:return new Se(e,n,t,o);case e.SAMPLER_2D:case e.SAMPLER_CUBE:return new we(e,n,t,o);case e.INT:case e.BOOL:return new De(e,n,t,o);case e.INT_VEC2:case e.BOOL_VEC2:return new Ee(e,n,t,o);case e.INT_VEC3:case e.BOOL_VEC3:return new Ae(e,n,t,o);case e.INT_VEC4:case e.BOOL_VEC4:return new Ve(e,n,t,o);case e.FLOAT_MAT2:return new Me(e,n,t,o);case e.FLOAT_MAT3:return new Ie(e,n,t,o);case e.FLOAT_MAT4:return new Pe(e,n,t,o);default:throw new g.t("Unrecognized uniform type: "+n.type+' for uniform "'+t+'".')}}function ze(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Float32Array(r),this._gl=e,this._location=o[0]}function be(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Float32Array(2*r),this._gl=e,this._location=o[0]}function Le(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Float32Array(3*r),this._gl=e,this._location=o[0]}function Se(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Float32Array(4*r),this._gl=e,this._location=o[0]}function we(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Float32Array(r),this._gl=e,this._locations=o,this.textureUnitIndex=void 0}function De(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Int32Array(r),this._gl=e,this._location=o[0]}function Ee(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Int32Array(2*r),this._gl=e,this._location=o[0]}function Ae(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Int32Array(3*r),this._gl=e,this._location=o[0]}function Ve(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Int32Array(4*r),this._gl=e,this._location=o[0]}function Me(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Float32Array(4*r),this._gl=e,this._location=o[0]}function Ie(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Float32Array(9*r),this._gl=e,this._location=o[0]}function Pe(e,n,t,o){var r=o.length;this.name=t,this.value=new Array(r),this._value=new Float32Array(16*r),this._gl=e,this._location=o[0]}ye.prototype.set=function(){if(!f.y.equalsArray(this.value,this._value,0)){f.y.clone(this.value,this._value);var e=f.y.toArray(this.value,Ce);this._gl.uniformMatrix4fv(this._location,!1,e)}},ze.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,r=0;r<n;++r){var i=e[r];i!==t[r]&&(t[r]=i,o=!0)}o&&this._gl.uniform1fv(this._location,t)},be.prototype.set=function(){for(var e=this.value,n=e.length,o=this._value,r=!1,i=0,a=0;a<n;++a){var l=e[a];t.o.equalsArray(l,o,i)||(t.o.pack(l,o,i),r=!0),i+=2}r&&this._gl.uniform2fv(this._location,o)},Le.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,r=!1,l=0,c=0;c<n;++c){var s=e[c];if(a.e(s.red))(s.red!==t[l]||s.green!==t[l+1]||s.blue!==t[l+2])&&(t[l]=s.red,t[l+1]=s.green,t[l+2]=s.blue,r=!0);else{if(!a.e(s.x))throw new i.t("Invalid vec3 value.");o.t.equalsArray(s,t,l)||(o.t.pack(s,t,l),r=!0)}l+=3}r&&this._gl.uniform3fv(this._location,t)},Se.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,l=0,c=0;c<n;++c){var s=e[c];if(a.e(s.red))T.e.equalsArray(s,t,l)||(T.e.pack(s,t,l),o=!0);else{if(!a.e(s.x))throw new i.t("Invalid vec4 value.");r.e.equalsArray(s,t,l)||(r.e.pack(s,t,l),o=!0)}l+=4}o&&this._gl.uniform4fv(this._location,t)},we.prototype.set=function(){for(var e=this._gl,n=e.TEXTURE0+this.textureUnitIndex,t=this.value,o=t.length,r=0;r<o;++r){var i=t[r];e.activeTexture(n+r),e.bindTexture(i._target,i._texture)}},we.prototype._setSampler=function(e){this.textureUnitIndex=e;for(var n=this._locations,t=n.length,o=0;o<t;++o){var r=e+o;this._gl.uniform1i(n[o],r)}return e+t},De.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,r=0;r<n;++r){var i=e[r];i!==t[r]&&(t[r]=i,o=!0)}o&&this._gl.uniform1iv(this._location,t)},Ee.prototype.set=function(){for(var e=this.value,n=e.length,o=this._value,r=!1,i=0,a=0;a<n;++a){var l=e[a];t.o.equalsArray(l,o,i)||(t.o.pack(l,o,i),r=!0),i+=2}r&&this._gl.uniform2iv(this._location,o)},Ae.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,r=!1,i=0,a=0;a<n;++a){var l=e[a];o.t.equalsArray(l,t,i)||(o.t.pack(l,t,i),r=!0),i+=3}r&&this._gl.uniform3iv(this._location,t)},Ve.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,i=0,a=0;a<n;++a){var l=e[a];r.e.equalsArray(l,t,i)||(r.e.pack(l,t,i),o=!0),i+=4}o&&this._gl.uniform4iv(this._location,t)},Me.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,r=0,i=0;i<n;++i){var a=e[i];x.f.equalsArray(a,t,r)||(x.f.pack(a,t,r),o=!0),r+=4}o&&this._gl.uniformMatrix2fv(this._location,!1,t)},Ie.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,r=0,i=0;i<n;++i){var a=e[i];f.p.equalsArray(a,t,r)||(f.p.pack(a,t,r),o=!0),r+=9}o&&this._gl.uniformMatrix3fv(this._location,!1,t)},Pe.prototype.set=function(){for(var e=this.value,n=e.length,t=this._value,o=!1,r=0,i=0;i<n;++i){var a=e[i];f.y.equalsArray(a,t,r)||(f.y.pack(a,t,r),o=!0),r+=16}o&&this._gl.uniformMatrix4fv(this._location,!1,t)};var Oe=0;function Re(e){var n=function(e,n){var t={};if(!_.e.highpFloatSupported||!_.e.highpIntSupported){var o,r,i,a,l=Fe(e),c=Fe(n),s=l.length,u=c.length;for(o=0;o<s;o++)for(r=0;r<u;r++)if(l[o]===c[r]){a="czm_mediump_"+(i=l[o]);var f=new RegExp(i+"\\b","g");n=n.replace(f,a),t[a]=i}}return{fragmentShaderText:n,duplicateUniformNames:t}}(e.vertexShaderText,e.fragmentShaderText);this._gl=e.gl,this._logShaderCompilation=e.logShaderCompilation,this._debugShaders=e.debugShaders,this._attributeLocations=e.attributeLocations,this._varyings=e.varyings,this._bufferMode=e.bufferMode,this._program=void 0,this._numberOfVertexAttributes=void 0,this._vertexAttributes=void 0,this._uniformsByName=void 0,this._uniforms=void 0,this._automaticUniforms=void 0,this._manualUniforms=void 0,this._duplicateUniformNames=n.duplicateUniformNames,this._cachedShader=void 0,this._uniformBlockLocation={},this.maximumTextureUnitIndex=void 0,this._vertexShaderSource=e.vertexShaderSource,this._vertexShaderText=e.vertexShaderText,this._fragmentShaderSource=e.fragmentShaderSource,this._fragmentShaderText=n.fragmentShaderText,this.id=Oe++}function Fe(e){var n=[],t=e.match(/uniform.*?(?![^{]*})(?=[=\[;])/g);if(a.e(t))for(var o=t.length,r=0;r<o;r++){var i=t[r].trim(),l=i.slice(i.lastIndexOf(" ")+1);n.push(l)}return n}Re.fromCache=function(e){return e=a.u(e,a.u.EMPTY_OBJECT),i.o.defined("options.context",e.context),e.context.shaderCache.getShaderProgram(e)},Re.replaceCache=function(e){return e=a.u(e,a.u.EMPTY_OBJECT),i.o.defined("options.context",e.context),e.context.shaderCache.replaceShaderProgram(e)},Object.defineProperties(Re.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},vertexAttributes:{get:function(){return Ne(this),this._vertexAttributes}},numberOfVertexAttributes:{get:function(){return Ne(this),this._numberOfVertexAttributes}},allUniforms:{get:function(){return Ne(this),this._uniformsByName}}});var Be="[Cesium WebGL] ";function Ne(e){if(!a.e(e._program)){var n=e._gl,t=function(e,n){var t=n._vertexShaderText,o=n._fragmentShaderText,r=e.createShader(e.VERTEX_SHADER);e.shaderSource(r,t),e.compileShader(r);var i=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(i,o),e.compileShader(i);var l=e.createProgram();e.attachShader(l,r),e.attachShader(l,i),e.deleteShader(r),e.deleteShader(i);var c=n._attributeLocations;if(a.e(c))for(var s in c)c.hasOwnProperty(s)&&e.bindAttribLocation(l,c[s],s);var u,f=n._varyings,m=n._bufferMode;if(a.e(f)&&a.e(m)&&e.transformFeedbackVaryings(l,f,m),e.linkProgram(l),!e.getProgramParameter(l,e.LINK_STATUS)){var d=n._debugShaders;if(!e.getShaderParameter(i,e.COMPILE_STATUS)){if(u=e.getShaderInfoLog(i),console.error(Be+"Fragment shader compile log: "+u),a.e(d)){var v=d.getTranslatedShaderSource(i);console.error(""!==v?Be+"Translated fragment shader source:\n"+v:Be+"Fragment shader translation failed.")}throw e.deleteProgram(l),new g.t("Fragment shader failed to compile.  Compile log: "+u)}if(!e.getShaderParameter(r,e.COMPILE_STATUS)){if(u=e.getShaderInfoLog(r),console.error(Be+"Vertex shader compile log: "+u),a.e(d)){var p=d.getTranslatedShaderSource(r);console.error(""!==p?Be+"Translated vertex shader source:\n"+p:Be+"Vertex shader translation failed.")}throw e.deleteProgram(l),new g.t("Vertex shader failed to compile.  Compile log: "+u)}throw u=e.getProgramInfoLog(l),console.error(Be+"Shader program link log: "+u),a.e(d)&&(console.error(Be+"Translated vertex shader source:\n"+d.getTranslatedShaderSource(r)),console.error(Be+"Translated fragment shader source:\n"+d.getTranslatedShaderSource(i))),e.deleteProgram(l),new g.t("Program failed to link.  Link log: "+u)}var h=n._logShaderCompilation;return h&&(u=e.getShaderInfoLog(r),a.e(u)&&u.length>0&&console.log(Be+"Vertex shader compile log: "+u)),h&&(u=e.getShaderInfoLog(i),a.e(u)&&u.length>0&&console.log(Be+"Fragment shader compile log: "+u)),h&&(u=e.getProgramInfoLog(l),a.e(u)&&u.length>0&&console.log(Be+"Shader program link log: "+u)),l}(n,e,e._debugShaders),o=n.getProgramParameter(t,n.ACTIVE_ATTRIBUTES),r=function(e,n){for(var t={},o=[],r=[],i=e.getProgramParameter(n,e.ACTIVE_UNIFORMS),l=0;l<i;++l){var c=e.getActiveUniform(n,l),s=-1!==c.name.indexOf("[0]",c.name.length-"[0]".length)?c.name.slice(0,c.name.length-3):c.name;if(0!==s.indexOf("gl_"))if(c.name.indexOf("[")<0){var u=e.getUniformLocation(n,s);if(null!==u){var f=ie(e,c,s,u);t[s]=f,o.push(f),f._setSampler&&r.push(f)}}else{var m,d,v,p,h=s.indexOf("[");if(h>=0){if(m=t[s.slice(0,h)],!a.e(m))continue;(d=m._locations).length<=1&&(v=m.value,null!==(p=e.getUniformLocation(n,s))&&(d.push(p),v.push(e.getUniform(n,p))))}else{d=[];for(var x=0;x<c.size;++x)null!==(p=e.getUniformLocation(n,s+"["+x+"]"))&&d.push(p);m=Te(e,c,s,d),t[s]=m,o.push(m),m._setSampler&&r.push(m)}}}return{uniformsByName:t,uniforms:o,samplerUniforms:r}}(n,t),i=function(e,n){var t=[],o=[];for(var r in n)if(n.hasOwnProperty(r)){var i=n[r],l=r,c=e._duplicateUniformNames[l];a.e(c)&&(i.name=c,l=c);var s=R[l];a.e(s)?t.push({uniform:i,automaticUniform:s}):o.push(i)}return{automaticUniforms:t,manualUniforms:o}}(e,r.uniformsByName);e._program=t,e._numberOfVertexAttributes=o,e._vertexAttributes=function(e,n,t){for(var o={},r=0;r<t;++r){var i=e.getActiveAttrib(n,r),a=e.getAttribLocation(n,i.name);o[i.name]={name:i.name,type:i.type,index:a}}return o}(n,t,o),e._uniformsByName=r.uniformsByName,e._uniforms=r.uniforms,e._automaticUniforms=i.automaticUniforms,e._manualUniforms=i.manualUniforms,e.maximumTextureUnitIndex=function(e,n,t){e.useProgram(n);for(var o=0,r=t.length,i=0;i<r;++i)o=t[i]._setSampler(o);return e.useProgram(null),o}(n,t,r.samplerUniforms)}}Re.prototype._bind=function(){Ne(this),this._gl.useProgram(this._program)},Re.prototype._setUniforms=function(e,n,t){var o,r;if(a.e(e)){var l=this._manualUniforms;for(o=l.length,r=0;r<o;++r){var c=l[r];c.value=e[c.name]()}}var s=this._automaticUniforms;for(o=s.length,r=0;r<o;++r){var u=s[r];u.uniform.value=u.automaticUniform.getValue(n)}var f=this._uniforms;for(o=f.length,r=0;r<o;++r)f[r].set();if(t){var m=this._gl,d=this._program;if(m.validateProgram(d),!m.getProgramParameter(d,m.VALIDATE_STATUS))throw new i.t("Program validation failed.  Program info log: "+m.getProgramInfoLog(d))}},Re.prototype.isDestroyed=function(){return!1},Re.prototype.destroy=function(){this._cachedShader.cache.releaseShaderProgram(this)},Re.prototype.finalDestroy=function(){return this._gl.deleteProgram(this._program),v.i(this)};var He=Object.freeze({ENVIRONMENT:0,COMPUTE:1,GLOBE:2,TERRAIN_CLASSIFICATION:3,CESIUM_3D_TILE:4,CESIUM_3D_TILE_CLASSIFICATION:5,CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW:6,S3MTiles:8,S3MTilesClampObjectStencil:9,S3MTilesClampObjectColor:10,ProjectionImage:11,OPAQUE:12,ClampObject:13,NonClampObject:14,Label_Billboard:15,Voxel_Billboard:16,Particle:17,TRANSLUCENT:18,ANALYSIS:19,LOG_DEPTH_OVERLAY:20,OVERLAY:21,OVERLAY_AGAINST_DEPTH:22,NUMBER_OF_PASSES:23}),Ue={FRONT:C.B.FRONT,BACK:C.B.BACK,FRONT_AND_BACK:C.B.FRONT_AND_BACK},ke=Object.freeze(Ue),Ge={NEVER:C.B.NEVER,LESS:C.B.LESS,EQUAL:C.B.EQUAL,LESS_OR_EQUAL:C.B.LEQUAL,GREATER:C.B.GREATER,NOT_EQUAL:C.B.NOTEQUAL,GREATER_OR_EQUAL:C.B.GEQUAL,ALWAYS:C.B.ALWAYS},We=Object.freeze(Ge),qe={ZERO:C.B.ZERO,KEEP:C.B.KEEP,REPLACE:C.B.REPLACE,INCREMENT:C.B.INCR,DECREMENT:C.B.DECR,INVERT:C.B.INVERT,INCREMENT_WRAP:C.B.INCR_WRAP,DECREMENT_WRAP:C.B.DECR_WRAP},Xe=Object.freeze(qe),Ye={CESIUM_3D_TILE_MASK:128,S3M_TILE:2,MODEL:6,SKIP_LOD_MASK:112,SKIP_LOD_BIT_SHIFT:4,CLASSIFICATION_MASK:15,setCesium3DTileBit:function(){return{enabled:!0,frontFunction:We.ALWAYS,frontOperation:{fail:Xe.KEEP,zFail:Xe.KEEP,zPass:Xe.REPLACE},backFunction:We.ALWAYS,backOperation:{fail:Xe.KEEP,zFail:Xe.KEEP,zPass:Xe.REPLACE},reference:Ye.CESIUM_3D_TILE_MASK,mask:Ye.CESIUM_3D_TILE_MASK}}},je=Object.freeze(Ye),Ze=[];function Ke(e,n){this.center=o.t.clone(a.u(e,o.t.ZERO)),this.halfAxes=f.p.clone(a.u(n,f.p.ZERO)),this.areaDirty=1}Ze[0]={num:0,des:"inside"},Ze[1]={num:4,data:[0,4,7,3],des:"left"},Ze[2]={num:4,data:[1,2,6,5],des:"right"},Ze[3]={num:0},Ze[4]={num:4,data:[0,1,5,4],des:"bottom"},Ze[5]={num:6,data:[0,1,5,4,7,3],des:"bottom, left"},Ze[6]={num:6,data:[0,1,2,6,5,4],des:"bottom, right"},Ze[7]={num:0},Ze[8]={num:4,data:[2,3,7,6],des:"top"},Ze[9]={num:6,data:[4,7,6,2,3,0],des:"top, left"},Ze[10]={num:6,data:[2,3,7,6,5,1],des:"top, right"},Ze[11]={num:0},Ze[12]={num:0},Ze[13]={num:0},Ze[14]={num:0},Ze[15]={num:0},Ze[16]={num:4,data:[0,3,2,1],des:"front"},Ze[17]={num:6,data:[0,4,7,3,2,1],des:"front, left"},Ze[18]={num:6,data:[0,3,2,6,5,1],des:"front, right"},Ze[19]={num:0},Ze[20]={num:6,data:[0,3,2,1,5,4],des:"front, bottom"},Ze[21]={num:6,data:[2,1,5,4,7,3],des:"front, bottom, left"},Ze[22]={num:6,data:[0,3,2,6,5,4],des:"front, bottom, right"},Ze[23]={num:0},Ze[24]={num:6,data:[0,3,7,6,2,1],des:"front, top"},Ze[25]={num:6,data:[0,4,7,6,2,1],des:"front, top, left"},Ze[26]={num:6,data:[0,3,7,6,5,1],des:"front, top, right"},Ze[27]={num:0},Ze[28]={num:0},Ze[29]={num:0},Ze[30]={num:0},Ze[31]={num:0},Ze[32]={num:4,data:[4,5,6,7],des:"back"},Ze[33]={num:6,data:[4,5,6,7,3,0],des:"back, left"},Ze[34]={num:6,data:[1,2,6,7,4,5],des:"back, right"},Ze[35]={num:0},Ze[36]={num:6,data:[0,1,5,6,7,4],des:"back, bottom"},Ze[37]={num:6,data:[0,1,5,6,7,3],des:"back, bottom, left"},Ze[38]={num:6,data:[0,1,2,6,7,4],des:"back, bottom, right"},Ze[39]={num:0},Ze[40]={num:6,data:[2,3,7,4,5,6],des:"back, top"},Ze[41]={num:6,data:[0,4,5,6,2,3],des:"back, top, left"},Ze[42]={num:6,data:[1,2,3,7,4,5],des:"back, top, right"},Ke.packedLength=o.t.packedLength+f.p.packedLength,Ke.pack=function(e,n,t){return i.o.typeOf.object("value",e),i.o.defined("array",n),t=a.u(t,0),o.t.pack(e.center,n,t),f.p.pack(e.halfAxes,n,t+o.t.packedLength),n},Ke.unpack=function(e,n,t){return i.o.defined("array",e),n=a.u(n,0),a.e(t)||(t=new Ke),o.t.unpack(e,n,t.center),f.p.unpack(e,n+o.t.packedLength,t.halfAxes),t};var $e=new o.t,Qe=new o.t,Je=new o.t,en=new o.t,nn=new o.t,tn=new o.t,on=new f.p,rn={unitary:new f.p,diagonal:new f.p},an=new o.t,ln=new o.t,cn=new o.t;Ke.fromPoints=function(e,n){if(a.e(n)||(n=new Ke),!a.e(e)||0===e.length)return n.halfAxes=f.p.ZERO,n.center=o.t.ZERO,n;var t,r=e.length,i=o.t.clone(e[0],$e);for(t=1;t<r;t++)o.t.add(i,e[t],i);var l=1/r;o.t.multiplyByScalar(i,l,i);var c,s=0,u=0,m=0,d=0,v=0,p=0;for(t=0;t<r;t++)s+=(c=o.t.subtract(e[t],i,Qe)).x*c.x,u+=c.x*c.y,m+=c.x*c.z,d+=c.y*c.y,v+=c.y*c.z,p+=c.z*c.z;s*=l,u*=l,m*=l,d*=l,v*=l,p*=l;var h=on;h[0]=s,h[1]=u,h[2]=m,h[3]=u,h[4]=d,h[5]=v,h[6]=m,h[7]=v,h[8]=p;var x=f.p.computeEigenDecomposition(h,rn),g=f.p.clone(x.unitary,n.halfAxes),_=f.p.getColumn(g,0,en),C=f.p.getColumn(g,1,nn),y=f.p.getColumn(g,2,tn),T=-Number.MAX_VALUE,z=-Number.MAX_VALUE,b=-Number.MAX_VALUE,L=Number.MAX_VALUE,S=Number.MAX_VALUE,w=Number.MAX_VALUE;for(t=0;t<r;t++)c=e[t],T=Math.max(o.t.dot(_,c),T),z=Math.max(o.t.dot(C,c),z),b=Math.max(o.t.dot(y,c),b),L=Math.min(o.t.dot(_,c),L),S=Math.min(o.t.dot(C,c),S),w=Math.min(o.t.dot(y,c),w);_=o.t.multiplyByScalar(_,.5*(L+T),_),C=o.t.multiplyByScalar(C,.5*(S+z),C),y=o.t.multiplyByScalar(y,.5*(w+b),y);var D=o.t.add(_,C,n.center);o.t.add(D,y,D);var E=Je;return E.x=T-L,E.y=z-S,E.z=b-w,o.t.multiplyByScalar(E,.5,E),f.p.multiplyByScale(n.halfAxes,E,n.halfAxes),n};var sn=new o.t,un=new o.t;function fn(e,n,t,r,l,c,s,u,m,d,v){if(!(a.e(l)&&a.e(c)&&a.e(s)&&a.e(u)&&a.e(m)&&a.e(d)))throw new i.t("all extents (minimum/maximum X/Y/Z) are required.");a.e(v)||(v=new Ke);var p=v.halfAxes;f.p.setColumn(p,0,n,p),f.p.setColumn(p,1,t,p),f.p.setColumn(p,2,r,p);var h=sn;h.x=(l+c)/2,h.y=(s+u)/2,h.z=(m+d)/2;var x=un;x.x=(c-l)/2,x.y=(u-s)/2,x.z=(d-m)/2;var g=v.center;return h=f.p.multiplyByVector(p,h,h),o.t.add(e,h,g),f.p.multiplyByScale(p,x,p),v}var mn=new o.t$1,dn=new o.t,vn=new o.t$1,pn=new o.t$1,hn=new o.t$1,xn=new o.t$1,gn=new o.t$1,_n=new o.t,Cn=new o.t,yn=new o.t,Tn=new o.t,zn=new o.t,bn=new t.o,Ln=new t.o,Sn=new t.o,wn=new t.o,Dn=new t.o,En=new o.t,An=new o.t,Vn=new o.t,Mn=new o.t,In=new t.o,Pn=new o.t,On=new o.t,Rn=new o.t,Fn=new m.o(o.t.UNIT_X,0);Ke.fromRectangle=function(e,n,t,r,s){if(!a.e(e))throw new i.t("rectangle is required");if(e.width<0||e.width>u.e.TWO_PI)throw new i.t("Rectangle width must be between 0 and 2*pi");if(e.height<0||e.height>u.e.PI)throw new i.t("Rectangle height must be between 0 and pi");if(a.e(r)&&!u.e.equalsEpsilon(r.radii.x,r.radii.y,u.e.EPSILON15))throw new i.t("Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)");var f,d,v,p,h,x,g;if(n=a.u(n,0),t=a.u(t,0),r=a.u(r,l.t.WGS84),e.width<=u.e.PI){var _=l.h.center(e,mn),C=r.cartographicToCartesian(_,dn),y=new c.f(C,r);g=y.plane;var T=_.longitude,z=e.south<0&&e.north>0?0:_.latitude,b=o.t$1.fromRadians(T,e.north,t,vn),L=o.t$1.fromRadians(e.west,e.north,t,pn),S=o.t$1.fromRadians(e.west,z,t,hn),w=o.t$1.fromRadians(e.west,e.south,t,xn),D=o.t$1.fromRadians(T,e.south,t,gn),E=r.cartographicToCartesian(b,_n),A=r.cartographicToCartesian(L,Cn),V=r.cartographicToCartesian(S,yn),M=r.cartographicToCartesian(w,Tn),I=r.cartographicToCartesian(D,zn),P=y.projectPointToNearestOnPlane(E,bn),O=y.projectPointToNearestOnPlane(A,Ln),R=y.projectPointToNearestOnPlane(V,Sn),F=y.projectPointToNearestOnPlane(M,wn),B=y.projectPointToNearestOnPlane(I,Dn);return d=-(f=Math.min(O.x,R.x,F.x)),p=Math.max(O.y,P.y),v=Math.min(F.y,B.y),L.height=w.height=n,A=r.cartographicToCartesian(L,Cn),M=r.cartographicToCartesian(w,Tn),h=Math.min(m.o.getPointDistance(g,A),m.o.getPointDistance(g,M)),x=t,fn(y.origin,y.xAxis,y.yAxis,y.zAxis,f,d,v,p,h,x,s)}var N=e.south>0,H=e.north<0,U=N?e.south:H?e.north:0,k=l.h.center(e,mn).longitude,G=o.t.fromRadians(k,U,t,r,En);G.z=0;var W=Math.abs(G.x)<u.e.EPSILON10&&Math.abs(G.y)<u.e.EPSILON10?o.t.UNIT_X:o.t.normalize(G,An),q=o.t.UNIT_Z,X=o.t.cross(W,q,Vn);g=m.o.fromPointNormal(G,W,Fn);var Y=o.t.fromRadians(k+u.e.PI_OVER_TWO,U,t,r,Mn);f=-(d=o.t.dot(m.o.projectPointOntoPlane(g,Y,In),X)),p=o.t.fromRadians(0,e.north,H?n:t,r,Pn).z,v=o.t.fromRadians(0,e.south,N?n:t,r,On).z;var j=o.t.fromRadians(e.east,U,t,r,Rn);return fn(G,X,q,W,f,d,v,p,h=m.o.getPointDistance(g,j),x=0,s)},Ke.clone=function(e,n){if(a.e(e))return a.e(n)?(o.t.clone(e.center,n.center),f.p.clone(e.halfAxes,n.halfAxes),n.areaDirty=1,n):new Ke(e.center,e.halfAxes)},Ke.intersectPlane=function(e,n){if(!a.e(e))throw new i.t("box is required.");if(!a.e(n))throw new i.t("plane is required.");var t=e.center,r=n.normal,l=e.halfAxes,c=r.x,u=r.y,m=r.z,d=Math.abs(c*l[f.p.COLUMN0ROW0]+u*l[f.p.COLUMN0ROW1]+m*l[f.p.COLUMN0ROW2])+Math.abs(c*l[f.p.COLUMN1ROW0]+u*l[f.p.COLUMN1ROW1]+m*l[f.p.COLUMN1ROW2])+Math.abs(c*l[f.p.COLUMN2ROW0]+u*l[f.p.COLUMN2ROW1]+m*l[f.p.COLUMN2ROW2]),v=o.t.dot(r,t)+n.distance;return v<=-d?s.S.OUTSIDE:v>=d?s.S.INSIDE:s.S.INTERSECTING};var Bn=new o.t,Nn=new o.t,Hn=new o.t,Un=new o.t,kn=new o.t;Ke.distanceSquaredTo=function(e,n){if(!a.e(e))throw new i.t("box is required.");if(!a.e(n))throw new i.t("cartesian is required.");var t=o.t.subtract(n,e.center,sn),r=e.halfAxes,l=f.p.getColumn(r,0,Bn),c=f.p.getColumn(r,1,Nn),s=f.p.getColumn(r,2,Hn),u=o.t.magnitude(l),m=o.t.magnitude(c),d=o.t.magnitude(s);o.t.normalize(l,l),o.t.normalize(c,c),o.t.normalize(s,s);var v=Un;v.x=o.t.dot(t,l),v.y=o.t.dot(t,c),v.z=o.t.dot(t,s);var p,h=0;return v.x<-u?h+=(p=v.x+u)*p:v.x>u&&(h+=(p=v.x-u)*p),v.y<-m?h+=(p=v.y+m)*p:v.y>m&&(h+=(p=v.y-m)*p),v.z<-d?h+=(p=v.z+d)*p:v.z>d&&(h+=(p=v.z-d)*p),h};var Gn=new o.t,Wn=new o.t;Ke.computePlaneDistances=function(e,t,r,l){if(!a.e(e))throw new i.t("box is required.");if(!a.e(t))throw new i.t("position is required.");if(!a.e(r))throw new i.t("direction is required.");a.e(l)||(l=new n.o);var c=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,u=e.center,m=e.halfAxes,d=f.p.getColumn(m,0,Bn),v=f.p.getColumn(m,1,Nn),p=f.p.getColumn(m,2,Hn),h=o.t.add(d,v,Gn);o.t.add(h,p,h),o.t.add(h,u,h);var x=o.t.subtract(h,t,Wn),g=o.t.dot(r,x);return c=Math.min(g,c),s=Math.max(g,s),o.t.add(u,d,h),o.t.add(h,v,h),o.t.subtract(h,p,h),o.t.subtract(h,t,x),g=o.t.dot(r,x),c=Math.min(g,c),s=Math.max(g,s),o.t.add(u,d,h),o.t.subtract(h,v,h),o.t.add(h,p,h),o.t.subtract(h,t,x),g=o.t.dot(r,x),c=Math.min(g,c),s=Math.max(g,s),o.t.add(u,d,h),o.t.subtract(h,v,h),o.t.subtract(h,p,h),o.t.subtract(h,t,x),g=o.t.dot(r,x),c=Math.min(g,c),s=Math.max(g,s),o.t.subtract(u,d,h),o.t.add(h,v,h),o.t.add(h,p,h),o.t.subtract(h,t,x),g=o.t.dot(r,x),c=Math.min(g,c),s=Math.max(g,s),o.t.subtract(u,d,h),o.t.add(h,v,h),o.t.subtract(h,p,h),o.t.subtract(h,t,x),g=o.t.dot(r,x),c=Math.min(g,c),s=Math.max(g,s),o.t.subtract(u,d,h),o.t.subtract(h,v,h),o.t.add(h,p,h),o.t.subtract(h,t,x),g=o.t.dot(r,x),c=Math.min(g,c),s=Math.max(g,s),o.t.subtract(u,d,h),o.t.subtract(h,v,h),o.t.subtract(h,p,h),o.t.subtract(h,t,x),g=o.t.dot(r,x),c=Math.min(g,c),s=Math.max(g,s),l.start=c,l.stop=s,l};var qn=new n.i;Ke.isOccluded=function(e,t){if(!a.e(e))throw new i.t("box is required.");if(!a.e(t))throw new i.t("occluder is required.");var o=n.i.fromOrientedBoundingBox(e,qn);return!t.isBoundingSphereVisible(o)},Ke.prototype.intersectPlane=function(e){return Ke.intersectPlane(this,e)},Ke.prototype.distanceSquaredTo=function(e){return Ke.distanceSquaredTo(this,e)},Ke.prototype.computePlaneDistances=function(e,n,t){return Ke.computePlaneDistances(this,e,n,t)},Ke.prototype.isOccluded=function(e){return Ke.isOccluded(this,e)},Ke.equals=function(e,n){return e===n||a.e(e)&&a.e(n)&&o.t.equals(e.center,n.center)&&f.p.equals(e.halfAxes,n.halfAxes)},Ke.prototype.clone=function(e){return Ke.clone(this,e)},Ke.prototype.equals=function(e){return Ke.equals(this,e)};var Xn=new r.e;Ke.prototype._updateBBox=function(){if(1==this.areaDirty){var e=f.p.getColumn(this.halfAxes,0,Bn),n=o.t.clone(o.t.negate(e,an)),t=f.p.getColumn(this.halfAxes,1,Nn),r=o.t.clone(o.t.negate(t,an)),i=f.p.getColumn(this.halfAxes,2,Hn),a=o.t.clone(o.t.negate(i,an));this.bbox=[],o.t.add(this.center,t,an),o.t.add(an,a,ln),o.t.add(ln,n,cn),this.bbox[0]=new o.t(cn.x,cn.y,cn.z),o.t.add(ln,e,cn),this.bbox[1]=new o.t(cn.x,cn.y,cn.z),o.t.add(an,i,ln),o.t.add(ln,e,cn),this.bbox[2]=new o.t(cn.x,cn.y,cn.z),o.t.add(ln,n,cn),this.bbox[3]=new o.t(cn.x,cn.y,cn.z),o.t.add(this.center,r,an),o.t.add(an,a,ln),o.t.add(ln,n,cn),this.bbox[4]=new o.t(cn.x,cn.y,cn.z),o.t.add(ln,e,cn),this.bbox[5]=new o.t(cn.x,cn.y,cn.z),o.t.add(an,i,ln),o.t.add(ln,e,cn),this.bbox[6]=new o.t(cn.x,cn.y,cn.z),o.t.add(ln,n,cn),this.bbox[7]=new o.t(cn.x,cn.y,cn.z);var l=o.t.magnitude(e),c=o.t.magnitude(t),s=o.t.magnitude(i),u=new o.t(-l,-c,-s),m=new o.t(l,c,s);if(l*c*s==0)return void(this.areaDirty=-1);o.t.normalize(e,e),o.t.normalize(t,t),o.t.normalize(i,i),this.u=o.t.clone(e),this.v=o.t.clone(t),this.w=o.t.clone(i),this.posMin=u,this.posMaX=m,this.areaDirty=0}};var Yn=void 0;Ke.prototype._createDeriveZBackfaceCommand=function(e){if(a.e(this.command))return this.command;this._updateBBox();for(var n=new Float32Array(24),t=0;t<8;t++)n[3*t]=this.bbox[t].x-this.center.x,n[3*t+1]=this.bbox[t].y-this.center.y,n[3*t+2]=this.bbox[t].z-this.center.z;a.e(Yn)||((Yn=new Uint8Array(36))[0]=3,Yn[1]=2,Yn[2]=6,Yn[3]=3,Yn[4]=6,Yn[5]=7,Yn[6]=0,Yn[7]=4,Yn[8]=1,Yn[9]=1,Yn[10]=4,Yn[11]=5,Yn[12]=4,Yn[13]=6,Yn[14]=5,Yn[15]=4,Yn[16]=7,Yn[17]=6,Yn[18]=0,Yn[19]=3,Yn[20]=4,Yn[21]=3,Yn[22]=7,Yn[23]=4,Yn[24]=0,Yn[25]=1,Yn[26]=2,Yn[27]=0,Yn[28]=2,Yn[29]=3,Yn[30]=1,Yn[31]=5,Yn[32]=6,Yn[33]=1,Yn[34]=6,Yn[35]=2);var o=v.h.createIndexBuffer({context:e,typedArray:Yn,usage:v.A.STATIC_DRAW,indexDatatype:p.IndexDatatype.UNSIGNED_BYTE});o.vertexArrayDestroyable=!1,o.referenceCount=1;var r=new L({context:e,attributes:[{index:0,vertexBuffer:v.h.createVertexBuffer({context:e,typedArray:n,usage:v.A.STATIC_DRAW}),componentDatatype:h.ComponentDatatype.FLOAT,componentsPerAttribute:3,offsetInBytes:0,strideInBytes:3*h.ComponentDatatype.getSizeInBytes(h.ComponentDatatype.FLOAT)}],indexBuffer:o}),i=["attribute vec4 position;","void main()","{","   gl_Position = czm_modelViewProjection * vec4(position.xyz, 1.0);","}"].join("\n"),l=["void main()","{","   gl_FragColor = vec4(1.0,0.0,0.0,0.3);","}"].join("\n"),c=new J({sources:[i]}),s=new J({sources:[l]});this.command=new D,this.command.cull=!1,this.command.boundingVolume=this,this.command.orientedBoundingBox=this,this.command.shaderProgram=Re.fromCache({context:e,vertexShaderSource:c,fragmentShaderSource:s,attributeLocations:{position:0}});var u=f.y.fromTranslation(this.center);return this.command.uniformMap={},this.command.modelMatrix=u,this.command.primitiveType=f._0x102869.TRIANGLES,this.command.vertexArray=r,this.command.count=Yn.length,this.command.pass=He.S3MTilesClampObjectStencil,this.command.renderState=_.u.fromCache({cull:{enabled:!0,face:ke.BACK},colorMask:{red:!1,green:!1,blue:!1,alpha:!1},stencilMask:je.SKIP_LOD_MASK,stencilTest:{enabled:!0,backFunction:We.NOT_EQUAL,backOperation:{fail:Xe.KEEP,zFail:Xe.REPLACE,zPass:Xe.REPLACE},frontFunction:We.NOT_EQUAL,frontOperation:{fail:Xe.KEEP,zFail:Xe.REPLACE,zPass:Xe.REPLACE},reference:je.SKIP_LOD_MASK,mask:je.SKIP_LOD_MASK}}),this.command};var jn=[];jn.push(new t.o),jn.push(new t.o),jn.push(new t.o),jn.push(new t.o),jn.push(new t.o),jn.push(new t.o);var Zn=new o.t$1,Kn=new o.t;Ke.prototype.calculateBoxArea=function(e,n,t,i,l,c,s,m){this._updateBBox();var v=e,p=o.t.subtract(v,this.center,kn);if(-1==this.areaDirty){var h=l/i*(w=-1!=c?c:.5*o.t.distance(this.posMaX,this.posMin))/t;return u.e.PI*h*h}var x=o.t.fromElements(o.t.dot(p,this.u),o.t.dot(p,this.v),o.t.dot(p,this.w),Gn),g=(x.x<this.posMin.x?1:0)+((x.x>this.posMaX.x?1:0)<<1)+((x.z<this.posMin.z?1:0)<<2)+((x.z>this.posMaX.z?1:0)<<3)+((x.y>this.posMaX.y?1:0)<<4)+((x.y<this.posMin.y?1:0)<<5);if(g>42)return console.log("area calculation is wrong"),-100;var _=Ze[g];if(0==_.num){h=l/i*(w=-1!=c?c:.5*o.t.distance(this.posMaX,this.posMin))/t;return u.e.PI*h*h}if(0==_.num)return console.log("area calculation is wrong"),-100;for(var C,y=[],T=s,z=0;z<_.num;z++){var b=jn[z],L=this.bbox[_.data[z]];C=!1;var S,w,D=u.e.PI;if(3===n)(S=f.y.multiplyByVector(T,r.e.fromElements(L.x,L.y,L.z,1),Xn)).z<0&&(C=!0,-1==w&&(D=u.e.PI_OVER_FOUR,t=o.t.magnitude(p)));else{var E=m,A=E.ellipsoid.cartesianToCartographic(L,Zn);a.e(A)?(E.project(A,Kn),(S=f.y.multiplyByVector(T,r.e.fromElements(Kn.z,Kn.x,Kn.y,1),Xn)).z<0&&(C=!0)):C=!0}if(1==C)return D*(h=l/i*(w=-1!=c?c:.5*o.t.distance(this.posMaX,this.posMin))/t)*h;b.x=S.x/S.w,b.y=l-S.y/S.w,y.push(b)}return Math.abs(d.A.computeArea2D(y))},e.x=Ke}));
